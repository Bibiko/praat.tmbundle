Abramowitz___Stegun__1970_	Abramowitz & Stegun (1970) M. Abramowitz & I. Stegun (1970): Handbook of mathematical functions. New York: Dover Publications. Links to this page concentration ellipse Confusion: To Dissimilarity (pdf)... 
Acknowledgments	Acknowledgments The following people contributed source code to Praat: Paul Boersma: user interface, graphics, printing, sound, spectral analysis, pitch analysis, formant analysis, intensity analysis, annotation, speech manipulation, voice report, listening experiments, articulatory synthesis, optimality-theoretic learning, tables, formulas, scripting, and adaptation of PortAudio, GLPK, and regular expressions. David Weenink: feedforward neural networks, principal component analysis, multidimensional scaling, discriminant analysis, LPC, VowelEditor, and adaptation of GSL, LAPACK, fftpack, regular expressions, and Espeak. Stefan de Konink and Franz Brauße: major help in port to GTK. Tom Naughton: major help in port to Cocoa. Erez Volk: adaptation of FLAC and MAD. Ola Söder: kNN classifiers, k-means clustering. Rafael Laboissière: adaptation of XIPA, audio bug fixes for Linux. Darryl Purnell created the first version of audio for Praat for Linux. We included the following freely available software libraries in Praat (sometimes with adaptations): XIPA: IPA font for Unix by Fukui Rei (GPL). GSL: GNU Scientific Library by Gerard Jungman and Brian Gough (GPL). GLPK: GNU Linear Programming Kit by Andrew Makhorin (GPL). PortAudio: Portable Audio Library by Ross Bencina, Phil Burk, Bjorn Roche, Dominic Mazzoni, Darren Gibbs. Espeak: text-to-speech synthesizer by Jonathan Duddington (GPL). MAD: MPEG Audio Decoder by Underbit Technologies (GPL). FLAC: Free Lossless Audio Codec by Josh Coalson. fftpack: public domain Fourier transforms by Paul Swarztrauber and Monty. LAPACK: public domain numeric algorithms by Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd., Courant Institute, Argonne National Lab, and Rice University. Regular expressions by Henry Spencer, Mark Edel, Christopher Conrad, Eddy De Greef (GPL). For technical support and advice: Ton Wempe, Dirk Jan Vet. For their financial support during the development of Praat: Netherlands Organization for Scientific Research (NWO) (1996–1999). Nederlandse Taalunie (2006–2008). Talkbank project, Carnegie Mellon / Linguistic Data Consortium (2002–2003). Stichting Spraaktechnologie (2014–2016). Spoken Dutch Corpus (CGN) (1999–2001). Laboratorium Experimentele OtoRhinoLaryngologie, KU Leuven. DFG-Projekt Dialektintonation, Universität Freiburg. Department of Linguistics and Phonetics, Lund University. Centre for Cognitive Neuroscience, University of Turku. Linguistics Department, University of Joensuu. Laboratoire de Sciences Cognitives et Psycholinguistique, Paris. Department of Linguistics, Northwestern University. Department of Finnish and General Linguistics, University of Tampere. Institute for Language and Speech Processing, Paradissos Amaroussiou. Jörg Jescheniak, Universität Leipzig. The Linguistics Teaching Laboratory, Ohio State University. Linguistics & Cognitive Science, Dartmouth College, Hanover NH. Cornell Phonetics Lab, Ithaca NY. Finally: Daniel Hirst, for managing the Praat Discussion list. 
Action_commands	Action commands The commands in the Dynamic menu of the Object window. These commands are only available if the right kinds of objects are selected. They are shown in a scrollable list, or in the Save menu if they start with Save as or Append to . Links to this page ButtonEditor 
Activation	Activation A Matrix whose elements must be >= 0 and <= 1. Classification: the response of a particular layer in a neural net to a Pattern.Learning: the desired response of the output layer in a neural net to a Pattern. Links to this page FFNet & Pattern & Activation: Get average costs... FFNet & Pattern & Activation: Get total costs... 
Add_action_command___	Add action command... One of the hidden commands in the Praat menu of the Object window. With this command, you add a button to the dynamic menu in the Object window. Settings See Add to dynamic menu.... Usage You can use this command in your initialization script or in plug-ins. Normally, however, if you want to add a command to the dynamic menu, you would use the command Add to dynamic menu... of the ScriptEditor instead. Links to this page ButtonEditor Hidden commands 
Add_menu_command___	Add menu command... One of the hidden commands in the Praat menu of the Object window. With this command, you add a button to any of the fixed menus in the Object or Picture window. Settings See Add to fixed menu.... Usage You can use this command in your initialization script or in plug-ins. Normally, however, if you want to add a command to a fixed menu, you would use the command Add to fixed menu... of the ScriptEditor instead. Links to this page ButtonEditor Hidden commands 
Add_to_dynamic_menu___	Add to dynamic menu... A command in the File menu of the ScriptEditor. With this command, you add a button to the dynamic menu in the Object window. This button will only be visible if the specified combination of objects is selected. Clicking the button will invoke the specified Praat script. Settings Class 1 the name of the class of the object to be selected. For instance, if a button should only appear if the user selects a Sound, this would be Sound. Number 1 the number of objects of class1 that have to be selected. For most built-in commands, this number is unspecified (0); e.g., the user can choose Draw... or To Spectrum regardless of whether she selected 1, 2, 3, or more Sound objects. If the number of selected objects is different from number1, the button will be visible but insensitive. Class 2 the name of the class of the second object to be selected, different from class1. Normally the empty string (). Number 2 the number of selected objects of class2. Class 3 the name of the class of the third object to be selected, different from class1 and class2. Normally the empty string (). Number 3 the number of selected objects of class3. Command the title of the new command button (or label, or submenu title). To get a separator line instead of a command text (only in a submenu), you specify a unique string that starts with a hyphen ('-'); the ButtonEditor may contain some examples of this. If the command starts with Save as , it will be placed in the Save menu. After command a button title in the dynamic menu or submenu where you want your new button. If you specify the empty string (), your button will be put at the bottom. You can specify a push button, a label (subheader), or a cascade button (submenu title) here. Depth 0 if you want your button in the main menu, 1 if you want it in a submenu. Script the full path name of the script to invoke. If you saved the script you are editing, its name will already have been filled in here. If you do not specify a script, you will get a separating label or cascading menu title instead, depending on the depth of the following command. Example If one object of class Sound is selected, you want a submenu called Filters after the Convolve button, containing the commands Autocorrelation and Band filter..., separated by a horizontal separator line: Add to dynamic menu: Sound, 0, , 0, , 0, Filters -, Convolve, 0, Add to dynamic menu: Sound, 1, , 0, , 0, Autocorrelation, Filters -, 1, /u/praats/demo/autocorrelation.praat Add to dynamic menu: Sound, 0, , 0, , 0, -- band filter --, Autocorrelation, 1, Add to dynamic menu: Sound, 1, , 0, , 0, Band filter..., -- band filter --, 1, /u/praats/demo/bandFilter.praat Note that Filters - will be a submenu title, because it is followed by subcommands (depth 1). Note that number1 is 1 only for the executable buttons; for the cascade button and the separator line, this number is ignored. Usage convention Please adhere to the convention that command that take arguments, such as Band filter... above, end in three dots. Using this command in a script To add a dynamic button from a script (perhaps your initialization script or a plug-in), use the hidden shell command Add action command... instead. Links to this page Add to fixed menu... History mechanism 
Add_to_fixed_menu___	Add to fixed menu... A command in the File menu of the ScriptEditor. With this command, you add a button to any fixed menu in the Object window or in the Picture window. Clicking the added button will invoke the specified Praat script. Settings Window the name of the window (Objects or Picture) that contains the menu that you want to change. Menu the title of the menu that you want to change. If window is Objects, you can specify the Praat, New, Open, Help, Goodies, Preferences, or Technical menu (for the Save menu, which depends on the objects selected, you would use Add to dynamic menu... instead). If window is Picture, you can specify the File, Edit, Margins, World, Select, Pen, Font, or Help menu. Command the title of the new menu button. To get a separator line instead of a command text, you specify a unique string that starts with a hyphen ('-'); the ButtonEditor contains many examples of this. After command a button title in the menu or submenu after which you want your new button to be inserted. If you specify the empty string (), your button will be put in the main menu. Depth 0 if you want your button in the main menu, 1 if you want it in a submenu. Script the full path name of the script to invoke. If you saved the script you are editing, its name will already have been filled in here. If you do not specify a script, you will get a cascading menu title instead. Example 1 In the Matrix submenu of the New menu, you want a separator line followed by the command Peaks: Add to fixed menu: Objects, New, -- peaks --, Create simple Matrix..., 1, Add to fixed menu: Objects, New, Peaks, -- peaks --, 1, /u/praats/demo/peaks.praat Example 2 In the New menu, you want a submenu called Demo, with a subitem titled Lorenz...: Add to fixed menu: Objects, New, Demo, , 0,, Add to fixed menu: Objects, New, Lorenz..., Demo, 1, /u/praats/demo/lorentz.praat Usage convention Please adhere to the convention that command that take arguments, such as Lorenz... above, end in three dots. Using this command in a script To add a fixed button from a script (perhaps your initialization script or a plug-in), use the hidden shell command Add menu command... instead. Links to this page History mechanism 
Advanced_pitch_settings___	Advanced pitch settings... A command in the Pitch menu of the SoundEditor or TextGridEditor windows. Before changing the advanced pitch settings, make sure you understand Intro 4.2. Configuring the pitch contour. View range different from analysis range Normally, the range of pitch values that can be seen in the editor window is equal to the range of pitch values that the analysis algorithm can determine. If you set the analysis range from 75 to 500 Hz, this will be the range you see in the editor window as well. If the pitch values in the curve happen to be between 350 and 400 Hz, you may want to zoom in to the 350-400 Hz pitch region. You will usually do this by changing the pitch range in the Pitch settings... window. However, the analysis range will also change in that case, so that the curve itself may change. If you do not want that, you can change the View range settings from 0.0 (= auto) - 0.0 (=auto) to something else, perhaps 350 - 400. Pitch analysis settings For information about these, see Sound: To Pitch (ac).... The standard settings are best in most cases. For some pathological voices, you will want to set the voicing threshold to much less than the standard of 0.45, in order to get pitch values even in irregular parts of the signal. Links to this page FAQ: Pitch analysis 
Advanced_pulses_settings___	Advanced pulses settings... A command in the Pulses menu of the SoundEditor or TextGridEditor windows. Before changing the advanced pulses settings, make sure you understand the Voice tutorial. For information about the Maximum period factor setting, see PointProcess: Get jitter (local).... The standard setting is best in most cases. The Period floor and Period ceiling settings derive from the pitch floor and pitch ceiling (Pitch settings...), according to a formula given in Voice 2. Jitter. 
Advanced_spectrogram_settings___	Advanced spectrogram settings... Optimization Number of time steps the maximum number of points along the time window for which Praat has to compute the spectrum. If your screen is not wider than 1200 pixels, then the standard of 1000 is appropriate, since there is no point in computing more than one spectrum per one-pixel-wide vertical line. If you have a really wide screen, you may see improvement if you raise this number to 1500. Number of frequency steps the maximum number of points along the frequency axis for which Praat has to compute the spectrum. If your screen is not taller than 768 pixels, then the standard of 250 is appropriate, since there is no point in computing more than one spectrum per one-pixel-height horizontal line. If you have a really tall screen, you may see improvement if you raise this number. For purposes of computation speed, Praat may decide to change the time step and the frequency step. This is because the time step never needs to be smaller than 1/(8√π) of the window length, and the frequency step never needs to be smaller than (√π)/8 of the inverse of the window length. For instance, if the window length is 5 ms, the actual time step will never be less than 5/(8√π) = 0.353 ms, and the actual frequency step will never be less than (√π)/8/0.005 = 44.31 Hz. Spectrogram analysis settings Method there is currently only one method available in this window for computing a spectrum from a sound: the Fourier transform. Window shape the shape of the analysis window. To compute the spectrum at, say, 3.850 seconds, samples that lie close to 3.850 seconds are given more weight than samples further away. The relative extent to which each sample contributes to the spectrum is given by the window shape. You can choose from: Gaussian, Square (none, rectangular), Hamming (raised sine-squared), Bartlett (triangular), Welch (parabolic), and Hanning (sine-squared). The Gaussian window is superior, as it gives no sidelobes in your spectrogram (see below); it analyzes a factor of 2 slower than the other window shapes, because the analysis is actually performed on twice as many samples per frame. Sidelobes; anybody wants to win a cake? The Gaussian window is the only shape that we can consider seriously as a candidate for the analysis window. To see this, create a 1000-Hz sine wave with Create Sound from formula... by typing 1/2 * sin (2*pi*1000*x) as the formula, then click View & Edit. If the window shape is Gaussian, the spectrogram will show a horizontal black line. If the window shape is anything else, the spectrogram will show many horizontal grey lines (sidelobes), which do not represent anything that is available in the signal. They are artifacts of the window shapes. We include these other window shapes only for pedagogical purposes and because the Hanning and Hamming windows have traditionally been used in other programs before computers were as fast as they are now (a spectrogram is computed twice as fast with these other windows). Several other programs still use these inferior window shapes, and you are likely to run into people who claim that the Gaussian window has disadvantages. We promise such people a large cake if they can come up with sounds that look better with Hanning or Hamming windows than with a Gaussian window. An example of the reverse is easy to find; we have just seen one. Spectrogram blackness settings Autoscaling Maximum (dB/Hz) all parts of the spectrogram that have a power above maximum (after preemphasis) will be drawn in black. The standard maximum is 100 dB/Hz, but if autoscaling is on (which is the standard), Praat will use the maximum of the visible part of the spectrogram instead; this ensures that the window will always look well, but it also means that the blackness of a certain part of the spectrogram will change as you scroll. Preemphasis (dB/octave) determines the steepness of a high-pass filter, i.e., how much the power of higher frequencies will be raised before drawing, as compared to lower frequencies. Since the spectral slope of human vowels is approximately -6 dB per octave, the standard value for this setting is +6 dB per octave, so that the spectrum is flattened and the higher formants look as strong as the lower ones. When you raise the preemphasis, frequency bands above 1000 Hz will become darker, those below 1000 Hz will become lighter. Dynamic compression determines how much stronger weak spectra should be made before drawing. Normally, this parameter is between 0 and 1. If it is 0 (the standard value), there is no dynamic compression. If it is 1, all spectra will be drawn equally strong, i.e., all of them will contain frequencies that are drawn in black. If this parameter is 0.4 and the global maximum is at 80 dB, then a spectrum with a maximum at 20 dB (which will normally be drawn all white if the dynamic range is 50 dB), will be raised by 0.4 * (80 - 20) = 24 dB, so that its maximum will be seen at 44 dB (thus making this frame visible). Links to this page Intro 3.2. Configuring the spectrogram 
AffineTransform	AffineTransform One of the types of objects in PRAAT. An affine transform is a combination of a linear transformation A and a translation t that transforms a vector x to a new vector y in the following way: y = A x + t Links to this page AffineTransform: Invert Configuration & AffineTransform: To Configuration Configurations: To AffineTransform (congruence)... Procrustes 
AffineTransform__Invert	AffineTransform: Invert Get the inverse of the selected AffineTransform object. The inverse from y = A x + t is: x = A-1 - A-1t. 
AIFF_and_AIFC_files	AIFF and AIFC files Ways for storing a Sound object on disk. File format Reading Read from file... recognizes AIFF and AIFC files with 8-bit and 16-bit encoding, but not compressed AIFC files. It recognizes any sampling frequency. The two channels of stereo files are averaged. Read two Sounds from AIFF file... reads both channels separately and names them left and right. The sample values are divided by 2(numberOfBitsPerSample – 1), so that the amplitude of the resulting Sound is between –1.0 and +1.0; the maximum sound pressure level for a sine wave is therefore: 20 · 10log (√2 / 2·10–5) = 91 dB. The resulting Sound will appear in the List of Objects; its name will be equal to the file name, without extension. Saving With Save as AIFF file.... The samples of the Sound are multiplied by 32768 and quantized between –32768 and 32767. To avoid clipping, keep the absolute amplitude below 1.000. If the maximum sound pressure level is 91 dB (top = 32767), the quantization threshold is (top = 1/2) –5 dB. 
aliasing	aliasing Aliasing (Du. vouwvervorming) is the phenomenon of the ambiguity of a sampled signal. Example With a sampling frequency of 10 kHz, a sine wave with a frequency of 3 kHz receives the same representation as a sine wave with a frequency of 7 kHz, 13 kHz, or 17 kHz, and so on. If the sampled signal is meant to represent a continuous spectral range starting at 0 Hz (which is the most common case for speech recordings), all these tones are likely to be interpreted as 3 kHz tones after sampling. To remedy this unwanted situation, the signal is usually low-pass filtered with a cut-off frequency just below 5 kHz, prior to sampling. Links to this page Create Sound from gammatone... Nyquist frequency sampling frequency 
AmplitudeTier	AmplitudeTier One of the types of objects in Praat. An AmplitudeTier object represents a time-stamped amplitude contour, i.e., it contains a series of (time, amplitude) points. The amplitude values are in Pascal. To see some applications, consult the IntensityTier information; the difference between an AmplitudeTier and an IntensityTier is that the former has values in Pascal which multiply linearly with a Sound (for instance), and the latter has values in dB, which multiply logarithmically with a Sound. Links to this page constant extrapolation Intro 8.3. Manipulation of intensity linear interpolation 
Anderson__1935_	Anderson (1935) E. Anderson (1935): The irises of the Gaspé peninsula. Bulletin of the American Iris Society 59: 2–5. Links to this page iris data set 
Anderson__1978_	Anderson (1978) N. Anderson (1978): On the calculation of filter coefficients for maximum entropy spectral analysis. In Childers: Modern Spectrum Analysis, IEEE Press: 252–255. Links to this page Sound: To LPC (burg)... 
Archangeli___Pulleyblank__1994_	Archangeli & Pulleyblank (1994) Diana Archangeli & Douglas Pulleyblank (1994): Grounded phonology. Cambridge, MA: MIT Press. Links to this page Create tongue-root grammar... OT learning 3.2. Data from another grammar 
Articulatory_synthesis	Articulatory synthesis This is a description of the articulatory synthesis package in Praat. For a detailed description of the physics and mathematics behind the model, see Boersma (1998), chapters 2 and 3. For examples of how to synthesize utterances, consult http://www.fon.hum.uva.nl/paul/diss/ch5/. How to start (after reading the Intro) We are going to have the synthesizer say [əpə]. We need a Speaker and an Artword object. 1. Create a speaker with Create Speaker... from the New menu. 2. Create an articulation word of 0.5 seconds with Create Artword.... 3. Edit the Artword by selecting it and clicking View & Edit. 4. To set the glottis to a position suitable for phonation, use the ArtwordEditor to set the Interarytenoid activity to 0.5 throughout the utterance. You set two targets: 0.5 at a time of 0 seconds, and 0.5 at a time of 0.5 seconds. 5. To prevent air escaping from the nose, close the nasopharyngeal port by setting the LevatorPalatini activity to 1.0 throughout the utterance. 6. To generate the lung pressure needed for phonation, you set the Lungs activity at 0 seconds to 0.2, and at 0.1 seconds to 0. 7. To force a jaw movement that closes the lips, set the Masseter activity at 0.25 seconds to 0.7, and the OrbicularisOris activity at 0.25 seconds to 0.2. 8. Select the Speaker and the Artword and click Movie; you will see a closing-and-opening gesture of the mouth. 9. Select the Speaker and the Artword and click To Sound... (see Artword & Speaker: To Sound...). 10. Just click OK; the synthesis starts. 11. If you are sitting at a 1997 computer, this will last for 5 minutes or so; at a 2010 computer, 6 seconds. If this is too slow for you, click Interrupt. Otherwise, you can watch the vibrating vocal cords and the changing vocal-tract shape. 12. You can play, view, and analyse the resulting Sound as you would any other. You can see and hear a sound movie if you select the Speaker, the Artword, and the Sound, and click Play. Links to this page Acknowledgments Types of objects 
Artword	Artword One of the types of objects in Praat. See Articulatory synthesis. An object of class Artword object represents the activities of several speech muscles as functions of time. Artword commands • Create Artword...: creates an Artword with relaxed muscles • Artword & Speaker: To Sound...: articulatory synthesis 
Artword___Speaker__To_Sound___	Artword & Speaker: To Sound... A command to synthesize a Sound object from the selected Speaker and the selected Artword. This is the command that performs the actual articulatory synthesis. See Articulatory synthesis. Settings Sampling frequency (Hz) the number of times per second that the equilibrium widths and lengths and the tensions of the muscles are recomputed from the Artword. This will also be the sampling frequency of the resulting sound and of the optional resulting tube widths, air pressures, and air velocities. The standard value is 22050 Hz. Oversampling the number of times that the aerodynamic quantities and the state of the tube walls will be recomputed during each sample period. The standard value is 25. Width 1, Width 2, Width 3 the numbers (see below) of the tubes whose widths you want to monitor. E.g., if Width 1 is 36, the synthesizer will create a Sound object named width36, which contains the width of tube 36 (the lower glottis) as a function of time, expressed in metres. To prevent the creation of a width object, specify 0 (the standard value). Pressure 1, Pressure 2, Pressure 3 the numbers (see below) of the tubes whose air pressures you want to monitor. E.g., if Pressure 3 is 37, the synthesizer will create a Sound object named pressure37, which contains the air pressure of tube 37 (the upper glottis) as a function of time, expressed in Pascal. To prevent the creation of a pressure object, specify 0 (the standard value). Velocity 1, Velocity 2, Velocity 3 the numbers (see below) of the tubes whose air velocities you want to monitor. E.g., if Velocity 1 is 60, the synthesizer will create a Sound object named velocity60, which contains the air velocity of tube 60 (in the mouth) as a function of time, expressed in metres per second. To prevent the creation of a velocity object, specify 0 (the standard value). Stability The internal sampling frequency for the aerodynamics is the specified Sampling frequency, multiplied by the specified Oversampling. With the standard settings, this is 22050 times 25 = 550750 Hz. To ensure the stability of the synthesis, this internal sampling frequency should not be less than the velocity of sound (353 m/s) divided by the length of the shortest tube. For the standard Female, Male, and Child speakers, the shortest tube is the upper glottis, which has a length of 0.7, 1.0, and 0.3 millimetres, respectively. The minimum internal sampling frequencies, therefore, are 504286, 353000, and 1176667 hertz, respectively. Time resolution To capture the microscopic pressure changes in the glottis, you will want maximum time resolution. For a female speaker, you could set Sampling frequency to 550750 Hz, and Oversampling to 1. Tube numbers Here are the tube numbers that you can use for the Width, Pressure, and Velocity settings: 1..23: lungs (from bottom to top) 24..29: bronchi (from bottom to top) 30..35: trachea (from bottom to top) 36: lower glottis 37: upper glottis (not for a one-mass model) 38..49: pharynx (from bottom to top) 50..51: nasopharyngeal branching 52..64: mouth (from back to front) 65..78: nose (from back to front) 79..86: conus elasticus (only for a 10-mass model) 87..89: glottal shunt between the arytenoids (from bottom to top) Some structural properties: • Tube 1 is closed at the bottom. • Tubes 64 (lips) and 78 (nostrils) radiate into the air. • The nasopharyngeal branch is at tubes 50, 51, and 65. They are constrained to have equal lengths. • For a one-mass model of the vocal cords, tube 36 is connected to 38. • For a 10-mass model, tubes 32..35 are replaced with 79..86, so that tube 31 is connected to 79, and 86 is connected to 36. • A glottal shunt will be implemented if the speaker's shunt.Dx attribute is not zero. A branch is then made from tubes 34 and 35 (or 85 and 86) to 87, and from tube 89 to 38 and 39. Links to this page Create Speaker... 
audio_control_panel	audio control panel Your system's way of controlling where sounds will be played, and how loud. On Windows, double-click the loudspeaker icon in the Start bar. On MacOS X, go to System Preferences, then to Sound, then to Output Volume (you can put a loudspeaker icon in OSX's menu bar here). On HP-UX, try the Use internal loudspeaker... preference in Praat's Preferences menu. Links to this page Sound: Play 
Axes___	Axes... One of the commands in the Margins and World menus of the Picture window. Purpose To view and change the current world coordinates of the horizontal and vertical axes. Usage The axes are normally changed by every drawing operation in the dynamic menu, i.e., by object-specific drawing commands with titles like Draw... and Paint... (the drawing commands in the Picture window, like Paint rectangle..., do not change the axes). You would use the Axes... command if your data are not in an object. Example The following script would draw a person's vowel triangle: # Put F1 (between 300 and 800 Hz) along the horizontal axis, # and F2 (between 600 and 3600 Hz) along the vertical axis. Axes: 300, 800, 600, 3600 # Draw a rectangle inside the current viewport (selected area), # with text in the margins, and tick marks in steps of 100 Hz along the F1 axis, # and in steps of 200 Hz along the F2 axis. Draw inner box Text top: no, Daniël's Dutch vowel triangle Text bottom: yes, %F_1 (Hz) Text left: yes, %F_2 (Hz) Marks bottom every: 1, 100, yes, yes, yes, Marks left every: 1, 200, yes, yes, yes, # Draw large phonetic symbols at the vowel points. Text special: 340, Centre, 688, Half, Times, 24, 0, u Text special: 481, Centre, 1195, Half, Times, 24, 0, ø # Etcetera This example would draw the texts Daniël's Dutch vowel triangle, F1 (Hz), and F2 (Hz) in the margins, and the texts u and ø at the appropriate positions inside the drawing area. Links to this page Demo window Insert picture from file... 
Bai___Demmel__1993_	Bai & Demmel (1993) Z. Bai & J. Demmel (1993): Computing the generalized singular value decomposition. SIAM J. Sci. Comput. 14: 1464–1486. 
Band_filtering_in_the_frequency_domain	Band filtering in the frequency domain We describe how band filtering in the frequency domain is performed. We start with a Sound and end with a filter bank representation of this sound. We assume a standard analysis context: a sound divided into frames according to a certain window length and time step. We will simulate a filterbank with N filters. The algorithm for each sound frame proceeds in the following way: 1. Apply a Gaussian window to the sound frame. 2. Convert the windowed frame into a Spectrum object. 3. Convert the spectral amplitudes to energy values by squaring the real and imaginary parts and multiplying by df, the frequency distance between two successive frequency points in the spectrum. Since the Spectrum object only contains positive frequencies, we have to multiply all energy values, except the first and the last frequency, by another factor of 2 to compensate for negative frequencies. 4. For each of the N filters in the filter bank: determine the inner product of its filter function with the energies as determined in the previous step. The result of each inner product is the energy in the corresponding filter. 5. Convert the energies in each filter to power by dividing by the window length. 6. Correct the power, due to the windowing of the frame, by dividing by the integral of the squared windowing function. 7. Convert all power values to dB's according to 10 * log10 (power / 4 10-10). Links to this page Filtering Sound & Pitch: To FormantFilter... Sound: To BarkFilter... Sound: To FormantFilter... Sound: To MelFilter... What was new in 4.0? 
BarkFilter	BarkFilter One of the types of objects in PRAAT. An object of type BarkFilter represents an acoustic time-frequency representation of a sound: the power spectral density P(z, t), expressed in dB's. It is sampled into a number of points around equally spaced times ti and frequencies zj (on a Bark scale). Inside a BarkFilter With Inspect you will see that this type contains the same attributes a Matrix. Links to this page Sound: To BarkFilter... What was new in 4.0? 
Bartlett__1954_	Bartlett (1954) M.S. Bartlett (1954): A note on multiplying factors for various chi-squared approximations., Joural of the Royal Statistical Society, Series B 16: 296–298 Links to this page SSCP: Get diagonality (bartlett)... 
BHEP_multivariate_normality_test	BHEP multivariate normality test The Baringhaus–Henze–Epps–Pulley multivariate normality test. According to Henze & Wagner (1997) the test has: affine invariance, consistency against each fixed nonnormal alternative distribution, asymptotic power against contiguous alternatives of order √ (n), feasibility for any dimension and any sample size. The test depends on a smoothing parameter h that can be chosen in various ways: Henze & Wagner (1997) recommend h = 1.41, while Tenreiro (2009) recommends hs = 0.448 + 0.026·d for short tailed alternatives and hl = 0.928 + 0.049·d for long tailed alternatives. Links to this page GaussianMixture & TableOfReal: To TableOfReal (BHEP normality tests)... TableOfReal: Report multivariate normality (BHEP)... 
binomialQ	binomialQ A function that can be used in Formulas. The complement of the cumulative binomial distribution. Syntax binomialQ (p, k, n) the probability that in n trials an event with probability p will occur at least k times. Calculator example A die is suspected to yield more sixes than a perfect die would do. In order to test this suspicion, you throw it 1,000 times. The result is 211 sixes. The probability that a perfect die yields at least 211 sixes is, according to Calculator..., binomialQ (1/6, 211, 1000) = 0.000152. Script example You convert 1000 values of pitch targets in Hz to the nearest note on the piano keyboard. 597 of those values turn out to be in the A, B, C, D, E, F, or G regions (the white keys), and 403 values turn out to be in the A#, C#, D#, F#, or G# regions (the black keys). Do our subjects have a preference for the white keys? The following script computes the probability that in the case of no preference the subjects would target the white keys at least 597 times. This is compared with a χ2 test. a = 597 b = 403 p = 7/12 ; no preference writeInfoLine: *** Binomial test , a, , , b, , p = , fixed$ (p, 6), *** pbin = binomialQ (p, a, a+b) appendInfoLine: P (binomial) = , fixed$ (pbin, 6) # Chi-square test with Yates correction: x2 = (a - 1/2 - p * (a+b))^2/(p*(a+b)) + (b + 1/2 - (1-p) * (a+b))^2/((1-p)*(a+b)) px2 = chiSquareQ (x2, 1) appendInfoLine: P (chi-square) = , fixed$ (px2, 6) The result is: *** Binomial test 597, 403, p = 0.583333 *** P (binomial) = 0.199330 P (chi-square) = 0.398365 The χ2 test is two-sided (it signals a preference for the white or for the black keys), so it has twice the probability of the binomial test. We cannot conclude from this test that people have a preference for the white keys. Of course, we cannot conclude either that people do not have such a preference. Links to this page Formulas 4. Mathematical functions 
Bishop__2006_	Bishop (2006) C.M. Bishop (2006): Pattern recognition and machine learning. Springer. Links to this page GaussianMixture TableOfReal: To GaussianMixture... 
blind_source_separation	blind source separation Blind source separation (BSS) is a technique for estimating individual source components from their mixtures at multiple sensors. It is called blind because we don't use any other information besides the mixtures. For example, imagine a room with a number of persons present and a number of microphones for recording. When one or more persons are speaking at the same time, each microphone registers a different mixture of individual speaker's audio signals. It is the task of BSS to untangle these mixtures into their sources, i.e. the individual speaker's audio signals. In general, this is a difficult problem because of several complicating factors. Different locations of speakers and microphones in the room: the individual speaker's audio signals do not reach all microphones at the same time. Room acoustics: the signal that reaches a microphone is composed of the signal that directly travels to the microphone and parts that come from room reverberations and echos. Varying distances to microphones: one or more speakers might be moving. This makes the mixing time dependent. If the number of sensors is larger than the number of sources we speak of an overdetermined problem. If the number of sensors and the number of sources are equal we speak of a determined problem. The more difficult problem is the underdetermined one where the number of sensors is less than the number of sources. Typology of mixtures In general two different types of mixtures are considered in the literature: instantaneous mixtures and convolutive mixtures. Instantaneous mixtures where the mixing is instantaneous, corresponds to the model Y=A·X. In this model Y is a matrix with the recorded microphone sounds, A is a so-called mixing matrix and X is a matrix with the independent source signals. Essentially the model says that the signal that each microphone records is a (possibly different) linear combination of the same source signals. If we would know the mixing matrix A we could easily solve the model above for X by standard means. However, in general we don't know A and X and there are an infinite number of possible decompositions for Y. The problem is however solvable by making some (mild) assumptions about A and X. Convolutive mixtures are mixtures where the mixing is of convolutive nature, i.e. the model is yi (n) = ΣjdΣτMij-1 hij(τ)xj(n-τ) + Ni(n), for i=1..m. Here yi (n) is the n-th sample of the i-th microphone signal, m is the number of microphones, hij(τ) is the multi-input multi-output linear filter with the source-microphone impulse responses that characterize the propagation of the sound in the room and Ni is a noise source. This model is typically much harder to solve than the previous one because of the hij(τ) filter term that can have thousands of coefficients. For example, the typical reverberation time of a room is approximately 0.3 s which corresponds to 2400 samples, i.e. filter coefficients, for an 8 kHz sampled sound. Solving the blind source separation for instantaneous mixtures Various techniques exist for solving the blind source separation problem for instantaneous mixtures. Very popular ones make make use of second order statistics (SOS) by trying to simultaneously diagonalize a large number of cross-correlation matrices. Other techniques like independent component analysis use higher order statistics (HOS) to find the independent components, i.e. the sources. Given the decomposition problem Y=A·X, we can see that the solution is determined only upto a permutation and a scaling of the components. This is called the indeterminancy problem of BSS. This can be seen as follows: given a permutation matrix P, i.e. a matrix which contains only zeros except for one 1 in every row and column, and a diagonal scaling matrix D, any scaling and permutation of the independent components Xn=(D·P)·X can be compensated by the reversed scaling of the mixing matrix An=A·(D·P)-1 because A·(D·P)-1·(D·P)·X = A·X = Y. Solving the blind source separation for convolutive mixtures Solutions for convolutive mixture problems are much harder to achieve. One normally starts by transforming the problem to the frequency domain where the convolution is turned into a multiplication. The problem then translates into a separate instantaneous mixing problem for each frequency in the frequency domain. It is here that the indeterminacy problem hits us because it is not clear beforehand how to combine the independent components of each frequency bin. Links to this page Sound: To Sound (blind source separation)... 
Boersma__1993_	Boersma (1993) Paul Boersma (1993): Accurate short-term analysis of the fundamental frequency and the harmonics-to-noise ratio of a sampled sound. Proceedings of the Institute of Phonetic Sciences 17: 97–110. University of Amsterdam. Can be downloaded as a PDF file from http://www.fon.hum.uva.nl/paul/ Links to this page Sound: Autocorrelate... Sound: To Harmonicity (ac)... Sound: To Pitch (ac)... Voice 5. Comparison with other programs 
Boersma__1997_	Boersma (1997) Paul Boersma (1997): How we learn variation, optionality, and probability. Proceedings of the Institute of Phonetic Sciences 21: 43–58. University of Amsterdam. Available from http://www.fon.hum.uva.nl/paul/. Equals chapter 15 of Boersma (1998). A less correct version (demoting and promoting a single pair of constraints, instead of them all) is available as Rutgers Optimality Archive 221, http://ruccs.rutgers.edu/roa.html Links to this page OT learning 1. Kinds of grammars OTGrammar & 2 Strings: Learn... 
Boersma__1998_	Boersma (1998) Paul Boersma (1998): Functional Phonology [LOT International Series 11]. The Hague: Holland Academic Graphics. Pages i-ix, 1-493. [Doctoral thesis, University of Amsterdam] This book can be downloaded as a PDF file from http://www.fon.hum.uva.nl/paul/, where you can also find many Praat scripts for the simulations and pictures in this book. A paperback version is also available from the author (paul.boersma@uva.nl). Links to this page Articulatory synthesis Boersma (1997) Boersma (2000) Create tongue-root grammar... OT learning 2.4. Evaluation OT learning 3.2. Data from another grammar OT learning 6. Shortcut to grammar learning OTGrammar: Learn one... phonToDifferenceLimens 
Boersma__2000_	Boersma (2000) Paul Boersma (2000): Learning a grammar in Functional Phonology. In Joost Dekkers, Frank van der Leeuw, & Jeroen van de Weijer (eds.): Phonology, Syntax, and Acquisition in Optimality Theory. Oxford University Press. An extended version is chapter 14 of Boersma (1998). Links to this page Create tongue-root grammar... OTGrammar: Learn one... 
Boersma__2009a_	Boersma (2009a) Paul Boersma (2009): Should jitter be measured by peak picking or by waveform matching? Folia Phoniatrica et Logopaedica 61: 305–308. Can be downloaded as a PDF file from http://www.fon.hum.uva.nl/paul/ Links to this page Voice 5. Comparison with other programs 
Boersma__2009b_	Boersma (2009b) Paul Boersma (2009b): Some correct error-driven versions of the Constraint Demotion algorithm. Linguistic Inquiry 40: 667–686. Can be downloaded as a PDF file from http://www.fon.hum.uva.nl/paul/ Links to this page OT learning 1. Kinds of grammars OT learning 4. Learning an ordinal grammar Tesar & Smolensky (1998) 
Boersma___Escudero__2008_	Boersma & Escudero (2008) Paul Boersma & Paola Escudero (2008): Learning to perceive a smaller L2 vowel inventory: an Optimality Theory account. In Peter Avery, Elan Dresher & Keren Rice (eds.), Contrast in phonology: theory, perception, acquisition. Berlin: Mouton De Gruyter. 271–301. Can be downloaded as a PDF file from http://www.fon.hum.uva.nl/paul/ Links to this page OT learning 1. Kinds of grammars 
Boersma___Hayes__2001_	Boersma & Hayes (2001) Paul Boersma & Bruce Hayes (2001): Empirical tests of the Gradual Learning Algorithm. Linguistic Inquiry 32: 45–86. Can be downloaded as a PDF file from http://www.fon.hum.uva.nl/paul/ Links to this page OT learning 1. Kinds of grammars OT learning 6. Shortcut to grammar learning OTGrammar & 2 Strings: Learn... 
Boersma___Kovacic__2006_	Boersma & Kovacic (2006) Paul Boersma & Gordana Kovacic (2006): Spectral characteristics of three styles of Croatian folk singing. Journal of the Acoustical Society of America 119: 1805–1816. Can be downloaded as a PDF file from http://www.fon.hum.uva.nl/paul/ Links to this page Sound: To Ltas (pitch-corrected)... 
Boersma___Pater__2008_	Boersma & Pater (2008) Paul Boersma & Joe Pater (2008): Convergence properties of a gradual learning algorithm for Harmonic Grammar. Rutgers Optimality Archive 970, http://ruccs.rutgers.edu/roa.html. Can be downloaded as a PDF file from http://www.fon.hum.uva.nl/paul/ Links to this page OT learning 1. Kinds of grammars OT learning 4. Learning an ordinal grammar 
Boll__1979_	Boll (1979) S.F. Boll (1979): Suppression of acoustic noise in speech using spectral subtraction.IEEE Transactions on ASSP 27: 113–120. Links to this page Sound: Remove noise... 
Bonferroni_correction	Bonferroni correction In general, if we have k independent significance tests at the α level, the probability p that we will get no significant differences in all these tests is simply the product of the individual probabilities: (1 - α)k. For example, with α = 0.05 and k = 10 we get p = 0.9510 = 0.60. This means, however, we now have a 40% chance that one of these 10 tests will turn out significant, despite each individual test only being at the 5% level. In order to guarantee that the overall significance test is still at the α level, we have to adapt the significance level α′ of the individual test. This results in the following relation between the overall and the individual significance level: (1 - α′)k = 1 - α. This equation can easily be solved for α′: α′ = 1 - (1-α)1/k, which for small α reduces to: α′ = α / k This is a very simple recipe: If you want an overall significance level α and you perform k individual tests, simply divide α by k to obtain the significance level for the individual tests. Links to this page Correlation: Confidence intervals... 
Boomsma__1977_	Boomsma (1977) A. Boomsma (1977): Comparing approximations of confidence intervals for the product-moment correlation coefficient. Statistica Neerlandica 31: 179-186. Links to this page Correlation: Confidence intervals... 
Bootstrap	Bootstrap The bootstrap data points are a random sample of size n drawn with replacement from the sample (x1,...xn). This means that the bootstrap data set consists of members of the original data set, some appearing zero times, some appearing once, some appearing twice, etc. More information can be found in Efron & Tibshirani (1993). Links to this page Discriminant analysis 
Borg___Groenen__1997_	Borg & Groenen (1997) I. Borg & P. Groenen (1997): Modern multidimensional scaling: theory and applications. Springer. Links to this page congruence coefficient MDS models Procrustes Procrustes transform 
box_plot	box plot A box plot provides a simple graphical summary of data. These plots originate from the work of Tukey (1977). Definitions The following figure shows an annotated box plot. To understand the box plot we need the following definitions: q25 = lower quartile, 25% of the data lie below this value q50 = median, 50% of the data lie below this value q75 = upper quartile, 25% of the data lie above this value The following definitions all depend on these quantiles: hspread = |q75 – q25| (50% interval) lowerOuterFence = q25 – 3.0 * hspread (not in figure) lowerInnerFence = q25 – 1.5 * hspread (not in figure) upperInnerFence = q75 + 1.5 * hspread upperOuterFence = q75 + 3.0 * hspread lowerWhisker = smallest data value larger then lowerInnerFence upperWhisker = largest data value smaller then upperInnerFence The box plot is a summary of the data in which: the horizontal lines of the rectangle correspond to q25, q50 and q75, respectively. the dotted line corresponds to the mean. the outliers outside the outerFences are drawn with an 'o'. the outliers in the intervals (lowerOuterFence, lowerInnerFence) and (upperInnerFence, upperOuterFence) are drawn with an '*'. the whisker lines outside the rectangle connect q25 with lowerWhisker, and, q75 with upperWhisker, respectively. With no outliers present, the whiskers mark minimum and/or maximum of the data. Links to this page Table: Box plots where... TableOfReal: Draw box plots... 
Brokken__1983_	Brokken (1983) F.B. Brokken (1983): Orthogonal Procrustes rotation maximizing congruence. Psychometrika 48: 343–352. Links to this page Configurations: To AffineTransform (congruence)... 
Buse__1973_	Buse (1973) A. Buse (1973): Goodness of fit in generalized least squares estimation., The American Statistician 27: 106–108. 
ButtonEditor	ButtonEditor An editor for viewing, hiding, showing, removing, and executing the commands in the fixed and dynamic menus of the Praat program. To open it, choose Buttons... from the Praat menu of the Object window. What the button editor shows The button editor gives a list of: 1. The five fixed buttons. 2. The built-in and added fixed menu commands, lexicographically sorted by window and menu name. 3. The built-in and added action commands, sorted by the names of the selected objects. Visibility of built-in commands Most built-in commands are visible by default, but some are hidden by default (see Hidden commands). The button editor shows these commands as shown or hidden, respectively. You can change the visibility of a command by clicking on the blue shown or hidden text; this text will then be replaced with HIDDEN or SHOWN, with capitals to signal their non-standard settings. These changes will be remembered in the buttons file across sessions of your program. To return to the standard settings, click the blue HIDDEN or SHOWN texts again. Some built-in commands cannot be hidden. They are marked as unhidable. The most notable example is the Buttons... button (a failure to make the Commands... command unhidable in Microsoft Word causes some computer viruses to be very hard to remove...). Added commands Commands that you have added to the fixed or dynamic menus (probably with Add to fixed menu... or Add to dynamic menu... in the ScriptEditor), are marked as ADDED. They are remembered in the buttons file. You can change the availability of these commands by clicking on the blue ADDED text, which will then be replaced with REMOVED. After this, the added command will no longer be remembered in the buttons file. To make the command available again, click the blue REMOVED text again, before leaving the program. Start-up commands Commands that were added in an initialization script or plug-in (with Add menu command... or Add action command...) are marked as START-UP. They are not remembered in the buttons file. You can change the visibility of these commands by clicking on the blue START-UP text, which will then be replaced with HIDDEN. This setting will be remembered in the buttons file. To make the command visible again, click the blue HIDDEN text again. Executing commands The button editor allows you to choose hidden commands without first making them visible in the fixed or dynamic menus. The editor shows all the executable commands in blue. These include: 1. The fixed Remove button, if one or more objects are selected in the List of Objects. 2. The other fixed buttons, if exactly one object is selected. 3. All of the fixed menu commands, hidden or not, and removed or not. 4. Those action commands that match the currently selected objects with respect to class and number. To execute any of these blue commands, just click on it. Links to this page objects Scripting 7.2. Scripting an editor from within 
buttons_file	buttons file The file into which changes in the availability and visibility of commands in the fixed and dynamic menus are recorded. The buttons file is written to disk when you quit Praat, and it is read again when you start Praat the next time. It is a simple Praat script that you can read (but should not edit) with any text editor. Adding buttons To add a command to a fixed or dynamic menu, you typically use the ScriptEditor. Removing buttons To remove an added command from a fixed or dynamic menu, you typically use the ButtonEditor. Hiding and showing buttons To hide a built-in command from a fixed or dynamic menu, or to make a hidden command visible, you typically use the ButtonEditor. Where is the buttons file? The buttons file is in your Praat preferences directory. On Unix the file is called buttons5, for instance /people/miep/.praat-dir/buttons5. On Macintosh it is called Buttons5, for instance /Users/miep/Library/Preferences/Praat Prefs/Buttons5. On Windows it is called Buttons5.ini, for instance C:\Documents and Settings\Miep\Praat\Buttons5.ini. Links to this page Hidden commands plug-ins 
Cailliez__1983_	Cailliez (1983) F. Cailliez (1983): The analytical solution of the additive constant problem. Psychometrika 48, 305-308. Links to this page Dissimilarity: Get additive constant 
Calculator	Calculator A window that allows you to calculate all kinds of simple or complicated mathematical and string expressions. To show the calculator, type Command-U or choose the Calculator... command. The result will be written to the Info window. See the Formulas tutorial for all the things that you can calculate with this command. Links to this page Formulas 1.1. Formulas in the calculator Formulas 1.2. Numeric expressions Formulas 1.3. String expressions Formulas 5. String functions Formulas 7. Attributes of objects Formulas 8. Data in objects undefined 
Calculator___	Calculator... A command in the Goodies submenu of the Praat menu of the Object window. Shortcut: Command-U. Choosing this command brings up Praat's calculator. Links to this page binomialQ Formulas 1.1. Formulas in the calculator Keyboard shortcuts OT learning 2.9. Output distributions 
CANDECOMP	CANDECOMP An algorithm to solve the INDSCAL problem. In the analysis of the INDSCAL three-way data matrix (numberOfPoints × numberOfDimensions × numberOfSources) we seek to minimize the function: f(X, W1,..., WnumberOfSources) = ∑i=1..numberOfSources | Si – XWiX′ |2 where Si is a known symmetric numberOfPoints × numberOfPoints matrix with scalar products of distances for source i, X is the unknown configuration numberOfPoints × numberOfDimensions matrix, X′ its transpose, and, Wi is the diagonal numberOfDimensions × numberOfDimensions weight matrix for source i. The function above has no analytical solution for X and the Wi. It can be solved, however, by an iterative procedure which Carroll & Chang have christened CANDECOMP (CANonical DECOMPosition). This method minimizes, instead of the function given above, the following function: g(X, Y, W1,..., WnumberOfSources) = ∑i=1..numberOfSources | Si – XWiY′ |2 where X and Y are both numberOfPoints × numberOfDimensions configuration matrices. The algorithm proceeds as follows: 1. Initialize the W matrices and the configuration matrix X. This can for example be done according to a procedure given in Young, Takane & Lewyckyj (1978). 2. An alternating least squares minimization process is started as described that sequentially updates Y, X an W (Carroll & Chang (1970)): 2.1. Solve for a new Y given X and the Wi 2.2. Solve for a new X given the Wi and the new Y. 2.3. Solve for the Wi given the new X and Y. Evaluate the goodness-of-fit criterion and either repeat the minimization sequence (2.1–2.3) or continue. 3. Done: make Y equal to X and solve a last time for the Wi. Note: during the minimization the following constraints are effective: The configuration must be centered. The sum of squared coordinates in the configuration space is one for each dimension, i.e., the configuration always has unit variance in each dimension. Links to this page INDSCAL analysis 
Canonical_correlation_analysis	Canonical correlation analysis This tutorial will show you how to perform canonical correlation analysis with PRAAT. 1. Objective of canonical correlation analysis In canonical correlation analysis we try to find the correlations between two data sets. One data set is called the dependent set, the other the independent set. In PRAAT these two sets must reside into one TableOfReal object. The lower numbered columns of this table will then be interpreted as the dependent part, the rest of the columns as the independent part. The dimension of, i.e., the number of columns in, the dependent part may not exceed the dimension of the independent part. As an example, we will use the dataset from Pols et al. (1973) with the frequencies and levels of the first three formants from the 12 Dutch monophthongal vowels as spoken in /h_t/ context by 50 male speakers. We will try to find the canonical correlation between formant frequencies (the dependent part) and levels (the independent part). The dimension of both groups of variates is 3. In the introduction of the discriminant analysis tutorial you can find how to get these data, how to take the logarithm of the formant frequency values and how to standardize them. The following script summarizes: pols50m = Create TableOfReal (Pols 1973): yes Formula: if col < 4 then log10 (self) else self endif Standardize columns Before we start with the canonical correlation analysis we will first have a look at the Pearson correlations of this table and calculate the Correlation matrix. It is given by: F1 F2 F3 L1 L2 L3 F1 1 -0.338 0.191 0.384 -0.505 -0.014 F2 -0.338 1 0.190 -0.106 0.526 -0.568 F3 0.191 0.190 1 0.113 -0.038 0.019 L1 0.384 -0.106 0.113 1 -0.038 0.085 L2 -0.505 0.526 -0.038 -0.038 1 0.128 L3 -0.014 -0.568 0.019 0.085 0.128 1 The following script summarizes: selectObject: pols50m To Correlation Draw as numbers: 1, 0, decimal, 3 The correlation matrix shows that high correlations exist between some formant frequencies and some levels. For example, the correlation coefficient between F2 and L2 equals 0.526. In a canonical correlation analysis of the dataset above, we try to find the linear combination u1 of F1, F2 and F3 that correlates maximally with the linear combination v1 of L1, L2 and L3. When we have found these u1 and v1 we next try to find a new combination u2 of the formant frequencies and a new combination v2 of the levels that have maximum correlation. These u2 and v2 must be uncorrelated with u1 and v1. When we express the above with formulas we have: u1 = y11F1+y12F2 + y13F3 v1 = x11L1+x12L2 + x13L3 ρ(u1, v1) = maximum, ρ(u2, v2) = submaximum, ρ(u2, u1) = ρ (u2, v1) = ρ (v2, v1) = ρ (v2, u1) = 0, where the ρ(ui, vi) are the correlations between the canonical variates ui and vi and the yij's and xij's are the canonical coefficients for the dependent and the independent variates, respectively. 2. How to perform a canonical correlation analysis Select the TableOfReal and choose from the dynamic menu the option To CCA.... This command is available in the Multivariate statistics action button. We fill out the form and supply 3 for Dimension of dependent variate. The resulting CCA object will bear the same name as the TableOfReal object. The following script summarizes: selectObject: pols50m cca = To CCA: 3 3. How to get the canonical correlation coefficients You can get the canonical correlation coefficients by queries of the CCA object. You will find that the three canonical correlation coefficients, ρ(u1, v1), ρ(u2, v2) and ρ(u3, v3) are approximately 0.86, 0.53 and 0.07, respectively. The following script summarizes: cc1 = Get correlation: 1 cc2 = Get correlation: 2 cc3 = Get correlation: 3 writeInfoLine: cc1 = , cc1, , cc2 = , cc2, , cc3 = , cc3 4. How to obtain canonical scores Canonical scores, also named canonical variates, are the linear combinations: ui = yi1F1+yi2F2 + yi3F3, and, vi = xi1L1+xi2L2 + xi3L3, where the index i runs from 1 to the number of correlation coefficients. You can get the canonical scores by selecting a CCA object together with the TableOfReal object and choose To TableOfReal (scores)... When we now calculate the Correlation matrix of these canonical variates we get the following table: u1 u2 u3 v1 v2 v3 u1 1 . . 0.860 . . u2 . 1 . . 0.531 . u3 . . 1 . . 0.070 v1 0.860 . . 1 . . v2 . 0.1 . . 1 . v3 . . 0.070 . . 1 The scores with a dot are zero to numerical precision. In this table the only correlations that differ from zero are the canonical correlations. The following script summarizes: selectObject: cca, pols50m To TableOfReal (scores): 3) To Correlation Draw as numbers if: 1, 0, decimal, 2, abs(self) > 1e-14 5. How to predict one dataset from the other CCA & TableOfReal: Predict... Additional information can be found in Weenink (2003). Links to this page CCA 
canonical_variate	canonical variate A canonical variate is a new variable (variate) formed by making a linear combination of two or more variates (variables) from a data set. A linear combination of variables is the same as a weighted sum of variables. Because we can in infinitely many ways choose combinations of weights between variables in a data set, there are also infinitely many canonical variates possible. In general additional constraints must be satisfied by the weights to get a meaningful canonical variate. For example, in canonical correlation analyis a data set is split up into two parts, a dependent and an independent part. In both parts we can form a canonical variate and we choose weights that maximize the correlation between these canonical variates (there is an algorithm that calculates these weights). Links to this page CCA & Correlation: Get redundancy (sl)... CCA & Correlation: Get variance fraction... 
Carroll___Chang__1970_	Carroll & Chang (1970) J.D. Carroll & J.-J. Chang, (1970): Analysis of Individual Differences in Multidimensional scaling via an N-way generalization of Eckart-Young Decomposition. Psychometrika 35: 283–319. Links to this page CANDECOMP individual difference scaling INDSCAL analysis 
Carroll___Wish__1974_	Carroll & Wish (1974) J.D. Carroll & M. Wish, (1974): Models and methods for three-way multidimensional scaling. In D.H. Krantz, R.C. Atkinson, R.D. Luce & P. Suppes (eds.): Contemporary developments in mathematical psychology: Vol. 2 Measurement, psychophysics, and neural information processing, 283–319. New York: Academic Press. Links to this page Create INDSCAL Carroll & Wish example... 
Categories	Categories One of the types of objects in PRAAT. An object of type Categories represents an ordered collection of categories. Each category is a simple text string. Categories commands Creation: Create an empty Categories FFNet & Pattern: To Categories... Viewing and editing: CategoriesEditor Analysis: Categories: To Confusion Categories: Difference Synthesis Categories: Append Categories: Permute... Categories: To unique Categories Inside a Categories With Inspect you will see the following attributes: size the number of simple categories. item[] the categories. Each category is an object of type SimpleString. Links to this page Create iris example... Feedforward neural networks 2. Quick start Feedforward neural networks 3. FFNet versus discriminant classifier FFNet & Pattern & Categories: Get average costs... FFNet & Pattern & Categories: Get total costs... FFNet & Pattern & Categories: Learn slow... FFNet & Pattern & Categories: Learn... FFNet: Categories KNN & Pattern & Categories & FeatureWeights: Evaluate... KNN & Pattern & Categories: Evaluate... KNN & Pattern & Categories: Learn... KNN & Pattern & Categories: To FeatureWeights... KNN & Pattern & FeatureWeights: To Categories... KNN & Pattern: To Categories... kNN classifiers 2. Quick start KNN: Extract output Categories Pattern & Categories: To FFNet... Pattern & Categories: To KNN classifier... Pattern & FeatureWeights: To Categories... Pattern: To Categories... TableOfReal: To Pattern and Categories... 
Categories__Append	Categories: Append You can choose this command after selecting 2 objects of type Categories. A new object is created that contains the second object appended after the first. 
Categories__Difference	Categories: Difference A command to compute the difference between two selected Categories objects. Behaviour Each element in the first object is compared with the corresponding object in the second object according to its compare method. The number of different categories will be shown in the Info window. 
Categories__Edit	Categories: Edit You can choose this command after selecting one Categories. A CategoriesEditor will appear on the screen, with the selected Categories in it. 
Categories__To_Confusion	Categories: To Confusion A command to compute the Confusion matrix from two selected Categories objects. Algorithm A confusion matrix is constructed from both Categories objects in the following way: The first Categories object is considered the stimulus Categories and its unique (sorted) categories form the row indices of the confusion matrix, the unique (sorted) categories of the second object form the column indices of this matrix. Next, each element in the first Categories object is compared with the corresponding object in the second object and the element in the confusion matrix addressed by this pair is incremented by 1. Links to this page Feedforward neural networks 2. Quick start Feedforward neural networks 3. FFNet versus discriminant classifier 
CategoriesEditor	CategoriesEditor An editor for manipulating Categories. To make a selection, use the left mouse button. The Ctrl key extends a selection (discontinuously). The Shift key extends a selection contiguously. Links to this page Categories: Edit 
CC	CC One of the types of objects in PRAAT. Any object that represents cepstral coefficients as a function of time. Links to this page CC: To Matrix 
CC__Get_c0_value_in_frame___	CC: Get c0 value in frame... Get the zeroth cepstral coefficient value in the specified frame. For a MFCC object this value relates to energy. 
CC__Get_value_in_frame___	CC: Get value in frame... Get the cepstral coefficient value at a specified position in a specified frame. 
CC__Paint___	CC: Paint... A command to paint the cepstral coefficients in shades of grey. Settings From coefficient, To coefficient the range of coefficients that will be represented. 
CC__To_DTW___	CC: To DTW... You can choose this command after selecting 2 objects with cepstral coefficients (two MFCC's or LFCC's). With this command you perform dynamic time warping. Algorithm First we calculate distances between cepstral coefficients: The distance between frame i (from me) and j (from thee) is: wc · d1 + wle · d2 + wr · d3, where wc, wle & wr are user-supplied weights and d1 = ∑ (k=1..nCoefficients; (cik - cjk)2) d2 = (ci0 - cj0)2 d3 = ∑ (k=1..nCoefficients; (rik - rjk)2), with rik the regression coefficient of the cepstral coefficients from the frames within a time span of dtr seconds. cij is j-th cepstral coefficient in frame i. Next we find the optimum path through the distance matrix with a Viterbi-algorithm. Links to this page DTW 
CC__To_Matrix	CC: To Matrix Copies the cepstral coefficients of the selected CC object to a newly created Matrix object. Behaviour zji = cij, with 1 ≤ i ≤ nx and 1 ≤ j ≤ numberOfCoefficientsi, where zji is the matrix element in row j and column i and cij is the j-th cepstral coefficient in frame i. 
CCA	CCA One of the types of objects in PRAAT. An object of type CCA represents the Canonical correlation analysis of two multivariate datasets. Commands Creation: TableOfReal: To CCA... Links to this page CCA & Correlation: Get redundancy (sl)... CCA & Correlation: Get variance fraction... CCA & Correlation: To TableOfReal (loadings) CCA & TableOfReal: To TableOfReal (loadings) CCA & TableOfReal: To TableOfReal (scores)... CCA: Get zero correlation probability... SSCP: To CCA... 
CCA___Correlation__Get_redundancy__sl____	CCA & Correlation: Get redundancy (sl)... Determine from the selected CCA and Correlation objects the Stewart-Love redundancy for the selected canonical variates. The Stewart-Love redundancy for a single canonical variate is the fraction of variance explained by the selected canonical variate in a set times the fraction of shared variance between the corresponding canonical variates in the two sets. The Stewart-Love redundancy for a canonical variate range is the sum of the individual redundancies. Settings X or Y determines whether you select the dependent (y) or the independent (x) set. Canonical variate range determines the canonical variates (or canonical variables). Algorithm The formula's can be found on page 170 of Cooley & Lohnes (1971). For example, the redundancy of the dependent set (y) given the independent set (x) for the ith canonical variate can be expressed as: Ri(y) = varianceFractioni(y) * ρi2, where varianceFractioni(y) is the variance fraction explained by the ith canonical variate of the dependent set, and ρi is the ith canonical correlation coefficient. The redundancy for the selected canonical variate in the dependent set shows what fraction of the variance in the dependent set is already explained by the variance in the independent set, i.e. this fraction could be considered as redundant. In the same way we can measure the redundancy of the independent (x) set giving the dependent set (y). Remark In general Ri(y) ≠ Ri(x). 
CCA___Correlation__Get_variance_fraction___	CCA & Correlation: Get variance fraction... Determine from the selected CCA and Correlation objects the fraction of the variance explained by the selected canonical variate range. Settings X or Y determines whether you select the dependent (y) or the independent (x) set. Canonical variate range determines the canonical variates (or canonical variables). Remarks 1. In general the variance fractions for a particular canonical variate in the dependent and in the independent set are not the same. 2. In general, the variance fractions for all canonical variates do not sum to 1. Algorithm The formula's can be found on page 170 of Cooley & Lohnes (1971). For example, the fraction of the variance explained by the ith canonical variable in the dependent set is: fractionVariance = ((yi′ Ryy′ Ryy yi) / (yi′ Ryy yi)) / ny, where yi is the eigenvector for dependent canonical variable i and Ryy is the correlation matrix for the ny variables in the dependent set. Links to this page CCA & Correlation: Get redundancy (sl)... 
CCA___Correlation__To_TableOfReal__loadings_	CCA & Correlation: To TableOfReal (loadings) Determine from the selected CCA and Correlation objects the correlations of the canonical variables with the original variables. These correlations are called canonical factor loadings, or also structure correlation coefficients. 
CCA___TableOfReal__Predict___	CCA & TableOfReal: Predict... Canonical correlation analysis 
CCA___TableOfReal__To_TableOfReal__loadings_	CCA & TableOfReal: To TableOfReal (loadings) Determine from the selected CCA and TableOfReal objects the correlations of the canonical variables with the original variables. These correlations are called canonical factor loadings, or also structure correlation coefficients. 
CCA___TableOfReal__To_TableOfReal__scores____	CCA & TableOfReal: To TableOfReal (scores)... Determines the scores on the dependent and the independent canonical variates from the selected CCA and TableOfReal objects. Settings Number of canonical correlations determines the dimension, i.e., the number of elements of the resulting canonical score vectors. The newly created table will have twice this number of columns because we have calculated score vectors for the dependent and the independent variates. Behaviour The scores on the dependent set are determined as Ty Y, where Ty is the dependent part in the table and Y is a matrix with numberOfCanonicalCorrelations eigenvectors for the dependent variate. The scores for the independent variates are then determined in an analogous way as Tx X. The scores for the dependent data will be in the lower numbered columns, the scores for the independent part will be in the higher numbered columns of the newly created object. Links to this page Canonical correlation analysis 
CCA__Get_zero_correlation_probability___	CCA: Get zero correlation probability... Get the probability that for the selected CCA object the chosen canonical correlation coefficient is different from zero. Setting Index is the index of the canonical correlation coefficient that you want to test. Algorithm Wilks' statistic: the probability that coefficient ρindex differs from zero is probability = chiSquareQ (χ2, ndf), where the number of degrees of freedom parameter equals ndf = (ny - index +1)(nx - index +1) and the chi-squared parameter is χ2 = –(numberOfObservations - (ny + nx +3)/2) log (Λindex), In the formulas above the variables ny and nx are the dimensions of the dependent and the independent data sets whose canonical correlations have been obtained, and Wilks' lambda is: Λindex = Πi=index..min(ny,nx) (1 – ρi2) 
Cepstrum	Cepstrum One of the types of objects in PRAAT. Description A Cepstrum is the log spectrum of the log power spectrum. Links to this page What was new in 4.0? 
Chebyshev_polynomials	Chebyshev polynomials The Chebyshev polynomials Tn(x) of degree n are special orthogonal polynomial functions defined on the domain [-1, 1]. Orthogonality: -1∫1 W(x) Ti(x) Tj(x) dx = δij W(x) = (1 – x2)–1/2 (-1 < x < 1) They obey certain recurrence relations: Tn(x) = 2 x Tn-1(x) – Tn-2(x) T0(x) = 1 T1(x) = x Links to this page ChebyshevSeries ChebyshevSeries: To Polynomial Create ChebyshevSeries... 
ChebyshevSeries	ChebyshevSeries One of the types of objects in PRAAT. An object of type ChebyshevSeries represents a linear combination of Chebyshev polynomials Tk(x). ChebyshevSeries (x) = Σk=1..numberOfCoefficients ck Tk(x) Links to this page ChebyshevSeries: To Polynomial Create ChebyshevSeries... 
ChebyshevSeries__To_Polynomial	ChebyshevSeries: To Polynomial A command to transform the selected ChebyshevSeries object into a Polynomial object. We find polynomial coefficients ck such that Σk=1..numberOfCoefficients ck xk = Σk=1..numberOfCoefficients lk Tk(x) We use the recurrence relation for Chebyshev polynomials to calculate these coefficients. 
Childers__1978_	Childers (1978) Modern spectrum analysis. IEEE Press. The Burg algorithm for linear prediction coefficients is described on pages 252-255. Links to this page Sound: To Formant (burg)... 
ClassificationTable	ClassificationTable One of the types of objects in Praat. An object of type ClassificationTable represents the result of a classification experiment. The numbers in a row show how well a particular input matches the classes represented by the column labels. The higher the number the better the match. Links to this page Discriminant & TableOfReal: To ClassificationTable... GaussianMixture & TableOfReal: To ClassificationTable 
Clear_history	Clear history A command in the Edit menu of the ScriptEditor for clearing the remembered history. See History mechanism. Links to this page Scripting 2. How to script settings windows 
Click	Click One of the ways to control Editors. How to click 1. Position the mouse above the object that you want to click. 2. Press and release the (left) mouse button. See also Shift-click. Usage in the Praat program Clicking on an object is used for selecting this object while deselecting all previously selected objects; clicking is also used for moving a cursor hair. Links to this page ManipulationEditor PitchTierEditor PointEditor TextGridEditor 
Cochleagram	Cochleagram One of the types of objects in Praat. It represents the excitation pattern of the basilar membrane in the inner ear (see Excitation) as a function of time. Links to this page Cochleagram: Formula... Formulas 1.8. Formulas for modification Formulas 7. Attributes of objects spectro-temporal representation 
Cochleagram__Formula___	Cochleagram: Formula... A command for changing the data in all selected Cochleagram objects. See the Formulas tutorial for examples and explanations. 
Colour	Colour In windows that pop up when you choose Colour... from the Pen menu or any of the Paint commands in the World menu, you can see the following field: Colour (0-1, name, or {r,g,b}) This means that you can specify here a colour in any of three ways: • a grey value between 0 and 1: a value of 0 means black, 1 means white, 0.5 means grey, 0.75 means silver, and so on. • a colour name: you can choose from Black, White, Red, Green, Blue, Yellow, Cyan, Magenta, Maroon, Lime, Navy, Teal, Purple, Olive, Pink, Silver, Grey, i.e. from any of the colours in the Pen menu. You can write these either with a capital (Red) or in lowercase (red). • an RGB colour: you can specify a red-green-blue value as three values between 0 and 1, enclosed within braces and separated by commas, e.g. {0.8,0.1,0.2} is something reddish. Links to this page Sound: Paint where... Sounds: Paint enclosed... Undo What was new in 5.2? 
Combine_to_stereo	Combine to stereo To combine two mono Sound objects into one single stereo Sound, select the two Sounds in the list and choose Combine to stereo from the Combine sounds menu. A new stereo Sound will appear in the list. Of the two original mono Sounds, the one that is higher in the list will become the left channel of the new stereo Sound, and the one that is lower in the list will become the right channel of the new Sound. Links to this page stereo What was new in 5.1? 
concentration_ellipse	concentration ellipse The percentage of bivariate normally distributed data covered by an ellipse whose axes have a length of numberOfSigmas·σ can be obtained by integration of the p.d.f. over an elliptical area. This results in the following equation as can be verified from equation 26.3.21 in Abramowitz & Stegun (1970): percentage = (1 - exp (-numberOfSigmas2/2))· 100%, where the numberOfSigmas is the radius of the ellipse: (x/σx)2 + (y/σy)2 = numberOfSigmas2. The numberOfSigmas = 1 ellipse covers 39.3%, the numberOfSigmas = 2 ellipse covers 86.5% and the numberOfSigmas = 3 ellipse covers 98.9% of the data. From the formula above we can show that if we want to cover p percent of the data, we have to chose numberOfSigmas as: numberOfSigmas = √(-2 ln(1-p/100)). For covering 95%of the data we calculate numberOfSigmas = 2.45. Links to this page Discriminant: Draw sigma ellipses... Discriminant: Get concentration ellipse area... GaussianMixture & PCA: Draw concentration ellipses... GaussianMixture: Draw concentration ellipses... SSCP: Draw sigma ellipse... 
confidence_interval	confidence interval The confidence interval gives an estimated range of values which is likely to include an unknown population parameter. The estimated range is calculated from a given set of observations. Examples At the α level of significance a two sided confidence interval for the true mean μ for normally distributed data with mean mean and known standard deviation σ can be constructed as: mean - zα/2 σ / √N ≤ μ ≤ mean + zα/2 σ / √N, where zα/2 = invGaussQ (α/2) and N is the number of observations. If the standard deviation is not known, we have to estimate its value (s) from the data and the formula above becomes: mean - tα/2;N s / √N ≤ μ ≤ mean + tα/2;N s / √N, where tα/2;N = invStudentQ (α/2, N-1). For α=0.05 and N=20 we get z0.025=1.96 and t0.025;20=2.039. This shows that when we have to estimate the standard deviation from the data, the confidence interval is wider than when the standard deviation is known beforehand. Links to this page confidence level Correlation: Confidence intervals... 
confidence_level	confidence level The confidence level is the probability value 1-α associated with a confidence interval, where α is the level of significance. It can also be expressed as a percentage 100(1-α)% and is than sometimes called the confidence coefficient. Links to this page Correlation: Confidence intervals... 
Configuration	Configuration One of the types of objects in PRAAT. An object of type Configuration represents the positions of a number of labelled points in a multidimensional space. How to create a Configuration From the New menu: • Create Configuration... By multidimensional scaling: • Dissimilarity: To Configuration (monotone mds)... • Dissimilarity: To Configuration (i-spline mds)... • Dissimilarity: To Configuration (interval mds)... • Dissimilarity: To Configuration (ratio mds)... • Dissimilarity: To Configuration (absolute mds)... By multidimensional scaling with weights (Dissimilarity & Weight: To Configuration...): • Dissimilarity & Weight: To Configuration (monotone mds)... • Dissimilarity & Weight: To Configuration (i-spline mds)... • Dissimilarity & Weight: To Configuration (interval mds)... • Dissimilarity & Weight: To Configuration (ratio mds)... • Dissimilarity & Weight: To Configuration (absolute mds)... By multidimensional scaling with a start Configuration: • Dissimilarity & Configuration: To Configuration (monotone mds)... • Dissimilarity & Configuration: To Configuration (i-spline mds)... • Dissimilarity & Configuration: To Configuration (interval mds)... • Dissimilarity & Configuration: To Configuration (ratio mds)... • Dissimilarity & Configuration: To Configuration (absolute mds)... By transforming an existing Configuration: • Configuration: To Configuration (varimax)... • Configuration & AffineTransform: To Configuration • Configuration & Procrustes: To Configuration From Principal component analysis: • TableOfReal: To Configuration (pca)... • PCA & TableOfReal: To Configuration... From Discriminant analysis: TableOfReal: To Configuration (lda)... • Discriminant & TableOfReal: To Configuration... How to draw a Configuration Configuration: Draw... Configuration: Draw as numbers... Configuration: Draw as squares... How to modify a Configuration Configuration: Randomize Configuration: Rotate (pc) (to principal directions) Configuration: Rotate... (in a plane around the origin) Configuration: Invert dimension... Configuration: Normalize... Inside a Configuration With Inspect you will see the following attributes: numberOfRows the number of points (numberOfPoints≥1). numberOfColumns the dimension of the space (numberOfDimensions≥1). rowLabels the names associated with the points. columnLabels the names for the dimensions. data [1..numberOfPoints][1..numberOfDimensions] the coordinates of the points. metric determines the way distances between points are measured. In general the distance between points xi and xj is: dij = (∑k=1..numberOfDimensions wk |xik – xjk|metric)1/metric For Euclidean distances metric is 2. w [1..numberOfDimensions] weight given to each dimension in the distance calculation. Links to this page Configuration & Configuration: To Procrustes... Configuration: Centralize Configuration: To Configuration (procrustes) Configuration: To Distance Configuration: To Similarity (cc) Configurations: To AffineTransform (congruence)... congruence coefficient ContingencyTable: To Configuration (ca)... Correspondence analysis Create INDSCAL Carroll & Wish example... Dissimilarity & Configuration & Weight: Get stress... Dissimilarity & Configuration & Weight: To Configuration... Dissimilarity & Configuration: Draw regression (absolute mds)... Dissimilarity & Configuration: Draw regression (i-spline mds)... Dissimilarity & Configuration: Draw regression (interval mds)... Dissimilarity & Configuration: Draw regression (monotone mds)... Dissimilarity & Configuration: Draw regression (ratio mds)... Dissimilarity & Configuration: Draw Shepard diagram... Dissimilarity & Configuration: Get stress (absolute mds)... Dissimilarity & Configuration: Get stress (i-spline mds)... Dissimilarity & Configuration: Get stress (interval mds)... Dissimilarity & Configuration: Get stress (monotone mds)... Dissimilarity & Configuration: Get stress (ratio mds)... Dissimilarity & Configuration: To Configuration (kruskal)... Dissimilarity & Weight: To Configuration... Dissimilarity: To Configuration (kruskal)... Distance & Configuration & Salience: Get VAF... Distance & Configuration & Salience: To Configuration (indscal)... Distance & Configuration: Get VAF... Distance & Configuration: To Configuration (indscal)... Distance: To Configuration (indscal)... Distance: To Configuration (ytl)... INDSCAL analysis Kruskal analysis MDS models Multidimensional scaling PCA & Configuration: To TableOfReal (reconstruct) Salience 
Configuration___AffineTransform__To_Configuration	Configuration & AffineTransform: To Configuration A command that transforms the selected Configuration to a new Configuration object according to the specifications in the selected AffineTransform object. 
Configuration___Configuration__To_Procrustes___	Configuration & Configuration: To Procrustes... A command that creates a Procrustes object from two selected Configuration objects. Setting Orthogonal transform determines whether or not a translation and a scaling are allowed in the transform. We calculate the Procrustes transform that transforms the second selected Configuration object to match the first selected Configuration object as closely as possible. 
Configuration___Procrustes__To_Configuration	Configuration & Procrustes: To Configuration A command that transforms the selected Configuration to a new Configuration object according to the specifications in the selected Procrustes object. 
Configuration__Centralize	Configuration: Centralize Makes the centre of the selected Configuration equal to the origin. 
Configuration__Draw___	Configuration: Draw... Draws a projection of the selected Configuration on a coordinate plane. Settings X-coordinate, Y-coordinate control the dimensions that will show in the plot. xmin, xmax; ymin, ymax range for horizontal and vertical axes, respectively. Garnish when on, draws a bounding box with decoration. Links to this page Multidimensional scaling 
Configuration__Invert_dimension___	Configuration: Invert dimension... Inverts one dimension of a Configuration. Setting Dimension the dimensions that has to be inverted. Behaviour For all points i=1..numberOfPoints: if j == dimension then xij = –xij. 
Configuration__Normalize___	Configuration: Normalize... Normalizes the selected Configuration. Settings Sum of squares (standard value: 0.0) The desired value for the variance. Each dimension separately When on, the sum of squares in each dimension (column) will be scaled to sumOfSquares When off, the sum of squares of all the matrix elements will equal sumOfSquares. With the default value (0.0) for sumOfSquares, and eachDimensionSeparately chosen, an INDSCAL-like normalization is applied: the sum of squares for each column is scaled to equal 1.0. When eachDimensionSeparately is off, a Kruskal-like normalization is applied: the sum of squares of the whole matrix is scaled equal to numberOfRows. Behaviour Before the normalization will be applied, however, we first translate the centre of the configuration to the origin by subtracting the mean for each dimension. The sum of squares than equals variance. 
Configuration__Randomize	Configuration: Randomize Changes all coordinates of the points xi in the Configuration according to: xij = randomUniform (-1, 1) 
Configuration__Rotate___	Configuration: Rotate... Rotates the Configuration in a plane around the origin. Settings Dimension 1, Dimension 2 the dimensions that span the plane. The order of dimension 1 and dimension 2 is not important: the lowest number always determines the first dimension. Angle the counter-clockwise rotation angle in degrees. 
Configuration__Rotate__pc_	Configuration: Rotate (pc) Rotates the Configuration to principal directions. The principal directions correspond to the principal components. 
Configuration__To_Configuration__procrustes_	Configuration: To Configuration (procrustes) A command that transforms the second selected Configuration object to match the first selected Configuration object as closely as possible.This problem of fitting one configuration (testee) to another (target) as closely as possible is called the Procrustes problem. We use a special Procrustes transform algorithm that does not mutilate or distort the testee configuration. Both Configuration objects must have the same dimensions. 
Configuration__To_Configuration__varimax____	Configuration: To Configuration (varimax)... A command that rotates the selected Configuration object to a new Configuration object whose coordinates have maximum squared variance. Settings Normalize rows when selected, the distances of all points to the origin will be made equal before iteration starts. We remember these scale factors and restore the original distances after the iteration process has stopped. Quartimax when selected, the sum of fourth powers, normalized or raw, will be maximized. Maximum number of iterations sets a limit to the number of iterations. One iteration consists of numberOfDimensions· (numberOfDimensions–1)/2 planar rotations of all pairs of dimensions. Tolerance also determines when the iteration stops. This happens if |vi–vi+1| < tolerance · vi, where vi is the squared variance for the ith iteration. The iteration process stops when either the maximum number of iterations is reached or the tolerance criterion is met, which ever one is first. Algorithm The Varimax rotation procedure was first proposed by Kaiser (1958). Given a numberOfPoints × numberOfDimensions configuration A, the procedure tries to find an orthonormal rotation matrix T such that the sum of variances of the columns of B*B is a maximum, where B = AT and * is the element wise (Hadamard) product of matrices. A direct solution for the optimal T is not available, except for the case when numberOfDimensions equals two. Kaiser suggested an iterative algorithm based on planar rotations, i.e., alternate rotations of all pairs of columns of A. However, this procedure is not without problems: the varimax function may have stationary points that are not even local maxima. We have incorporated an algorithm of Ten Berge (1995) that prevents this unpleasant situation from happening. 
Configuration__To_Distance	Configuration: To Distance A command that computes a Distance object for each selected Configuration. Algorithm The distance dij between objects i and j is calculated as: dij = dji = (∑k=1..numberOfDimensions |xik – xjk|2)1/2 
Configuration__To_Similarity__cc_	Configuration: To Similarity (cc) A command that create one Similarity object from the selected Configuration objects. In the Similarity object entry sij equals the congruence coefficient for the i-th and j-th selected Configuration object. All Configuration objects must have the same number of points and the same dimensions. 
Configurations__To_AffineTransform__congruence____	Configurations: To AffineTransform (congruence)... A command that creates an AffineTransform object from two selected Configuration objects. We calculate the affine transform that transforms the second selected Configuration object to match the first selected Configuration object as closely as possible. The degree of proportionality is the congruence between corresponding dimensions. Settings Maximum number of iterations sets a limit to the number of iterations. Tolerance also determines when the iteration stops. This happens if |f(Ti)–f(Ti+1)| < tolerance · f(Ti), where f(Ti) is the sum of the congruences for the ith iteration (see below). The iteration process stops when either the maximum number of iterations is reached or the tolerance criterion is met, which ever one is first. Algorithm Sometimes the criterion used in a Procrustes transform is too restrictive for comparing two configurations. This criterion is only zero when the positions in the rotated configuration (AT) equal the positions in the other configuration (B). Brokken (1983) proposed an algorithm to maximize instead the sum of congruences between corresponding dimensions of AT and B. Specifically he proposed to maximize f(T) = ∑i=1..numberOfDimensions t′iA′bi / ((t′iA′Ati)1/2(b′ibi)1/2), where t′i and b′i are the ith column of T and B, respectively. A direct solution for T is not available, it can only be obtained by an iterative procedure. The implemented algorithm is from Kiers & Groenen (1996) and shows excellent convergence properties. 
Confusion	Confusion One of the types of objects in Praat. An object of type Confusions represents a confusion matrix, with stimuli as row labels and responses as column labels. The entry at position [i][j] represents the number of times response j was given to the stimulus i. Creating a Confusion from data in a text file Suppose you have two objects A and B. In one way or another, you have acquired the following confusions: δAA = 6, δAB = 2 , δBA = 1, and δBB = 7. You can create a simple text file like the following: ooTextFile ! to make Praat recognize your file Confusion ! The line that tells Praat about the contents 2 A B ! Number of columns, and column labels 2 ! Number of rows A 6 2 ! Row label A, A-A value, A-B value B 1 7 ! Row label B, B-A value, B-B value This text file can be read with the Read from file... command. Commands Creation: Categories: To Confusion Create simple Confusion... Drawing Draw as numbers... Draw as squares... Query Get fraction correct Confusion: Get stimulus sum... Confusion: Get response sum... Get grand sum Modification Formula... Confusion: Increase... Grouping Confusion: Group stimuli... Confusion: Group responses... Analysis: Confusion: To Similarity... Confusion: To Dissimilarity (pdf)... Inside a Confusion With Inspect you will see the following attributes: numberOfRows the number of stimuli. numberOfColumns the number of responses. rowLabels the names of the stimuli. columnLabels the names of the responses. Links to this page Confusion: Condense... Confusion: To Dissimilarity... Confusion: To TableOfReal (marginals) Discriminant analysis Feedforward neural networks 2. Quick start Feedforward neural networks 3. FFNet versus discriminant classifier INDSCAL analysis 
Confusion__Condense___	Confusion: Condense... Groups row and column labels of the selected Confusion object in order to reduce its dimension. Settings Search the pattern to match. Replace the pattern that replaces the match(es). Replace limit limits the maximum number of times that a match/replace cycle may occur within each label. Search and replace are defines whether the search and replace strings are taken literally or as a regular expression. Behaviour First all row and column labels are changed according to the search and replace specification. Next all rows or columns that have the same labels are summed. 
Confusion__Get_fraction_correct	Confusion: Get fraction correct A query to ask the selected Confusion matrix for the fraction of correct classifications. The fraction correct is defined as the quotient of the number of correct classifications and the sum of the entries in the matrix. Correct classifications have identical row and column labels. Links to this page Discriminant analysis 
Confusion__Get_response_sum___	Confusion: Get response sum... Returns the number of times the chosen response was given (the sum of all the numbers in the column with this response label). Example Given the following selected Confusion: u i a ! The response labelss u 6 2 1 ! Responses on stimulus u, i 3 4 2 ! Responses on stimulus i a 1 4 4 ! Responses on stimulus a The command Get response sum: a will return the number 7. Links to this page Confusion 
Confusion__Get_stimulus_sum___	Confusion: Get stimulus sum... Returns the number of responses for the chosen stimulus (the sum of all the numbers in the row with this stimulus label). Example Given the following selected Confusion: u i a ! The response labels u 6 2 1 ! Responses on stimulus u, i 3 4 2 ! Responses on stimulus i a 1 4 4 ! Responses on stimulus a The command Get stimulus sum: a will return the number 9. Links to this page Confusion 
Confusion__Group___	Confusion: Group... Groups a number of stimuli and responses into one new category. Settings Stimuli & Responses defines the labels that will be grouped. New label defines the new label for the grouped labels. New label position the row/column number for the new group label. Example Given the following selected Confusion: u i a ! The response labels u 6 2 1 ! Responses on stimulus u, i 3 4 2 ! Responses on stimulus i a 1 4 4 ! Responses on stimulus a After the command Group stimuli: u i, high, 0, the new Confusion will be: high a ! The new response labels high 15 3 ! Responses on group high a 5 4 ! Responses on stimulus a Instead after the command Group stimuli: u i, high, 2, the new Confusion will be: a high ! The new response labels a 4 5 ! Responses on stimulus a high 3 15 ! Responses on group high 
Confusion__Group_responses___	Confusion: Group responses... Groups a number of responses into one new category. Settings Responses defines the responses that will be grouped. New label defines the new label for the grouped responses. New label position the column number for the new group label. Example Given the following selected Confusion: u i a ! The response labels u 6 2 1 ! Responses on stimulus u, i 3 4 2 ! Responses on stimulus i a 1 4 4 ! Responses on stimulus a After the command Group responses: a i, front, 1, the new Confusion will be: front i ! The new response labels u 7 2 ! Responses on stimulus u, i 5 4 ! Responses on stimulus i a 5 4 ! Responses on stimulus a Links to this page Confusion 
Confusion__Group_stimuli___	Confusion: Group stimuli... Groups a number of stimuli into one new category. Settings Stimuli defines the stimuli that will be grouped. New label defines the new label for the grouped stimuli. New label position the row number for the new group label. Example Given the following selected Confusion: u i a ! The response labels u 6 2 1 ! Responses on stimulus u, i 3 4 2 ! Responses on stimulus i a 1 4 4 ! Responses on stimulus a After the command Group stimuli: u i, high, 1, the new Confusion will be: u i a ! The response labels high 9 6 3 ! Responses on stimulus group high, a 1 4 4 ! Responses on stimulus a Links to this page Confusion 
Confusion__Increase___	Confusion: Increase... Increases the contents of the corresponding cell in the selected Confusion by one. Settings Stimulus and Response define the cell whose value will be increased by one. Example Given the following Confusion: u i a ! The response labels u 6 2 1 ! Responses on stimulus u, i 3 4 2 ! Responses on stimulus i a 1 4 4 ! Responses on stimulus a The command Increase: u, i results in: u i a ! The responses u 6 3 1 ! Responses on stimulus u, i 3 4 2 ! Responses on stimulus i a 1 4 4 ! Responses on stimulus a 
Confusion__To_Dissimilarity___	Confusion: To Dissimilarity... A command that creates a Dissimilarity from every selected Confusion. Settings Normalize when on, normalize rows by dividing each row element by the row sum. In this way you correct for unequal stimulus numbers. No symmetrization, Average, Houtgast determine the symmetrization procedure. See Confusion: To Similarity... Maximum dissimilarity determines the maximum dissimilarity possible. When the default value, 0.0, is chosen, maximumDissimilarity is calculated as the maximum element in the Similarity object. Algorithm We first transform the Confusion to a Similarity. See Confusion: To Similarity... To obtain dissimilarities from similarities we reverse the latter: dissimilarityij = maximumDissimilarity – similarityij 
Confusion__To_Dissimilarity__pdf____	Confusion: To Dissimilarity (pdf)... A command that creates a Dissimilarity from every selected Confusion. Settings Symmetrize first when on, the confusion matrix is symmetrized before we calculate dissimilarities. Maximum dissimilarity (units of sigma) specifies the dissimilarity from confusion matrix elements that are zero. Algorithm 1. Normalize rows by dividing each row element by the row sum (optional). 2. Symmetrize the matrix by averaging fij and fji. 3. Transformation of the confusion measure which is a sort of similarity measure to the dissimilarity measure. Similarity and dissimilarity have an inverse relationship: the greater the similarity, the smaller the dissimilarity and vice versa. Both have a monotonic relationship with distance. The most simple way to transform the similarities fij into dissimilarities is: dissimilarityij = maximumSimilarity – similarityij For ordinal analyses like Kruskal this transformation is fine because only order relations are important in this analysis. However, for metrical analyses like INDSCAL this is not optimal. In INDSCAL, distance is a linear function of dissimilarity. This means that, with the transformation above, you ultimately fit an INDSCAL model in which the distance between object i and j will be linearly related to the confusion between i and j. For the relation between confusion and dissimilarity, the model implemented here, makes the assumption that the amount of confusion between objects i and j is related to the amount that their probability density functions, pdf's, overlap. Because we do not know these pdf's we make the assumption that both are normal, have equal sigma and are one-dimensional. The parameter to be determined is the distance between the centres of both pdf's. According to formula 26.2.23 in Abramowitz & Stegun (1970), for each fraction fij, we have to find an x that solves: fij = 1 / √(2π) ∫x∞ e-t·t/2 dt This x will be used as the dissimilarity between i and j. The relation between x and fij is monotonic. This means that the results for a Kruskal analysis will not change much. For INDSCAL, in general, you will note a significantly better fit. Links to this page Distance INDSCAL analysis 
Confusion__To_Similarity___	Confusion: To Similarity... A command that creates a Similarity from every selected Confusion. Settings Normalize when on, normalize rows by dividing each row element by the row sum. In this way you correct for unequal stimulus numbers. No symmetrization, Average, Houtgast determine the symmetrization procedure. Algorithm The Average procedure averages: similarityij= similarityji = (confusionij + confusionji) / 2 The Houtgast procedure as described in the paper by Klein, Plomp & Pols (1970), expresses similarity between stimuli i and j by the number of times that stimulus i and j have resulted in the same response, summated over all response categories. We use the following formula to calculate the Houtgast dissimilarities: similarityij = ∑k=1..numberOfColumns min (confusionik, confusionjk) which is equivalent to the formula in the Klein et al. paper: similarityij = ∑k=1..numberOfColumns (confusionik + confusionjk – |confusionik – confusionjk|) Links to this page Confusion: To Dissimilarity... 
Confusion__To_TableOfReal__marginals_	Confusion: To TableOfReal (marginals) A new TableOfReal object is created from the selected Confusion object with one extra row and column. The first element of the extra row will contain the sum of the confusions in the the first column, the first element of the extra column will contain the sum of the confusions in the the first row, etc... The bottom-right element will contain the sum of all confusions. 
congruence_coefficient	congruence coefficient The congruence coefficient is a measure of similarity between two Configurations. The congruence coefficient c(X, Y) for the configurations X and Y is defined as: c(X, Y) = ∑i<j wij dij(X) dij(Y) / ([∑i<j wij d2ij(X)]1/2 [∑i<j wij d2ij(Y)]1/2), where dij(X) is the distance between the points i and j in configuration X and wij are nonnegative weights (default: wij = 1). Since distances are nonnegative, the congruence coefficient has a value between 0 and 1. The congruence coefficient is a better measure of the similarity between configurations than the correlation coefficient of the distances. Borg & Groenen (1997) give a simple example where things go wrong with correlation coefficients: two configurations X and Y with three points each, have distances d12(X) = 1, d13(X) = 2, d23(X) = 3 and d12(Y) = 2, d13(Y) = 3, d23(Y) = 4. These distances have a correlation coefficient of 1. However, in X the three points lie on a straight line and in Y the points form a triangle. This unwanted situation occurs because in the calculation of the correlation coefficient the mean is subtracted from the distances and the resulting values are no longer distances (they may become negative). In calculating the correlation between the distances we should not subtract the mean. In fact, the congruence coefficient is exactly this correlation coefficient calculated with respect to the origin and not with respect to the centroid position (the mean). For further information on how well one number can assess the similarity between two configurations see Borg & Groenen (1997) section 19.7. Links to this page Configuration: To Similarity (cc) 
constant_extrapolation	constant extrapolation - the interpretation of values in tiers before the first point or after the last point. Example The following is a PitchTier with three points: Between 0.10 and 0.20 seconds, the pitch rises from 170 to 180 Hz, and between 0.20 and 0.45 seconds it falls from 180 to 110 Hz. This is linear interpolation. But what happens before 0.10 seconds? There, the pitch is just 170 Hz, i.e. the value of the first pitch point. This is constant extrapolation to the left. Likewise, after 0.45 seconds the pitch is just 110 Hz, i.e. the value of the last pitch point. This is constant extrapolation to the right. Constant extrapolation in Praat Praat uses constant extrapolation in all tiers and grids with values at time points (PitchTier, IntensityTier, DurationTier, AmplitudeTier, FormantGrid). Links to this page Create FormantGrid... Formulas 8. Data in objects 
constraints	constraints In Optimality Theory, the `rules' that an output form has to satisfy. Since there can be many constraints and these constraints can conflict with each other, the constraints are violable and the highest-ranked constraints have the largest say in determining the optimal output. See the OT learning tutorial for many examples. Links to this page OT learning 1. Kinds of grammars 
ContingencyTable	ContingencyTable One of the types of objects in PRAAT. In a two-way contingency table, cell fij contains the frequency with which row category i co-occurs with column category j. Necessarily, all fij ≥ 0. Commands Creation TableOfReal: To ContingencyTable Query ContingencyTable: Get chi squared probability ContingencyTable: Get Cramer's statistic ContingencyTable: Get contingency coefficient Analysis ContingencyTable: To Configuration (ca)... Links to this page Correspondence analysis 
ContingencyTable__To_Configuration__ca____	ContingencyTable: To Configuration (ca)... A command that creates a Configuration object from the selected ContingencyTable object by means of Correspondence analysis. Settings Number of dimensions The dimensionality of the Configuration. Scaling of the final configuration determines whether row points are in the centre of gravity of column points, or, column points are in the centre of gravity of row points, or, whether roes and columns are treated symmetrically. Algorithm 1. We start with the following transformation of the entries fij: hij = fij / √ (fi+f+j) - √ (fi+f+j) / N, where hij is the entry for a cell in the matrix H with transformed data, fi+ is the total count for row i, f+j is the total count for column j and N is the grand total. This can be written in matrix form as: H = R–1/2FC–1/2 – R1/2uu′C1/2 / N, where R and C are diagonal matrices with the row and column totals, respectively and u a column vector with all elements equal to 1. 2. Next the singular value decomposition of matrix H is performed: H = K Λ L′, where K′K = I, L′L = I, and Λ is a diagonal matrix with singular values. 3. Now the row (X) and column points (Y) can be determined. Three normalizations are possible: • Scale row points in the centre of gravity of column points X = √N R–1/2KΛ Y = √N C–1/2L • Scale column points in the centre of gravity of row points X = √N R–1/2K Y = √N C–1/2LΛ • Treat row points and column points symmetrically X = √N R–1/2KΛ–1/2 Y = √N C–1/2LΛ–1/2 For more details see Gifi (1990), chapter 8. 
Cooley___Lohnes__1971_	Cooley & Lohnes (1971) W.W. Colley & P.R. Lohnes (1971): Multivariate data analysis. John Wiley & Sons. Links to this page CCA & Correlation: Get redundancy (sl)... CCA & Correlation: Get variance fraction... 
Copy___	Copy... One of the fixed buttons in the Object window. Availability You can choose this command after selecting one object of any type. Behaviour The Object window copies the selected object, and all the data it contains, to a new object, which will appear at the bottom of the List of Objects. Example If you select Sound hallo and click `Copy...', a command window will appear, which prompts you for a name; after you click OK, a new object will appear in the list, bearing that name. Links to this page Formulas 8. Data in objects 
Copy_to_clipboard	Copy to clipboard A command in the File menu of the Picture window on Windows and Macintosh. It copies the selected part of the picture to the clipboard. You can then Paste it into any program that knows how to display pictures. Behaviour Though all the picture data will be written to the clipboard, only the part that corresponds to the selected part of the Picture window (the viewport) will be visible. Usage On Windows, if you have a PostScript printer, you may want to use Save as EPS file... instead (experiment with the results after converting to PDF or printing). If the picture is too large, e.g. a spectrogram that does not seem to fit into the clipboard, you can try Save as Windows metafile... instead. On the Mac, the picture will be put on the clipboard in PDF format, which is recognized by programs that know how to handle PDF pictures, such as Microsoft® Word™ 2008; the quality of the picture will be exactly as good as when you use Save as PDF file... and read in the resulting PDF file. Please realize that Word will convert the PDF picture to a mediocre 300-dpi bitmap if you save the document as a .doc file; therefore, you should save the document as a .docx file instead. If you cannot work with .docx files (for instance because your publisher does not accept that file type yet), consider using Save as EPS file... instead. In older programs, such as Microsoft® Word™ 2004, you cannot paste Praat's PDF pictures; use Save as EPS file... instead. Links to this page Printing Save as PNG file... 
Correlation	Correlation One of the types of objects in PRAAT. An object of type Correlation represents the correlation coefficients of a multivariate data set. Links to this page Canonical correlation analysis CCA & Correlation: Get redundancy (sl)... CCA & Correlation: Get variance fraction... CCA & Correlation: To TableOfReal (loadings) Correlation: Confidence intervals... GaussianMixture & TableOfReal: To Correlation (columns) Principal component analysis TableOfReal: To Correlation TableOfReal: To Correlation (rank) 
Correlation__Confidence_intervals___	Correlation: Confidence intervals... Calculates confidence intervals for the correlation coefficients from the selected Correlation object(s) and saves these intervals in a new TableOfReal object. Settings Confidence level the confidence level you want for the confidence intervals. Number of tests determines the Bonferroni correction for the significance level. If the default value (zero) is chosen, it will be set equal to the number of correlations involved (a matrix of dimension n has n·(n-1)/2 correlations). Approximation defines the approximation that will be used to calculate the confidence intervals. It is either Fisher's z transformation or Ruben's transformation. According to Boomsma (1977), Ruben's approximation is more accurate than Fisher's. Algorithm We obtain intervals by the large-sample conservative multiple tests with Bonferroni inequality and the Fisher or Ruben transformation. We put the upper values of the confidence intervals in the upper triangular part of the matrix and the lower values of the confidence intervals in lower triangular part of the resulting TableOfReal object. In Fisher's approximation, for each element rij of the correlation matrix the confidence interval is: [ tanh (zij - zα′ / √(N - 3)) , tanh (zij + zα′ / √(N - 3)) ], where zij is the Fisher z-transform of the correlation rij: zij = 1/2 ln ((1 + rij) / (1 - rij)), zα′ the Bonferroni corrected z-value zα/(2·numberOfTests), α = 1 - confidenceLevel, and N the number of observations that the correlation matrix is based on. In Ruben's approximation the confidence interval for element rij is: [ x1 / √(1 - x12), x2 / √(1 - x22) ] in which x1 and x2 are the smallest and the largest root from a x2 + b x + c = 0, with a = 2N - 3 - zα′2 b = - 2 r′ √((2N - 3)(2N - 5)) c = (2N - 5 - zα′2) r′2 - 2zα′2, and r′ = rij / √(1 - rij2), Links to this page What was new in 4.1? 
Correspondence_analysis	Correspondence analysis Correspondence analysis provides a method for representing data in an Euclidean space so that the results can be visually examined for structure. For data in a typical two-way ContingencyTable both the row variables and the column variables are represented in the same space. This means that one can examine relations not only among row or column variables but also between row and column variables. In correspondence analysis the data matrix is first transformed by dividing each cell by the square root of the corresponding row and column totals. The transformed matrix is then decomposed with singular value decomposition resulting in the singular values (which in this case are canonical correlations) and a set of row vectors and column vectors. Next the row and column vectors are rescaled with the original total frequencies to obtain optimal scores. These optimal scores are weighted by the square root of the singular values and become the coordinates of the points in the Configuration. Examples can be found in the books by Weller & Romney (1990) and Gifi (1990). Links to this page ContingencyTable: To Configuration (ca)... Types of objects 
Covariance	Covariance One of the types of objects in PRAAT. An object of type Covariance represents the sums of squares and cross products of a multivariate data set divided by the number of observations. An object of type Covariance contains the same attributes as an object of type SSCP. Since an object of type Covariance contains the mean values (the centroids), the covariances as well as the number of observations it has all the information necessary to be the subject of all kinds of statistical tests on means and variances. Links to this page Covariance & TableOfReal: Extract quantile range... Covariance & TableOfReal: To TableOfReal (mahalanobis)... Covariance: Difference Covariance: Get fraction variance... Covariance: Get significance of means difference... Covariance: Get significance of one mean... Covariance: Get significance of one variance... Covariance: Get significance of variance ratio... Covariance: Set value... Covariance: To TableOfReal (random sampling)... Covariances: Report equality Covariances: Report multivariate mean difference... Create simple Covariance... CrossCorrelationTable PCA & Covariance: Project Principal component analysis Sound: To Covariance (channels)... SSCP: To Covariance... T-test TableOfReal: To Covariance 
Covariance___TableOfReal__Extract_quantile_range___	Covariance & TableOfReal: Extract quantile range... Extract those rows from the selected TableOfReal object whose Mahalanobis distance, with respect to the selected Covariance object, are within the quantile range. 
Covariance___TableOfReal__To_TableOfReal__mahalanobis__	Covariance & TableOfReal: To TableOfReal (mahalanobis)... Calculate Mahalanobis distance for the selected TableOfReal with respect to the selected Covariance object. Setting Use table centroid Use the mean vector calculated from the columns in the selected TableOfReal instead of the means in the selected Covariance. Explanation The Mahalanobis distance is defined as d = √((x - mean)′ S-1 (x - mean)), where x is a vector, mean is the average and S is the covariance matrix. It is the multivariate form of the distance measured in units of standard deviation. Example Count the number of items that are within 1, 2, 3, 4 and 5 standard deviations from the mean. We first create a table with only one column and 10000 rows and fill it with numbers drawn from a normal distribution with mean zero and standard deviation one. Its covariance matrix, of course, is one dimensional. We next create a table with Mahalanobis distances. n = 100000 t0 = Create TableOfReal: table, n, 1 Formula: randomGauss(0,1) c = To Covariance selectObject: c, t0 ts = To TableOfReal (mahalanobis): no for nsigma to 5 selectObject: ts extraction = Extract rows where: self < nsigma nr = Get number of rows nrp = nr / n * 100 expect = (1 - 2 * gaussQ (nsigma)) * 100 writeInfoLine: nsigma, -sigma: , nrp, , , expect, removeObject: extraction endfor Links to this page Discriminant & TableOfReal: To TableOfReal (mahalanobis)... 
Covariance__Difference	Covariance: Difference You can choose this command after selecting two objects of type Covariance. We test the hypothesis that the samples that gave rise to the two covariance matrices M1 and M2, have equal covariances. The test statistic is L′ which is distributed as a χ2 variate with p(p+1)/2 degrees of freedom. L′ = L · (1 – (2p + 1 – 2 / (p + 1)) / (6 · ( N – 1))), where, L = (N – 1) · (ln determinant (M1) – ln determinant (M2)) + trace (M2 · M1–1) – p), p is dimension of covariance matrix and N is the number of observations underlying the covariance matrix. For more details on this test, see e.g. page 292 of Morrison (1990). 
Covariance__Get_fraction_variance___	Covariance: Get fraction variance... A command to ask the selected Covariance object for the fraction of the total variance that is accounted for by the selected dimension(s). Settings From dimension, To dimension define the range of components. By choosing both numbers equal, you get the fraction of the variance explained by that dimension. Details The total variance is the sum of the diagonal elements of the covariance matrix C, i.e., its trace. The fraction is defined as: Σi=from..to Cii / Σi=1..numberOfRows Cii Links to this page PCA & TableOfReal: Get fraction variance... SSCP: Get fraction variation... 
Covariance__Get_significance_of_means_difference___	Covariance: Get significance of means difference... Gets the level of significance for the difference of two means from the selected Covariance object being different from a hypothesized value. Settings Index1, Index2 the positions of the two elements of the means vector whose difference is compared to the hypothesized difference. Value the hypothesized difference (μ). Paired samples determines whether we treat the two means as being dependent. Equal variances determines whether the distribution of the difference of the means is a Student t-distribution (see below). Behaviour This is Student's t-test for the significance of a difference of means. The test statistic is: t = (mean1 - mean2 - μ) √ (N / s2) with ndf degrees of freedom. In the formula above mean1 and mean2 are the elements of the means vector, μ is the hypothesized difference and N is the number of observations. The value that we use for the (combined) variance s2 is: s2 = var1 + var2 - 2 * covar12, when the samples are paired, and s2 = var1 + var2 when they are not. The var1 and var2 are the variance components for mean1 and mean2, respectively, and covar12 is their covariance. When we have paired samples we assume that the two variances are not independent and their covariance is subtracted, otherwise their covariance is not taken into account. Degrees of freedom parameter ndf usually equals 2(N-1). If the two variances are significantly different, the statistic t above is only approximately distributed as Student's t with degrees of freedom equal to: ndf = (N-1) · (var1 + var2)2 / (var12 + var22). The returned probability p will be the two-sided probability p = 2 * studentQ (t, ndf) A low probability p means that the difference is significant. Links to this page T-test 
Covariance__Get_significance_of_one_mean___	Covariance: Get significance of one mean... Gets the level of significance for one mean from the selected Covariance object being different from a hypothesized mean. Settings Index the position of the element in the means vector (centroid) that you want to test. Value the hypothesized mean μ (see below). Behaviour This is the standard test on means when the variance is unknown. The test statistic is t = (mean - μ) √(N / s2), which has the Student t distribution with ndf = N-1 degrees of freedom. In the formulas above, mean is the element of the mean vector at position index, μ is the hypothesized mean, N is the number of observations, s2 is the variance at position [index][index] in the covariance matrix. The returned probability p is the two-sided probability p = 2 * studentQ (t, ndf) A low probability p means that the difference is significant. Links to this page T-test 
Covariance__Get_significance_of_one_variance___	Covariance: Get significance of one variance... Gets the probability for one variance from the selected Covariance object being different from a hypothesized variance. Settings Index the position of the variance element. Hypothesized variance the hypothesized variance σ2 Behaviour The test statistic χ2 = (N-1)s2 / σ2, is distributed as a chi-squared variate with ndf = N-1 degrees of freedom. The returned probability p will be p = chiSquareQ (χ2, ndf) 
Covariance__Get_significance_of_variance_ratio___	Covariance: Get significance of variance ratio... Gets the probability for the ratio of two variances from the selected Covariance object being different from a hypothesized ratio. Settings Index1, Index2 determine the variances. Hypothesized ratio the hypothesized ratio F. Behaviour The test statistic f = s12 / s22 / ratio is distributed as Fisher's F distribution with ndf1 = N-1 and ndf2 = N-1 degrees of freedom for the numerator and denominator terms, respectively. The returned probability p will be the two-sided probability p = 2 * fisherQ (f, ndf1, ndf2) If s22 > s12 we use 1/f to determine the probability. 
Covariance__Set_value___	Covariance: Set value... Input Covariance matrix cell values. Constraints on input values A covariance matrix is a symmetric matrix: values input at cell [i,j] will be automatically input at cell [j,i] too. All values on the diagonal must be positive numbers. The absolute value of an off-diagonal element at cell [i,j] must be smaller than the corresponding diagonal elements at cells [i,i] and [j,j]. 
Covariance__To_TableOfReal__random_sampling____	Covariance: To TableOfReal (random sampling)... Generate a TableOfReal object by random sampling from a multi-variate normal distribution whose Covariance matrix is the selected object. Setting Number of data points determines the number of data points that will be generated. Each data point occupies one row in the generated table. Algorithm The algorithm proceeds as follows: 1. Diagonalize the covariance matrix: calculate the eigenvalues vi and eigenvectors ei of the m × m Covariance matrix. In general there will also be m of these. Let E be the m × m matrix with eigenvector ej in column j (j=1..m). 2. Generate a vector x whose elements xk equal xk = randomGauss (0, √ (vk)). Each xk is a random deviate drawn from a Gaussian distribution with mean zero and standard deviation equal to the square root of the corresponding eigenvalue vk. 3. Rotate back: calculate the vector y = E x, obtained by multiplying the vector x with the matrix E. 4. Add the centroid to y and copy the elements of y to the corresponding row of the TableOfReal object. 5. Repeat steps 2, 3 and 4 until the desired number of data points has been reached. 6. Copy the column labels from the Covariance object to the TableOfReal object. In case the covariance matrix is diagonal, the algorithm is much simpler: we can skip the first and third step. Links to this page GaussianMixture: To TableOfReal (random sampling)... What was new in 3.9? 
Covariances__Report_equality	Covariances: Report equality Reports the probability that the selected Covariance matrices are equal. We use the Bartlett test and the Wald test. According to Schott (2001), both tests are overly sensitive to violations of normality. 
Covariances__Report_multivariate_mean_difference___	Covariances: Report multivariate mean difference... Reports the probability that the two multivariate means of the selected Covariances are equal. Settings Covariances are equal determines whether the test is performed as if the two covariance matrices are equal or not. Algorithm For equal covariance matrices the test is via Hotelling's T2 as described in Morrison (1990, page 141). The test statistic is F = (N1+N2-p-1)/((N1+N2-2)p)· T2, with p and N1+N2-p-1 degrees of freedom. If the covariance matrices are not equal, we apply a correction on the number of degrees of freedom as proposed by Krishnamoorthy & Yu (2004). The test statistic in this case is F = (ν-p+1)/(pν)· T2, with p and ν degrees of freedom. Here ν is a corrected number of degrees of freedom. (The test for unequal covariances simplifies to Welch's approximate solution for the univariate t-test with unequal variances.) 
Create_Artword___	Create Artword... A command to create an Artword object with all muscle activities set to zero. See Articulatory synthesis. Settings Name the name that you give to the created object. The standard name is hallo, but you should give it a more sensible name, possibly something that represents the utterance that it is supposed to generate. Duration (seconds) the duration of the resulting Artword. Should be as long as the utterance that you want to generate with it. The standard value is 1 second. 
Create_ChebyshevSeries___	Create ChebyshevSeries... A command to create a ChebyshevSeries from a list of coefficients. Settings Xmin and Xmax define the domain of the polynomials. Coefficients define the coefficients of each Chebyshev polynomial. The coefficient of the polynomial with the highest degree comes last. 
Create_Configuration___	Create Configuration... A command to create a Configuration with the specified number of points and number of dimensions. The location of the points will be determined by the formula (see Formulas for more information about possible formulas). 
Create_DurationTier___	Create DurationTier... A command in the New menu to create an empty DurationTier object. The resulting object will have the specified name and time domain, but contain no duration points. To add some points to it, use DurationTier: Add point.... Scripting example To create a tier 0.9 seconds long, with an deceleration around 0.6 seconds, you do: Create DurationTier: dur, 0, 0.9 Add point: 0.3, 1 Add point: 0.6, 2.3 Add point: 0.7, 1 The result will look like The target duration will be the area under this curve, which is 0.9 + 1/2 · 1.3 · 0.4 = 1.16 seconds. Links to this page Manipulation: Replace duration tier 
Create_empty_EditCostsTable___	Create empty EditCostsTable... Creates an empty EditCostsTable. Settings Name the name of the resulting EditCostsTable object. Number of target symbols the number of different symbols in the target symbol set that you want to give special edit cost values in the EditCostTable. The number you specify may be smaller than the actual target symbol set size because the EditCostTable has an entry for target symbols that fall in a rest category. If you don't want to treat any target symbol is a special way you may set this value to 0. Number of source symbols the number of different symbols in the source symbol set that you want to give special edit cost values in the EditCostTable. The number you specify may be smaller than the actual source symbol set size because the EditCostTable has an entry for source symbols that fall in a rest category. If you don't want to treat any source symbol is a special way you may set this value 0. 
Create_empty_PointProcess___	Create empty PointProcess... A command in the New menu to create an empty PointProcess. The newly created object is put in the list of objects. 
Create_FFNet___	Create FFNet... Create a new feedforward neural net of type FFNet. Settings Number of inputs the dimension of the input of the neural net. Number of outputs (≥ 1) the number of different categories that you want the net to learn. Number of units in hidden layer 1, Number of units in hidden layer 2 determine the number of units in the hidden layers. If you want a neural net with no hidden layers, both numbers have to be 0. If you want a neural net with only 1 hidden layer then one of these numbers has to differ from 0. Links to this page Feedforward neural networks 4. Command overview 
Create_FFNet__linear_outputs____	Create FFNet (linear outputs)... Create a FFNet feedforward neural network whose output units are linear. Settings Number of inputs the dimension of the input of the neural net. Number of outputs (≥ 1) the number of different categories that you want the net to learn. Number of units in hidden layer 1, Number of units in hidden layer 2 determine the number of units in the hidden layers. If you want a neural net with no hidden layers, both numbers have to be 0. If you want a neural net with only 1 hidden layer then one of these numbers has to differ from 0. 
Create_formant_table__Peterson___Barney_1952_	Create formant table (Peterson & Barney 1952) A command to create a Table object filled with the fundamental frequency and the first three formant frequency values from 10 American-English monophthongal vowels as spoken in a /h_d/ context by 76 speakers (33 men, 28 women and 15 children). Every vowel was pronounced twice, so that there are 1520 recorded vowels in total. Table layout The created table will contain 9 columns: Column 1, labelled as Type speaker type: m, w or c (for man, women or child). Column 2, labelled as Sex speaker sex: either m or f (for male or female). Column 3, labelled as Speaker speaker id: a number from 1 to 76. Column 4, labelled as Vowel the vowel name. The following list gives the vowel in a h_d context word together with its representation in this column: (heed, iy), (hid, ih), (head, eh), (had, ae), (hod, aa), (hawed, ao), (hood, uh), (who'd, uw), (hud, ah), (heard, er). Column 5, labelled as IPA the IPA notation for the vowels as defined in Peterson & Barney (1952). Column 6, labelled as F0 the fundamental frequency in Hertz. Column 7, 8 and 9, labelled as F1, F2 and F3 the frequencies in Hertz of the first three formants. Remarks We originally downloaded the data from the University of Pennsylvania FTP site, where they were reportedly based on a printed version supplied by Ignatius Mattingly. About the IPA notation. We used the original notation from the Peterson & Barney article. The notation in Watrous (1991) differs for three vowels: Watrous uses /e, o, ɜ/ where Peterson & Barney use /ɛ, ɔ, ɜ˞/. More details about these data and how they were measured can be found in the articlesWatrous (1991) and in Peterson & Barney (1952). Links to this page Table: Report two-way anova... 
Create_formant_table__Pols___Van_Nierop_1973_	Create formant table (Pols & Van Nierop 1973) A command to create a Table object filled with the frequencies and the levels of the first three formants from the 12 Dutch monophthong vowels as spoken in /h_t/ context by 50 male and 25 female speakers. Table layout The created table will contain 10 columns Column 1, labeled as Sex speaker sex: Either m or f (for male or female). Column 2, labeled as Speaker speaker id: a number from 1 to 75. Column 3, labeled as Vowel the vowel name. The following list gives the vowel in p_t context word together with its representation in this column: (poet, oe), (paat, aa), (poot, oo), (pat, a), (peut, eu), (piet, ie), (puut, uu), (peet, ee), (put, u), (pet, e), (pot, o), (pit, i). Column 4, labeled as IPA the IPA-notation for the vowels Column 5, 6 and 7, labeled as F1, F2 and F3 the frequencies in Hertz of the first three formants. Column 8, 9 and 10, labeled as L1, L2 and L3 the levels in decibel below overall SPL of the first three formants. More details about these data and how they were measured can be found in Pols et al. (1973) and Van Nierop et al. (1973). 
Create_formant_table__Weenink_1985_	Create formant table (Weenink 1985) A command to create a Table object filled with the fundamental frequency and the first three formant frequency values from 12 Dutch monophthongal vowels as spoken in isolation by 30 speakers (10 men, 10 women and 10 children). Every vowel was pronounced only once, so that there are 360 recorded vowels in total. A reduced form, with only the formant frequecy values, is also available as a TableOfReal. Table layout The created table will contain 9 columns: Column 1, labelled as Type speaker type: m, w or c (for man, women or child). Column 2, labelled as Sex speaker sex: either m or f (for male or female). Column 3, labelled as Speaker speaker id: a number from 1 to 76. Column 4, labelled as Vowel the vowel name. The following list gives the vowel in Dutch p_t context words together with its representation in this column: (poet, oe), (paat, aa), (poot, oo), (pat, a), (peut, eu), (piet, ie), (puut, uu), (peet, ee), (put, u), (pet, e), (pot, o), (pit, i). Column 5, labelled as IPA the IPA notation for the vowels. Column 6, labelled as F0 the fundamental frequency in Hertz. Column 7, 8 and 9, labelled as F1, F2 and F3 the frequencies in Hertz of the first three formants. The formant frequency values have been determined by means of LPC analysis with a varying prediction order. See Weenink (1985). 
Create_FormantGrid___	Create FormantGrid... A command in the New menu to create an empty FormantGrid object. Settings Start time (s) End time (s) the time domain of the resulting FormantGrid. Number of formants (e.g. 10) the number of formants in the resulting FormantGrid. For instance, if you set this to 10, the resulting FormantGrid will contain 10 formant tiers (for F1 through F10) and 10 bandwidth tiers (for B1 through B10). Each of these 20 tiers will contain one point. Initial first formant (e.g. 550 Hz) the frequency value of the single formant point in the first formant tier. Because of constant extrapolation, F1 will have this value throughout the time domain. Initial formant spacing (e.g. 1100 Hz) the difference between the frequency values of the points in adjacent formant tiers. For instance, the example values mentioned here cause F2 to be 1650 Hz throughout the time domain; F3 will be 2750 Hz, F4 will be 3850 Hz, and so on. Initial first bandwidth (e.g. 60 Hz) the value of the single bandwidth point in the first bandwidth tier. Because of constant extrapolation, B1 will have this value throughout the time domain. Initial bandwidth spacing (e.g. 50 Hz) the difference between the values of the points in adjacent bandwidth tiers. For instance, the example values mentioned here cause B2 to be 110 Hz throughout the time domain; B3 will be 160 Hz, B4 will be 210 Hz, and so on. To add some points to it, use FormantGrid: Add formant point... and FormantGrid: Add bandwidth point.... For more examples, see Source-filter synthesis. Links to this page Source-filter synthesis 2. Filtering a source 
Create_INDSCAL_Carroll___Wish_example___	Create INDSCAL Carroll & Wish example... Creates eight Dissimilarity objects that bear names 1 ... 8. These objects contain the interpoint distances for a twodimensional 3×3 Configuration of points, labelled A, B, C, ... I. All Dissimilarity objects are based on the following underlying configuration. The eight sources weigh this configuration in the following manner: For each source, the distances were subjected to the transformation: dissimilarityij = distanceij + noiseRange · u, where u is a uniform random variable between 0 and 1. Now you can do the following for example: Select all the Dissimilarity objects and choose To Distance.... Uncheck scale (add additive constant). Select all the Distance objects and choose To Configuration (indscal).... and an INDSCAL analysis will be performed. In order to reproduce the saliences, you have to uncheck the Normalize scalar products option. This example was adapted from Carroll & Wish (1974). Links to this page Multidimensional scaling 
Create_IntensityTier___	Create IntensityTier... A command in the New menu to create an empty IntensityTier object. The resulting object will have the specified name and time domain, but contain no formant points. To add some points to it, use IntensityTier: Add point.... For an example, see Source-filter synthesis. Links to this page Intro 8.3. Manipulation of intensity 
Create_iris_example___	Create iris example... A FFNet feedforward neural net will be created together with two other objects: a Pattern and a Categories. The Pattern will contain the observations in the iris data set, and the Categories will contain the 3 different iris species categorized by numbers. Settings Number of units in hidden layer 1, Number of units in hidden layer 2 determine the number of units in the hidden layers. If you want a neural net with no hidden layers, both numbers have to be 0. If you want a neural net with only 1 hidden layer then one of these numbers has to differ from 0. For this simple data you can leave both hidden layers empty. Links to this page Feedforward neural networks 2. Quick start kNN classifiers 2. Quick start 
Create_ISpline___	Create ISpline... A command to create an ISpline from a list of coefficients. Settings Xmin and Xmax define the domain of the polynomial spline. Degree defines the degree of the polynomial spline. Coefficients define the coefficients of the basis polynomials. Interior knots define the positions in the domain where continuity conditions are defined. Behaviour The number of coefficients and the number of interior knots must satisfy the following relation: numberOfCoefficients = numberOfInteriorKnots + degree 
Create_KlattGrid___	Create KlattGrid... A command to create a multitier KlattGrid speech synthesizer. 
Create_KNN___	Create KNN... Create a new KNN classifier. Settings Name The name of the classifier. See also: kNN classifiers Links to this page kNN classifiers 3. Command overview 
Create_LegendreSeries___	Create LegendreSeries... A command to create a LegendreSeries from a list of coefficients. Settings Xmin and Xmax define the domain of the polynomials. Coefficients define the coefficients of each Legendre polynomial. The coefficient of the polynomial with the highest degree comes last. 
Create_letter_R_example___	Create letter R example... Creates a Dissimilarity object that bears the name R. The dissimilarities in this object were chosen to be a monotone transformation of the distances between the 32 two-dimensional points that make up the capital letter R. All 32 · (32-1)/2 interpoint distances were subjected to the transformation: dissimilarityij = distanceij2 + 5 + noiseRange · u, where u is a uniform random variable between 0 and 1. This example was chosen from Green, Carmone & Smith (1989). Links to this page Kruskal analysis Multidimensional scaling 
Create_Matrix___	Create Matrix... A command in the New menu to create a Matrix with the specified sampling attributes, filled with values from a formula (see Matrix: Formula...). 
Create_MSpline___	Create MSpline... A command to create an MSpline from a list of coefficients. Settings Xmin and Xmax define the domain of the polynomial spline. Degree defines the degree of the polynomial spline. Coefficients define the coefficients of the basis polynomials. Interior knots define the positions in the domain where continuity conditions are defined. Behaviour The number of coefficients and the number of interior knots must satisfy the following relation: numberOfCoefficients = numberOfInteriorKnots + degree + 1 
Create_Permutation___	Create Permutation... A command to create a Permutation of the numbers 1,2, ..., numberOfElements. Settings Name the name of the new permutation. Number of elements the number of elements in the permutation. Identity permutation determines whether the permution will be a randomly chosen one, or the identity permutation. 
Create_PitchTier___	Create PitchTier... A command in the New menu to create an empty PitchTier object. The resulting object will have the specified name and time domain, but contain no pitch points. To add some points to it, use PitchTier: Add point.... For an example, see Source-filter synthesis. Links to this page Intro 8.1. Manipulation of pitch Manipulation: Replace pitch tier Source-filter synthesis 1. Creating a source from pitch targets 
Create_Poisson_process___	Create Poisson process... A command to create a PointProcess object that represents a Poisson process. A Poisson process is a stationary point process with a fixed density λ, which means that there are, on the average, λ events per second. Settings Start time (s) tmin, the beginning of the time domain, in seconds. End time (s) tmax, the end of the time domain, in seconds. Density (Hz) the average number of points per second. Algorithm First, the number of points N in the time domain is determined. Its expectation value is λ = (tmax – tmin) · density but its actual value is taken from the Poisson distribution: p(n) = (λn / n!) e–λ Then, N points are computed throughout the time domain, according to a uniform distribution: p(t) = 1 / (tmax – tmin) for t ∈ [tmin, tmax] p(t) = 0 outside [tmin, tmax] Links to this page New menu 
Create_Polynomial___	Create Polynomial... A command to create an Polynomial from a list of coefficients. Settings Xmin and Xmax define the domain of the polynomial. Degree defines the degree of the basis polynomials. Coefficients define the coefficients of the polynomial. The coefficient of the highest power of x comes last. 
Create_simple_Confusion___	Create simple Confusion... Creates a square confusion matrix with equal stimulus labels and response labels. Example The command Create simple Confusion: simple, u i a results in the following Confusion: u i a ! The response labels u 0 0 0 ! Responses on stimulus u, i 0 0 0 ! Responses on stimulus i a 0 0 0 ! Responses on stimulus a 
Create_simple_Covariance___	Create simple Covariance... Create a Covariance matrix with its centroid. Settings Covariances define the covariances. Because a covariance matrix is a symmetric matrix, only the upper triangular part of the matrix has to be input (row-wise). If your covariance matrix is of dimension d, your input needs d(d+1)/2 elements. The first d input elements are the elements of the first row of the covariance matrix, the next d-1 input elements are for the second row, then d-2 for the third row, etc. Centroid defines the centroid. Number of observations defines the number of observations. 
Create_simple_Matrix___	Create simple Matrix... A command in the New menu to create a Matrix with the specified number of rows and columns, filled with values from a formula (see Matrix: Formula...). Links to this page Formulas 1.7. Formulas for creation 
Create_simple_Polygon___	Create simple Polygon... Creates a Polygon from user supplied x/y pairs. Settings Name defines the name of the resulting Polygon. Vertices as X-Y pairs, defines the x-y values of the vertices of the Polygon. The Polygon will be automatically closed, i.e., the first and the last point will be connected. Example The command Create simple Polygon: p, 0.0 0.0 0.0 1.0 1.0 0.0 defines a Polygon with three points. In the figure the three points are indicated with open circles while the Polygon is drawn as a closed figure. 
Create_Sound_from_formula___	Create Sound from formula... A command in the New menu to create a Sound with a specified duration and sampling frequency, filled with values from a formula. See the Formulas tutorial for explanations and examples. Links to this page Advanced spectrogram settings... ExperimentMFC 3.4. Variable inter-stimulus intervals Formulas 1.6. Formulas in settings windows Formulas 1.7. Formulas for creation Formulas 7. Attributes of objects Intro 1.3. Creating a sound from a formula Intro 3.2. Configuring the spectrogram Sounds: Convolve... Spectrum: Get centre of gravity... 
Create_Sound_from_gammatone___	Create Sound from gammatone... A command to create a Sound as a gammatone. Settings Name the name of the resulting Sound object. Minimum time (s) and Maximum time (s) the start and end time of the resulting Sound. Sampling frequency (Hz) the sampling frequency of the resulting Sound. Gamma determines the exponent of the polynomial. Frequency (Hz) and Bandwidth (Hz) determine the frequency and damping of the cosine wave in the gammatone. Initial phase (radians) the initial phase of the cosine wave. Addition factor (standard value: 0) determines the degree of asymmetry in the spectrum of the gammatone. The zero default value gives a gammatone. A value unequal to zero results in a so called gammachirp. A negative value is used in auditory filter modeling to guarantee the usual direction of filter asymmetry, which corresponds to an upward glide in instantaneous frequency. Scale amplitudes determines whether the amplitudes will be scaled to fit in the range (-1, 1). Purpose to create a Sound according to the following formula: tγ–1 e–2π·bandwidth·t cos (2π·frequency·t + additionFactor·ln(t) + initialPhase), The gammachirp function has a monotonically frequency-modulated carrier (the chirp) with instantaneous frequency instantaneousFrequency(t) = frequency + additionFactor / (2·π·t) and an envelope that is a gamma distribution function. It is a theoretically optimum auditory filter, in the sense that it leads to minimal uncertainty in the joint time and scale representation of auditory signal analysis. For faithful modelling of the inner ear, Irino & Patterson (1997) conclude that a value of approximately 1.5 * ERB (frequency) is appropriate for bandwidth. ERB stands for equivalent rectangular bandwidth. Their formula for ERB is: ERB(f) = 6.23 10–6 f2 + 93.39 10–3 f + 28.52. To avoid aliasing in the chirp sound, a sound is only generated during times where the instantaneous frequency is greater than zero and smaller than the Nyquist frequency. Links to this page New menu 
Create_Sound_from_Shepard_tone___	Create Sound from Shepard tone... One of the commands that create a Sound. Settings Name the name of the resulting Sound object. Minimum time (s) and Maximum time (s) the start and end time of the resulting Sound. Sampling frequency (Hz) the sampling frequency of the resulting Sound. Lowest frequency (Hz) the frequency of the lowest component in the tone complex. Number of components the number of frequency components in the tone complex. Frequency change (semitones/s) determines how many semitones the frequency of each component will change in one second. The number of seconds needed to change one octave will then be 12 divided by Frequency change. You can make rising, falling and monotonous tone complexes by chosing a positive, negative or zero value. Amplitude range (dB) determines the relative size in decibels of the maximum and the minimum amplitude of the components in a tone complex. These relative amplitudes will then be 10–amplitudeRange/20. Octave shift fraction (0-1) shifts all frequency components by this fraction at the start. You will probably only need this if you want to generate static tone complexes as the example script below shows. Purpose To create a Sound that is a continuous variant of the sound sequences used by Shepard (1964) in his experiment about the circularity in judgments of relative pitch. The tone consists of many sinusoidal components whose frequencies might increase exponentially in time. All frequencies are always at successive intervals of an octave and sounded simultaneously. Thus the frequency of each component above the lowest is at each moment in time exactly twice the frequency of the one just below. The amplitudes are large for the components of intermediate frequency only, and tapered off gradually to subthreshold levels for the components at the highest and lowest extremes of frequency. For a rising tone complex, the Sound is generated according to the following specification: s(t) = ∑i=1..numberOfComponents Ai(t) sin (argi(t)), where argi(t) = ∫ 2π fi(τ) dτ , and fi(t) = lowestFrequency · 2(i – 1 + octaveShiftFraction + t/(12/frequencyChange_st), with Ai(t) = 10((Lmin + (Lmax – Lmin) (1 – cos 2πθi(t)) / 2) / 20), where, Lmax = 0, Lmin = 10–amplitudeRange/20, and, θi(t) = 2π log2 (f(t) / lowestFrequency) / numberOfComponents. The maximum frequency that can be reached during a sweep by any single tone is: maximumFrequency = lowestFrequency·2numberOfComponents. A component that reaches the maximum frequency falls instantaneously to the lowest frequency and then starts rising again. The absolute sound pressure level of the resulting sound will not be set, it is only guaranteed that the peak value is just below 1. You can always scale the intensity with the Scale Intensity... command. Example The following script generates 12 static Shepard tone complexes, 1 semitone 'apart', with a cosine window to temper the abrupt start and finish. fadeTime = 0.010 for i to 12 fraction = (i-1)/12 Create Sound from Shepard tone: s + string$ (i), 0, 0.1, 22050, 4.863, 10, 0, 34, fraction Fade in: 0, 0, fadeTime, no Fade out: 0, 0.1, -fadeTime, no endfor Links to this page New menu 
Create_Sound_from_tone_complex___	Create Sound from tone complex... A command in the New menu to create a Sound as the sum of a number of sine waves with equidistant frequencies. Settings Name the name of the resulting Sound object. Start time (s) End time (s) the time domain of the resulting Sound. Sampling frequency (Hz) the sampling frequency of the resulting Sound. Phase determines whether the result is a sum of sines or a sum of cosines, i.e., whether the zero crossings or the maxima of the components are synchronized. This choice has little perceptual consequences. Frequency step (Hz) the distance between the components. In first approximation, this is the perceived fundamental frequency. First frequency (Hz) the lowest frequency component. If you supply a value of 0, First frequency is taken equal to Frequency step. Ceiling (Hz) the frequency above which no components are used. If you supply a value of 0 or a value above the Sound's Nyquist frequency, ceiling is taken equal to the Nyquist frequency. Number of components determines how many sinusoids are used. If you supply a value of 0 or a very high value, the maximum number of components is used, limited by Ceiling. Example 1: a pulse train A series of pulses at regular intervals, sampled after low-pass filtering at the Nyquist frequency, can be regarded as a sum of cosine waves. For instance, a 100-Hz pulse train, sampled at 44100 Hz, can be created with: Create Sound from tone complex: train, 0, 1, 44100, Cosine, 100, 0, 0, 0 Supplying the value 0 for firstFrequency yields an unshifted harmonic complex. Example 2: a shifted harmonic complex Some experiments on human pitch perception (residue pitch) use a number of sinusoidal components with harmonically related frequencies that are all shifted by a constant amount. For instance, to get a sum of sine waves with frequencies 105 Hz, 205 Hz, and 305 Hz, you would use: Create Sound from tone complex: train, 0.3, 1, 44100, Sine, 100, 105, 0, 3 or Create Sound from tone complex: train, 0.3, 1, 44100, Sine, 100, 105, 350, 0 whichever you prefer. Some of these experiments are described in Plomp (1967) and Patterson & Wightman (1976). Algorithm For the `sine' phase, the resulting Sound is given by the following formula: x(t) = ∑i=1..numberOfComponents sin (2π·(firstFrequency + (i–1)·frequencyStep)·t) More flexibility? Suppose you wanted to vary the relative strengths of the frequency components. You could achieve this by creating a Sound with the command discussed here, take its Fourier transform, run a formula on the resulting Spectrum, and take the inverse Fourier transform. A more general approach is described shortly. Suppose you need a sum of sine waves with frequencies 105, 205, 305, ..., 1905 Hz, and with relative amplitudes 1, 1/2, 1/3, ..., 1/19. You could build a script that computes the various components, and add them to each other as you go along. Instead of calling 19 scripts, however, you can achieve this with the following more general script: form Add waves with decreasing amplitudes natural Number_of_components 19 endform # Create a Matrix with frequency and amplitude information in each row: Create simple Matrix: freqAndGain, number_of_components, 2, 0 Formula: if col = 1 then row * 100 + 5 else 1 / row fi # Create a large Matrix with all the component sine waves: Create Matrix: components, 0, 1, 10000, 1e-4, 0.5e-4, 1, number_of_components, number_of_components, 1, 1, 0 Formula: Matrix_freqAndGain [2] * sin (2 * pi * Matrix_freqAndGain [1] * x) # Integrate: Formula: self + self [row - 1, col] # Publish last row: To Sound (slice): number_of_components Scale amplitudes: 0.99 
Create_Speaker___	Create Speaker... A command to create a Speaker object. See Articulatory synthesis. Settings Name the name that you give to the created object. The standard name is speaker, but if you work with multiple Speaker objects, give them sensible names to reduce confusion. Kind of speaker Choose from Female, Male, or Child. The only difference is a relative size. Number of tubes in glottis Choose from 1, 2, or 10. See Artword & Speaker: To Sound... for details. 
Create_SpeechSynthesizer___	Create SpeechSynthesizer... Creates the Espeak speech synthesizer. Settings Language determines the language of the synthesizer. Voice variant determines which voice type the synthesizer uses (male, female or whispered voices). Links to this page SpeechSynthesizer 
Create_Strings_as_directory_list___	Create Strings as directory list... A command in the New menu to create a Strings object containing a list of directories in a given parent directory. It works completely analogously to Create Strings as file list.... Links to this page What was new in 4.5? 
Create_Strings_as_file_list___	Create Strings as file list... A command in the New menu to create a Strings object containing a list of files in a given directory. Settings Name the name of the resulting Strings object. File path the directory name, with an optional wildcard (see below) for selecting files. Behaviour The resulting Strings object will contain an alphabetical list of file names, without the preceding path through the directory structures. If there are no files that match the file path, the Strings object will contain no strings. Usage There are two ways to specify the file path. One way is to specify a directory name only. On Unix, the file path could be /usr/people/miep/sounds or /usr/people/miep/sounds/, for instance. On Windows, C:\Documents and Settings\Miep\Sounds or C:\Documents and Settings\Miep\Sounds\. On Macintosh, /Users/miep/Sounds or /Users/miep/Sounds/. Any of these produce a list of all the files in the specified directory. The other way is to specify a wildcard (a single asterisk) for the file names. To get a list of all the files whose names start with hal and end in .wav, type /usr/people/miep/sounds/hal*.wav, C:\Documents and Settings\Miep\Sounds\hal*.wav, or /Users/miep/Sounds/hal*.wav. Script usage In a script, you can use this command to cycle through the files in a directory. For instance, to read in all the sound files in a specified directory, you could use the following script: directory$ = /usr/people/miep/sounds strings = Create Strings as file list: list, directory$ + /*.wav numberOfFiles = Get number of strings for ifile to numberOfFiles selectObject: strings fileName$ = Get string: ifile Read from file: directory$ + / + fileName$ endfor If the script has been saved to a script file, you can use file paths that are relative to the directory where you saved the script. Thus, with Create Strings as file list: list, *.wav you get a list of all the .wav files that are in the same directory as the script that contains this line. And to get a list of all the .wav files in the directory Sounds that resides in the same directory as your script, you can do Create Strings as file list: list, Sounds/*.wav As is usual in Praat scripting, the forward slash (/) in this example can be used on all platforms, including Windows. This makes your script portable across platforms. See also To get a list of directories instead of files, use Create Strings as directory list.... Links to this page FAQ: Scripts Scripting 6.4. Files What was new in 3.8? What was new in 4.5? What was new in 4.6? What's new? 
Create_TableOfReal__Pols_1973____	Create TableOfReal (Pols 1973)... A command to create a TableOfReal filled with the first three formant frequency values and (optionally) the levels from the 12 Dutch monophthongal vowels as spoken in /h_t/ context by 50 male speakers. The first three columns will contain the frequencies in Hz, the next three columns the levels in decibels below the overall SPL of the measured vowel segment. Each row will be labelled with its corresponding vowel symbol. More details about these data and how they were measured can be found in the paper of Pols et al. (1973). Links to this page Discriminant analysis TableOfReal: To TableOfReal (means by row labels)... 
Create_TableOfReal__Van_Nierop_1973____	Create TableOfReal (Van Nierop 1973)... A command to create a TableOfReal filled with the first three formant frequency values and (optionally) the levels from the 12 Dutch monophthongal vowels as spoken in /h_t/ context by 25 female speakers. The first three columns will contain the frequencies in Hz, the next three columns the levels in decibels below the overall SPL of the measured vowel segment. Each row will be labelled with its corresponding vowel symbol. More details about these data and how they were measured can be found in the paper of Van Nierop et al. (1973). 
Create_TableOfReal__Weenink_1985____	Create TableOfReal (Weenink 1985)... A command to create a TableOfReal filled with the first three formant frequency values from the 12 Dutch monophthongal vowels as spoken in isolation by either 10 men or 10 women or 10 children. The three columns will contain the formant frequencies in Hz. Each row will be labelled with its corresponding vowel symbol. More details about these data and how they were measured can be found in the paper of Weenink (1985). Links to this page Create formant table (Weenink 1985) 
Create_TextGrid___	Create TextGrid... A command to create a TextGrid from scratch. Settings Start time (s) the start time, usually 0 seconds. End time (s) the end time in seconds, usually the duration. Tier names a list of the names of the tiers that you want to create, separated by spaces. Point tiers a list of the names of the tiers that you want to be point tiers; the rest of the tiers will be interval tiers. Links to this page Intro 7. Annotation New menu 
Create_tongue-root_grammar___	Create tongue-root grammar... A command in the New menu for creating an OTGrammar object with a tongue-root-harmony grammar. These OTGrammar grammars only accept inputs of the form V1tV2, where V1 and V2 are chosen from the six front vowels i, ɪ, e, ɛ, ə, and a. The following phonological features are relevant: ATRRTR highiɪ mideɛ lowəa Constraints The resulting OTGrammar will usually contain at least the following five constraints: *[rtr / hi] do not implement [retracted tongue root] if the vowel is high. *[atr / lo] do not implement [advanced tongue root] if the vowel is low. PARSE (rtr) make an underlying [retracted tongue root] specification surface. PARSE (atr) make an underlying [advanced tongue root] specification surface. *GESTURE (contour) do not go from advanced to retracted tongue root, nor the other way around, within a word. This set of constraints thus comprises: • two grounding conditions (Archangeli & Pulleyblank (1994)), which we can see as gestural constraints; • two faithfulness constraints, which favour the similarity between input and output, and can be seen as implementing the principle of maximization of perceptual contrast; • a harmony constraint, which, if crucially ranked higher than at least one faithfulness constraint, forces tongue-root harmony. In addition, there may be the following four constraints: *[rtr / mid] do not implement [retracted tongue root] if the vowel is mid; universally ranked lower than *[rtr / hi]. *[rtr / lo] do not implement [retracted tongue root] if the vowel is low; universally ranked lower than *[rtr / mid]. *[atr / mid] do not implement [advanced tongue root] if the vowel is mid; universally ranked lower than *[atr / lo]. *[atr / hi] do not implement [advanced tongue root] if the vowel is high; universally ranked lower than *[atr / mid]. The universal rankings referred to are due to the local-ranking principle (Boersma (1998)). A learning algorithm may enforce this principle, e.g., if *[rtr / hi] falls down the ranking scale, *[rtr / mid] may be pushed along. For information on learning these tongue-root grammars, see OT learning and Boersma (2000). Links to this page OT learning 3.2. Data from another grammar OT learning 4. Learning an ordinal grammar 
Create_Vocal_Tract_from_phone___	Create Vocal Tract from phone... A way to create a VocalTract object. Purpose to translate a phone symbol like [a], [u], etc., into a vocal-tract area function. Behaviour The resulting VocalTract will appear in the list of objects, with the same name as the phone. Algorithm The area function of the resulting VocalTract is taken from the Russian speaker from Fant (1960). 
CrossCorrelationTable	CrossCorrelationTable One of the types of objects in Praat. A CrossCorrelationTable represents the cross-correlations between a number of signals. Cell [i,j] of a CrossCorrelationTable contains the cross-correlation between the i-th and the j-th signal. For example, the CrossCorrelationTable of an n-channel sound is a n×n table where the number in cell [i,j] is the cross-correlation of channel i with channel j (for a particular lag time τ). A CrossCorrelationTable has a square matrix whose cells contain the cross-correlations between the signals and a centroid vector with the average value of each signal. Remarks Sometimes in the statistical literature, the cross-correlation between signals is also called covariance. However, the only thing a Covariance has in common with a CrossCorrelationTable is that both are symmetric matrices. The differences between a CrossCorrelationTable and a Covariance are: 1. a Covariance matrix is always positive-definite; for a cross-correlation table this is only guaranteed if the lag time τ = 0. 2. The elements cij in a Covariance always satisfy |cij/√(cii·cjj)| ≤ 1; this is generally not the case for cross-correlations. Links to this page CrossCorrelationTables CrossCorrelationTables: Create test set... Sound: To Covariance (channels)... Sound: To CrossCorrelationTable... Sound: To Sound (blind source separation)... 
CrossCorrelationTables	CrossCorrelationTables One of the types of objects in Praat. A CrossCorrelationTables represents a collection of CrossCorrelationTable objects. 
CrossCorrelationTables__Create_test_set___	CrossCorrelationTables: Create test set... Create a collection of CrossCorrelationTables that are all derived from different diagonal matrices by the same transformation matrix. Settings Matrix dimension determines the size of the square matrix with cross-correlations. Number of matrices determines the number of matrices that have to be generated. First is positive-definite guarantees that the first matrix of the series is positive definite. Sigma the standard deviation of the noise that is added to each transformation matrix element. A value of zero makes all the cross-correlation matrices jointly diagonalizable. A value greater than zero makes each transformation matrix a little different and the collection not jointly diagonalizable anymore. Algorithm All the CrossCorrelationTable matrices are generated as V′·Dk· V, where Dk is a diagonal matrix with entries randomly choosen from the [-1,1] interval. The matrix V is a random orthogonal matrix obtained from the singular value decomposition of a matrix M = U·D·V′, where the cells of the matrix M are random Gaussian numbers with mean 0 and standard deviation 1. If the first matrix has to be positive definite, the numbers on the diagonal of D1 are randomly chosen from the [0.1,1] interval. 
Davis___Mermelstein__1980_	Davis & Mermelstein (1980) S.B. Davis & P. Mermelstein (1980), Comparison of parametric representations for monosyllabic word recognition in continuously spoken sentences. IEEE Transactions on ASSP 28: 357–366. Links to this page MelFilter: To MFCC... 
De_Leeuw__1977_	De Leeuw (1977) J. de Leeuw (1977): Applications of convex analysis to multidimensional scaling. In J.R. Barra, F. Brodeau, G. Romier & B. van Cutsem (eds.): Recent developments in statistics. Amsterdam: North-Holland. 133–145. Links to this page smacof stress 
De_Leeuw___Pruzansky__1978_	De Leeuw & Pruzansky (1978) J. de Leeuw & S. Pruzansky (1978): A new computational method to fit the weighted Euclidean distance model. Psychometrika 43: 479–490. 
Deliyski__1993_	Deliyski (1993) Dimitar D. Deliyski: Acoustic model and evaluation of pathological voice production. Proceedings Eurospeech '93, Vol. 3, 1969–1972. Links to this page Voice 5. Comparison with other programs 
Demo_window	Demo window The Demo window is a window in which you can draw and ask for user input. You can use it for demonstrations, presentations, simulations, adaptive listening experiments, and stand-alone programs (see Scripting 9.1. Turning a script into a stand-alone program). The Demo window is Praat's least visible window: you can create it only through a script. Try the following script after selecting a Sound object: demo Draw: 0, 3, -1, 1, yes, curve You see the Demo window turning up on the screen, with the Sound painted into it. It works because the Draw... command is available in the Objects window when you select a Sound. Then try: demo Draw line: 0, -1, 3, 1 You see a line drawn from (0 seconds, -1 Pa) to (3 seconds, +1 Pascal) in the waveform. It works because the Draw line... command is available in the Picture window. Then try: demo Erase all demo Red demo Axes: 0, 100, 0, 100 demo Text: 50, centre, 50, half, Hello You see a text appearing in red, in the centre of the window. This works because you are using commands from the Picture window, including the Axes... command, which sets the world coordinates to something else than before (before, the world coordinates were determined by the Sound). Now suppose you want the Sound to appear in the top half of the window, and some texts in the bottom left and bottom right corners of the window. You can use Select outer viewport... and Select inner viewport..., if you know that the size of the Demo window is 100 horizontally and 100 vertically (rather than 12×12, as the Picture window), and that the point (0, 0) lies in the bottom left (rather than the top left, as in the Picture window): demo Erase all demo Black demo Times demo 24 demo Select outer viewport: 0, 100, 50, 100 demo Draw: 0, 0, 0, 0, yes, curve demo Select inner viewport: 0, 100, 0, 100 demo Axes: 0, 10, 0, 10 demo Text: 0, left, 0, bottom, Left, bottom corner demo Text: 10, right, 0, bottom, Right bottom corner As the title page of a presentation, you could do: demo Erase all demo Select inner viewport: 0, 100, 0, 100 demo Axes: 0, 100, 0, 100 demo Paint rectangle: purple, 0, 100, 0, 100 demo Pink demo Text: 50, centre, 50, half, This is my title Getting user input For almost all applications, you will want the user (or the participant in an experiment) to be able to click on things in the Demo window, or to control the Demo window by pressing keys. Here is a presentation with two screens: demo Erase all demo Select inner viewport: 0, 100, 0, 100 demo Axes: 0, 100, 0, 100 demo Paint rectangle: purple, 0, 100, 0, 100 demo Pink demo Text: 50, centre, 50, half, This is the first page demoWaitForInput ( ) demo Erase all demo Paint rectangle: purple, 0, 100, 0, 100 demo Text: 50, centre, 50, half, This is the second page In this example, you go from the first to the second screen either by clicking with the mouse or by pressing any key. You will usually want to be more selective in your choice of user actions to respond to. The function demoWaitForInput always returns 1, so that you can use it nicely in a loop, in which you can react selectively: label FIRST_SCREEN demo Erase all demo Black demo Times demo 24 demo Select inner viewport: 0, 100, 0, 100 demo Axes: 0, 100, 0, 100 demo Paint rectangle: purple, 0, 100, 0, 100 demo Pink demo Text: 50, centre, 50, half, This is the first page while demoWaitForInput ( ) if demoClicked ( ) goto SECOND_SCREEN elsif demoKeyPressed ( ) if demoKey$ ( ) = → or demoKey$ ( ) = goto SECOND_SCREEN endif endif endwhile label SECOND_SCREEN demo Erase all demo Paint rectangle: purple, 0, 100, 0, 100 demo Text: 50, centre, 50, half, This is the second page while demoWaitForInput ( ) if demoClicked ( ) goto END elsif demoKeyPressed ( ) if demoKey$ ( ) = ← goto FIRST_SCREEN elsif demoKey$ ( ) = → or demoKey$ ( ) = goto END endif endif endwhile label END This script allows you to use the arrow keys and the space bar to navigate between the two screens. A shorter version is: label FIRST_SCREEN demo Erase all demo Black demo Times demo 24 demo Select inner viewport: 0, 100, 0, 100 demo Axes: 0, 100, 0, 100 demo Paint rectangle: purple, 0, 100, 0, 100 demo Pink demo Text: 50, centre, 50, half, This is the first page while demoWaitForInput ( ) goto SECOND_SCREEN demoInput (•→ ) endwhile label SECOND_SCREEN demo Erase all demo Paint rectangle: purple, 0, 100, 0, 100 demo Text: 50, centre, 50, half, This is the second page while demoWaitForInput ( ) goto END demoInput (•→ ) goto FIRST_SCREEN demoInput (←) endwhile label END This uses two tricks, namely the possibility of following the goto statement by a condition and using demoInput to quickly test for multiple possible inputs (the bullet represents a mouse click). Getting click locations You can use the functions demoX and demoY to see where the user has clicked. These function respond in world coordinates. To see whether the user has clicked in the sound that occupies the upper half of the screne in the above example, you do while demoWaitForInput ( ) if demoClicked ( ) Select outer viewport: 0, 100, 50, 100 Axes: 0, 3, -1, 1 if demoX ( ) >= 0 and demoX ( ) < 3 and demoY ( ) >= -1 and demoY ( ) < 1 The last line can be shortened to: if demoClickedIn (0, 3, -1, 1) Another example of when you want to know the click location is when you test for a click on a button that you drew on the screen: demo Paint rounded rectangle: pink, 30, 70, 16, 24 demo Text: 50, centre, 20, half, Analyse while demoWaitForInput ( ) goto ANALYSE demoClickedIn (30, 70, 16, 24) Full-screen viewing When you click in the top right corner of the Demo window (64-bit Mac) or in the zoom box (the green button in the title bar of the Demo window on 32-bit Mac), the Demo window will zoom out very strongly: it will fill up the whole screen. The menu bar becomes invisible, although you can still make it temporarily visible and accessible by moving the mouse to the upper edge of the screen. The Dock also becomes invisible, although you can make it temporarily visible and accessible by moving the mouse to the edge of the screen (the left, bottom, or right edge, depending on where your Dock normally is). When you click the zoom box again, the Demo window is restored to its original size. See also Tips and Tricks below. Asynchronous play If you select a Sound and execute the command Play Praat will play the whole sound before proceeding to the next line of your script. You will often instead want Praat to continue running your script while the sound is playing. To accomplish that, use the asynchronous directive: Create Sound as pure tone: tone, 1, 0, 0.2, 44100, 440, 0.2, 0.01, 0.01 asynchronous Play Remove The sound will continue to play, even after the Sound object has been removed. Please note that a following Play command will interrupt the playing of the first: while demoWaitForInput ( ) if demoClicked ( ) Create Sound as pure tone: tone, 1, 0, 3.0, 44100, ... randomGauss (440, 100), 0.2, 0.01, 0.01 asynchronous Play Remove endif endwhile The first sound will stop playing soon after the user clicks for the second time. Miscellaneous In the above examples, things will often get drawn to the screen with some delay, i.e., you may not see the erasures and paintings happening. This is because several operating systems use buffering of graphics. These systems will draw the graphics only just before getting user input. This means that demoWaitForInput is the place where your drawings will typically be painted on the screen. If you want painting to happen earlier (e.g. in animations), you can use demoShow ( ). To see whether any function keys are pressed (during a mouse click or key press), you can use demoShiftKeyPressed ( ), demoCommandKeyPressed ( ), demoOptionKeyPressed ( ), and demoExtraControlKeyPressed ( ). To put some text in the title bar of the Demo window, try demoWindowTitle: This is the title of my presentation Tips and Tricks If you resize the Demo window with the handle in the bottom left, or if you zoom the window out to the full screen, you may see that the relative positions of the contents of the window will change. Also, clicking on buttons and in parts of the window may yield unexpected x and y values. It is therefore advisable to resize the window only if you are on a page that you can get out of by pressing a key, or by clicking anywhere in the window without using demoX, demoY or demoClickedIn. If you click away the Demo window while it is waiting for input, you get a message saying You interrupted the script.... If you do not want to see this message, you should make sure that the user can reach the end of the script, for instance by pressing the → key on the last page. To make sure the user sees that the script has ended, you could end it with demo Erase all. Your demo can save its preferences in a directory of its choice, e.g. in 'preferencesDirectory$'/../GuineaPigAnalyzer if your demo is called GuineaPigAnalyzer. If you want to be less conspicuous and like to use the Praat preferences directory instead, please use the apps subdirectory, in this way: createDirectory: preferencesDirectory$ + /apps createDirectory: preferencesDirectory$ + /apps/GuineaPigAnalyzer Links to this page ExperimentMFC 1. When to use Praat Insert picture from file... Intro ManPages Scripting 6.6. Controlling the user What was new in 5.2? What's new? 
Difference_of_two_proportions	Difference of two proportions This page explains how you compute the significance of a difference between two proportions with a χ2 (chi-square) test. 1. Example of normal use Suppose that you are interested in proving that for a certain experimental participant Task B is easier than Task A.You let the participant perform Task A 110 times, and she turns out to perform this task correctly 71 times. You also let her perform Task B 120 times, and she performs this task correctly 93 times. The following table summarizes the results of your experiment: CorrectIncorrect Task A7139 Task B9327 The null hypothesis is that both tasks are equally difficult for the participant and that the probability that she performs Task A correctly is equal to the probability that she performs Task B correctly. To compute the probability that the observed proportions are at least as different as 93/120 and 71/110 if the null hypothesis is true, go to Report difference of two proportions in the Goodies menu and fill in the four values 71, 39, 93, and 27. The resulting two-tailed p is 0.04300, suggesting that the null hypothesis can be rejected and the two tasks are not equally difficult for the participant (if the possibility that Task A is easier for her than Task B can be ruled out a priori, then the resulting one-tailed p is 0.02150). 2. Example of incorrect use: areal features An anonymous linguist once proposed that there was a causal relation between blood groups and the incidence of dental fricatives. He noticed that dental fricatives occurred mainly in languages whose speakers predominantly had blood group O. To prove his point, he tabulated 100 languages: Has /θ/ or /ð/No dental fricatives Group O2411 Group A or B2936 Since p < 0.05, the linguist regarded his hypothesis as being supported by the facts. However, this χ2 test assumes that the 100 languages are independent, but they are not. Two adjacent languages tend to correlate in their probability of having dental fricatives, and their speakers tend to correlate in their blood groups. Both are areal features, which undermine the independence assumed by the χ2 test. The actual null hypothesis that the test rejected was the combined hypothesis that dental fricatives correlate with blood group and that the 100 languages are independent. Another anonymous linguist proposed that those Limburgian dialects that had lost their tone contrast compensated this by having larger vowel inventories. He drew up a table of the dialects of 100 villages: Has toneHas no tone Has over 25 vowels107 Has under 25 vowels803 This result is very significant (p < 10-4), but only shows that either there is a relation between tone and the number of vowels or that the dialects are not independent. And since adjacent dialects are arguably dependent both with respect to tone and the number of vowels, the statistical significance does not allow us to draw any conclusion about the relationship between tone and the number of vowels. 3. Example of problematic use: pooling participants An anonymous student decided to do the Task A versus Task B experiment described above, but did not let one participant perform all the 230 tasks. Instead, she let 5 participants perform 46 tasks each (22 times task A, 24 times Task B). The pooled data were: CorrectIncorrect Task A7139 Task B10416 The resulting p is 0.00016. So what is the conclusion, if the measurements can clearly be dependent? Well, if the null hypothesis is that all five participants are equally good at Task A as at Task B, then this hypothesis can be rejected. The conclusion must be that these five participants have on average more trouble with Task A than with Task B. The student incorrectly concluded, however, that Task A was more difficult for the average population than Task B. In order to be able to draw such a conclusion, however, a different test would be required, namely one that takes into account that the five participants form a random sample from the total population. The simplest such test would be a sign test over the participants: count those participants who score better on Task A than on Task B and see whether this number is reliably less than 50 percent of all participants. For five participants, such a sign test would never reach significance at a two-tailed 5 percent level (2·0.55 = 0.0625). 4. Example of problematic use: pooling participants Our purpose was to disprove the null hypothesis that listeners' perception does not depend on the language they think they hear. However, certain vowel tokens acoustically in between the Dutch /ɑ/ and the Dutch /ɔ/ were perceived 50 percent of the time as /ɑ/ and 50 percent of the time as /ɔ/ when Dutch learners of Spanish thought they were hearing Dutch, but 60 percent of the time as /ɔ/ when they thought they were hearing Spanish. The responses of 40 listeners, all of whom underwent both language modes, is combined in the following table: /ɑ//ɔ/ Dutch mode200200 Spanish mode160240 The result was p = 0.0056, which reliably showed that these 40 listeners on average shifted their category boundary toward /ɑ/ when they thought that the language they were listening to was Spanish. The conclusion is that not all listeners were indifferent to the language mode, so that mode-dependent perception must exist. The explanation in this case was that the Spanish /a/ (which Dutch learners of Spanish identify with their /ɑ/) is more auditorily front than Dutch /ɑ/; in order to reject the null hypothesis that language modes exist but that their direction is random for each learner, i.e. the population average of the shift is zero, a separate test was required to show that the observed shift is representative of the population of Dutch learners of Spanish (this is easier to accomplish for 40 participants than for 5). Links to this page Statistics 
differenceLimensToPhon	differenceLimensToPhon A routine for converting intensity difference limens into sensation level, the inverse of phonToDifferenceLimens. Formula differenceLimensToPhon (ndli) = ln (1 + ndli / 30) / ln (61 / 60) Links to this page Formulas 4. Mathematical functions 
Discriminant	Discriminant One of the types of objects in PRAAT. An object of type Discriminant represents the discriminant structure of a multivariate data set with several groups. This discriminant structure consists of a number of orthogonal directions in space, along which maximum separability of the groups can occur. Commands Creation: Discriminant analysis tutorial TableOfReal: To Discriminant Drawing Draw eigenvalues... Draw eigenvector... Draw sigma ellipses... Links to this page Discriminant & Pattern: To Categories... Discriminant & SSCP: Project Discriminant & TableOfReal: To ClassificationTable... Discriminant & TableOfReal: To Configuration... Discriminant & TableOfReal: To TableOfReal (mahalanobis)... Discriminant: Extract pooled within-groups SSCP Discriminant: Extract within-group SSCP... Discriminant: Get concentration ellipse area... Discriminant: Get confidence ellipse area... Discriminant: Get contribution of component... Discriminant: Get partial discrimination probability... Discriminant: Get Wilks' lambda... epoch Feedforward neural networks 3. FFNet versus discriminant classifier TableOfReal: To Configuration (lda)... 
Discriminant___Pattern__To_Categories___	Discriminant & Pattern: To Categories... A command to use the selected Discriminant to classify each pattern from the selected Pattern into a category. Arguments as in Discriminant & TableOfReal: To ClassificationTable.... 
Discriminant___SSCP__Project	Discriminant & SSCP: Project A command to project the selected SSCP object on the eigenspace defined by the selected Discriminant object. Further details can be found in Eigen & SSCP: Project 
Discriminant___TableOfReal__To_ClassificationTable___	Discriminant & TableOfReal: To ClassificationTable... A command to use the selected Discriminant to classify each row from the selected TableOfReal. The newly created ClassificationTable will then contain the posterior probabilities of group membership. Settings Pool covariance matrices when on, all group covariance matrices are pooled and distances will be determined on the basis of only this pooled covariance matrix (see below). Details The posterior probabilities of group membership pj for a vector x are defined as: pj = p(j|x) = exp (–dj2(x) / 2) / ∑k=1..numberOfGroups exp (–dk2(x) / 2), where di2 is the generalized squared distance function: di2(x) = ((x–μi)′ Σi-1 (x–μi) + ln determinant (Σi)) / 2 – ln aprioriProbabilityi that depends on the individual covariance matrix Σi and the mean μi for group i. When the covariances matrices are pooled, the squared distance function can be reduced to: di2(x) = ((x–μi)′ Σ-1 (x–μi) – ln aprioriProbabilityi, and Σ is now the pooled covariance matrix. The a priori probabilities normally will have values that are related to the number of training vectors ni in each group: aprioriProbabilityi = ni / Σk=1..numberOfGroups nk Links to this page Discriminant & Pattern: To Categories... Discriminant analysis 
Discriminant___TableOfReal__To_Configuration___	Discriminant & TableOfReal: To Configuration... A command to project each row in the selected TableOfReal onto a space spanned by the eigenvectors of the selected Discriminant. Settings Number of dimensions specifies the number of eigenvectors taken into account, i.e., determines the dimension of the resulting Configuration. When the default value (0) is given the resulting Configuration will have the maximum dimension as allowed by the number of eigenvectors in the selected Discriminant. Precondition The number of columns in the TableOfReal must equal the dimension of the eigenvectors in the Discriminant. See also Eigen & TableOfReal: Project.... Links to this page Discriminant analysis 
Discriminant___TableOfReal__To_TableOfReal__mahalanobis	Discriminant & TableOfReal: To TableOfReal (mahalanobis)... Calculate Mahalanobis distances for the selected TableOfReal with respect to one group in the selected Discriminant object. Settings Group label defines which group mean to use for the distance calculation. Pool covariance matrices when on use a pooled covariance matrix instead of the group covariance matrix. Algorithm See Covariance & TableOfReal: To TableOfReal (mahalanobis).... Example Calculate the number of datapoints that are within the one-sigma elipses of two different groups, i.e. the number of data points that are in the overlapping area. Suppose the group labels are ø and ʏ. pols50m = Create TableOfReal (Pols 1973): no Formula: log10(self) discriminant = To Discriminant selectObject: pols50m, discriminant t1 = To TableOfReal (mahalanobis): \o/, no selectObject: pols50m, discriminant t2 = To TableOfReal (mahalanobis): \yc, no Now we count when both the t1 and t2 values are smaller than 1 (sigma): Copy: tr Formula: Object_'t1'[] < 1 and Object_'t2'[] < 1 Extract rows where column: 1, equal to, 1 no = Get number of rows 
Discriminant__Draw_sigma_ellipses___	Discriminant: Draw sigma ellipses... A command to draw for each group from the selected Discriminant an ellipse that covers part of the multivariate data. Settings Number of sigmas determines the data coverage. Discriminant plane When on, the selected X and Y-dimension will refer to the eigenvectors of the discriminant space, and, consequently, the projection of the hyper ellipsoid onto the space spanned by these eigenvectors will be drawn. When off, the selected X and Y-dimension will refer to the original dimensions. Xmin, Xmax, Ymin, Ymax determine the limits of the drawing area. Label size determines the size of the labels at the centre of the ellipse. No labels will be drawn when a value less than or equal to zero is chosen. Links to this page Discriminant analysis 
Discriminant__Extract_pooled_within-groups_SSCP	Discriminant: Extract pooled within-groups SSCP Extract the pooled within-group SSCP from the selected Discriminant object. 
Discriminant__Extract_within-group_SSCP___	Discriminant: Extract within-group SSCP... Extract the SSCP for group index from the selected Discriminant object. 
Discriminant__Get_concentration_ellipse_area___	Discriminant: Get concentration ellipse area... A command to query the Discriminant object for the area of the concentration ellipse of one of its groups. Settings Number of sigmas determines the data coverage. Discriminant plane When on, the selected X and Y-dimension will refer to the eigenvectors of the discriminant space, and, consequently, the area of the projection of the hyper ellipsoid onto the space spanned by these eigenvectors will be calculated. When off, the selected X and Y-dimension will refer to the original dimensions. Algorithm See SSCP: Get sigma ellipse area... 
Discriminant__Get_confidence_ellipse_area___	Discriminant: Get confidence ellipse area... A command to query the Discriminant object for the area of the confidence ellipse of one of its groups. Settings Discriminant plane When on, the selected X and Y-dimension will refer to the eigenvectors of the discriminant space, and, consequently, the area of the projection of the hyper ellipsoid onto the space spanned by these eigenvectors will be calculated. When off, the selected X and Y-dimension will refer to the original dimensions. Algorithm See SSCP: Get confidence ellipse area... 
Discriminant__Get_contribution_of_component___	Discriminant: Get contribution of component... A command to ask the selected Discriminant for the contribution of the jth discriminant function (component) to the total variance. Details The contribution is defined as: eigenvalue[j] / Σi=1..numberOfEigenvalues eigenvalue[i] 
Discriminant__Get_partial_discrimination_probability___	Discriminant: Get partial discrimination probability... A command to test the selected Discriminant for the significance of discrimination afforded by the remaining n–k eigenvectors after the acceptance of the first k eigenvectors. Details The test statistic is: χ2 = –(degreesOfFreedom–(numberOfGroups+dimension)/2) ln Λ′, where degreesOfFreedom = (dimension–k)(numberOfGroups–k–1), and, Λ′ = Πj=k+1..numberOfEigenvalues 1 / (1 + eigenvalue[j]) 
Discriminant__Get_Wilks__lambda___	Discriminant: Get Wilks' lambda... A command to ask the selected Discriminant for the value of Wilks' lamda (a multivariate measure of group differences over several variables). Settings From the first eigenvalue number from which the value for lambda has to be calculated. Details Wilks' lambda is defined as: Λ = Πi=from..numberOfEigenvalues 1 / (1 + eigenvalue[i]) Because lambda is a kind of inverse measure, values of lambda which are near zero denote high discrimination between groups. 
Discriminant_analysis	Discriminant analysis This tutorial will show you how to perform discriminant analysis with PRAAT As an example, we will use the dataset from Pols et al. (1973) with the frequencies and levels of the first three formants from the 12 Dutch monophthongal vowels as spoken in /h_t/ context by 50 male speakers. This data set has been incorporated into Praat and can be called into play with the Create TableOfReal (Pols 1973)... command that can be found in the New / TableOfReal menu. In the list of objects a new TableOfReal object will appear with 6 columns and 600 rows (50 speakers × 12 vowels). The first three columns contain the formant frequencies in Hz, the last three columns contain the levels of the first three formants given in decibels below the overall sound pressure level of the measured vowel segment. Each row is labelled with a vowel label. Pols et al. use logarithms of frequency values, we will too. Because the measurement units in the first three columns are in Hz and in the last three columns in dB, it is probably better to standardize the columns. The following script summarizes our achievements up till now: table = Create TableOfReal (Pols 1973): yes Formula: if col < 4 then log10 (self) else self fi Standardize columns # change the column labels too, for nice plot labels. Set column label (index): 1, standardized log (%F__1_) Set column label (index): 2, standardized log (%F__2_) Set column label (index): 3, standardized log (%F__3_) Set column label (index): 4, standardized %L__1_ Set column label (index): 5, standardized %L__2_ Set column label (index): 6, standardized %L__3_ To get an indication of what these data look like, we make a scatter plot of the first standardized log-formant-frequency against the second standardized log-formant-frequency. With the next script fragment you can reproduce the following picture. Viewport: 0, 5, 0, 5 selectObject: table Draw scatter plot: 1, 2, 0, 0, -2.9, 2.9, -2.9, 2.9, 10, yes, +, yes Apart from a difference in scale this plot is the same as fig. 3 in the Pols et al. article. 1. How to perform a discriminant analysis Select the TableOfReal and choose from the dynamic menu the option To Discriminant. This command is available in the Multivariate statistics action button. The resulting Discriminant object will bear the same name as the TableOfReal object. The following script summarizes: selectObject: table discrimimant = To Discriminant 2. How to project data on the discriminant space You select a TableOfReal and a Discriminant object together and choose: To Configuration.... One of the options of the newly created Configuration object is to draw it. The following picture shows how the data look in the plane spanned by the first two dimensions of this Configuration. The directions in this configuration are the eigenvectors from the Discriminant. The following script summarizes: selectObject: table, discriminant To Configuration: 0 Viewport: 0, 5, 0, 5 Draw: 1, 2, -2.9, 2.9, -2.9, 2.9, 12, yes, +, yes If you are only interested in this projection, there also is a short cut without an intermediate Discriminant object: select the TableOfReal object and choose To Configuration (lda).... 3. How to draw concentration ellipses Select the Discriminant object and choose Draw sigma ellipses.... In the form you can fill out the coverage of the ellipse by way of the Number of sigmas parameter. You can also select the projection plane. The next figure shows the 1-σ concentration ellipses in the standardized log F1 vs log F2 plane. When the data are multinormally distributed, a 1-σ ellipse will cover approximately 39.3% of the data. The following code summarizes: selectObject: discriminant Draw sigma ellipses: 1.0, no, 1, 2, -2.9, 2.9, -2.9, 2.9, 12, yes 4. How to classify Select together the Discriminant object (the classifier), and a TableOfReal object (the data to be classified). Next you choose To ClassificationTable. Normally you will enable the option Pool covariance matrices and the pooled covariance matrix will be used for classification. The ClassificationTable can be converted to a Confusion object and its fraction correct can be queried with: Confusion: Get fraction correct. In general you would separate your data into two independent sets, TRAIN and TEST. You would use TRAIN to train the discriminant classifier and TEST to test how well it classifies. Several possibilities for splitting a dataset into two sets exist. We mention the jackknife (leave-one-out) and the bootstrap methods (resampling). Links to this page Acknowledgments Canonical correlation analysis Configuration Discriminant Feedforward neural networks 3. FFNet versus discriminant classifier Intro Statistics Types of objects What was new in 3.9? 
disparities	disparities The numbers d′ij that result from applying an admissible transformation f on the dissimilarities δij, i.e., d′ij = f (δij). Disparities have the same dimension as distances. Other names for disparities are pseudo distances and target distances. Links to this page Dissimilarity & Configuration & Weight: Get stress... Dissimilarity & Configuration: Draw regression (absolute mds)... Dissimilarity & Configuration: Draw regression (i-spline mds)... Dissimilarity & Configuration: Draw regression (interval mds)... Dissimilarity & Configuration: Draw regression (monotone mds)... Dissimilarity & Configuration: Draw regression (ratio mds)... Dissimilarity: To Configuration (absolute mds)... Dissimilarity: To Configuration (i-spline mds)... Dissimilarity: To Configuration (interval mds)... Dissimilarity: To Configuration (monotone mds)... Dissimilarity: To Configuration (ratio mds)... MDS models stress 
Dissimilarity	Dissimilarity One of the types of objects in PRAAT. It represents a one-way table with dissimilarities between objects. Creating a Dissimilarity from data in a text file Suppose you have three objects A, B and C. In one way or another, you have acquired the following (symmetric) dissimilarities: δAB = 2 (= δBA) , δAC = 1 (= δCA), and δBC = 1.4 (= δCB), where δAB represents the dissimilarity between object A and object B. You can create a simple text file like the following: ooTextFile ! The line by which Praat can recognize your file Dissimilarity ! The line that tells Praat about the contents 3 A B C ! Number of columns, and column labels 3 ! Number of rows A 0 2 1 ! Row label (A), A-B value, A-C value B 2 0 1.4 ! Row label (B), B-A value, B-C value C 1 1.4 0 ! Row label (C), C-A value, C-B value Notice that: the row and column labels are identical. the matrix elements on the diagonal are zero. the matrix is symmetrical. This text file can be read with the Read from file... command. Since a Dissimilarity object has the data structure of a square symmetrical TableOfReal, you could also start from an appropriate TableOfReal object and cast it to a Dissimilarity object. Commands Creation Confusion: To Dissimilarity... Drawing Draw as numbers... Draw as squares... Query Get column mean (index)... Get column mean (label)... Get column stdev (index)... Get column stdev (label)... Dissimilarity: Get additive constant Modification Formula... Set value... Remove column (index)... Insert column (index)... Set row label (index)... Set row label (label)... Set column label (index)... Set column label (label)... Multidimensional scaling analysis Dissimilarity: To Configuration (monotone mds)... Dissimilarity: To Configuration (i-spline mds)... Dissimilarity: To Configuration (interval mds)... Dissimilarity: To Configuration (ratio mds)... Dissimilarity: To Configuration (absolute mds)... Dissimilarity: To Configuration (kruskal)... Transformations Dissimilarity: To Distance... Dissimilarity: To Weight Links to this page Confusion: To Dissimilarity (pdf)... Create INDSCAL Carroll & Wish example... Create letter R example... Dissimilarity & Configuration & Weight: Get stress... Dissimilarity & Configuration & Weight: To Configuration... Dissimilarity & Configuration: Draw regression (absolute mds)... Dissimilarity & Configuration: Draw regression (i-spline mds)... Dissimilarity & Configuration: Draw regression (interval mds)... Dissimilarity & Configuration: Draw regression (monotone mds)... Dissimilarity & Configuration: Draw regression (ratio mds)... Dissimilarity & Configuration: Draw Shepard diagram... Dissimilarity & Configuration: Get stress (absolute mds)... Dissimilarity & Configuration: Get stress (i-spline mds)... Dissimilarity & Configuration: Get stress (interval mds)... Dissimilarity & Configuration: Get stress (monotone mds)... Dissimilarity & Configuration: Get stress (ratio mds)... Dissimilarity & Configuration: To Configuration (absolute mds)... Dissimilarity & Configuration: To Configuration (i-spline mds)... Dissimilarity & Configuration: To Configuration (interval mds)... Dissimilarity & Configuration: To Configuration (kruskal)... Dissimilarity & Configuration: To Configuration (monotone mds)... Dissimilarity & Configuration: To Configuration (ratio mds)... Dissimilarity & Weight: To Configuration... Dissimilarity & Weight: To Configuration... FeatureWeights INDSCAL analysis Kruskal analysis MDS models Multidimensional scaling Pattern & FeatureWeights: To Dissimilarity... Pattern to Dissimilarity Pattern: To Dissimilarity... Similarity: To Dissimilarity... Weight 
Dissimilarity___Configuration___Weight__Get_stress___	Dissimilarity & Configuration & Weight: Get stress... A command that calculates the stress between distances dij derived from the selected Configuration object and disparities d′ij derived from the selected Dissimilarity object. With the selected Weight object the evaluation of the influence of each dissimilarity on stress can be influenced. Settings Normalized stress, Kruskal's stress-1, Kruskal's stress-2 or Raw stress Behaviour Except for absolute mds, we us stress formula's that are independent of the scale of the Configuration (see stress): you would have got the same stress value if you had pre-multiplied the selected Configuration with any number greater than zero. 
Dissimilarity___Configuration___Weight__To_Configuratio	Dissimilarity & Configuration & Weight: To Configuration... A command that creates a Configuration object from a Dissimilarity object. With the selected Weight object the influence of each dissimilarity on stress can be influenced. The selected Configuration object serves as a starting configuration for the minimization process. Settings Dissimilarity: To Configuration (monotone mds)... Dissimilarity: To Configuration (i-spline mds)... Dissimilarity: To Configuration (interval mds)... Dissimilarity: To Configuration (ratio mds)... Dissimilarity: To Configuration (absolute mds)... 
Dissimilarity___Configuration__Draw_regression__absolut	Dissimilarity & Configuration: Draw regression (absolute mds)... Draws a scatterplot of the dissimilarities δij from the selected Dissimilarity object versus disparities d′ij obtained from the regression of distances dij from Configuration on the dissimilarities δij. d′ij = δij Settings Minimum proximity, Maximum proximity minimum and maximum values for the proximities (horizontal axis). Minimum distance, Maximum distance minimum and maximum values for the distances (vertical axis). Mark size (mm), Mark string size and kind of the marks in the plot. Garnish when on, draws a bounding box with decoration. 
Dissimilarity___Configuration__Draw_regression__i-splin	Dissimilarity & Configuration: Draw regression (i-spline mds)... Draws a scatterplot of the dissimilarities δij from the selected Dissimilarity versus disparities d′ij obtained from the regression of distances dij from Configuration on the spline transformed dissimilarities δij. Settings Number of interior knots determines the number of segments. Order of I-spline The order of the polynomial basis of the I-spline. Minimum proximity, Maximum proximity minimum and maximum values for the proximities (horizontal axis). Minimum distance, Maximum distance minimum and maximum values for the distances (vertical axis). Mark size (mm), Mark string size and kind of the marks in the plot. Garnish when on, draws a bounding box with decoration. 
Dissimilarity___Configuration__Draw_regression__interva	Dissimilarity & Configuration: Draw regression (interval mds)... Draws a scatterplot of the dissimilarities δij from the selected Dissimilarity versus disparities d′ij obtained from the regression of distances dij from Configuration on the dissimilarities δij. d′ij = a + b · δij, where the values of a and b are determined by regression. Settings Minimum proximity, Maximum proximity minimum and maximum values for the proximities (horizontal axis). Minimum distance, Maximum distance minimum and maximum values for the distances (vertical axis). Mark size (mm), Mark string size and kind of the marks in the plot. Garnish when on, draws a bounding box with decoration. 
Dissimilarity___Configuration__Draw_regression__monoton	Dissimilarity & Configuration: Draw regression (monotone mds)... Draws a scatterplot of the dissimilarities δij from the selected Dissimilarity versus disparities d′ij obtained from the monotone regression of distances dij from Configuration on the dissimilarities δij. Settings Primary or secondary approach to ties When dissimilarities are equal, i.e., δij = δkl the primary approach imposes no conditions on the corresponding distances dij and dkl, while the secondary approach demands that also dij = dkl. Minimum proximity, Maximum proximity minimum and maximum values for the proximities (horizontal axis). Minimum distance, Maximum distance minimum and maximum values for the distances (vertical axis). Mark size (mm), Mark string size and kind of the marks in the plot. Garnish when on, draws a bounding box with decoration. Links to this page Multidimensional scaling 
Dissimilarity___Configuration__Draw_regression__ratio_m	Dissimilarity & Configuration: Draw regression (ratio mds)... Draws a scatterplot of the dissimilarities δij from the selected Dissimilarity versus disparities d′ij obtained from the regression of distances dij from Configuration on the dissimilarities δij. d′ij = b · δij, where the value of b is determined by regression. Settings Minimum proximity, Maximum proximity minimum and maximum values for the proximities (horizontal axis). Minimum distance, Maximum distance minimum and maximum values for the distances (vertical axis). Mark size (mm), Mark string size and kind of the marks in the plot. Garnish when on, draws a bounding box with decoration. 
Dissimilarity___Configuration__Draw_Shepard_diagram___	Dissimilarity & Configuration: Draw Shepard diagram... Draws the Shepard diagram. This is a scatterplot of the dissimilarities from the Dissimilarity object versus distances (as calculated from the Configuration). Settings Minimum proximity, Maximum proximity minimum and maximum values for the proximities (horizontal axis). Minimum distance, Maximum distance minimum and maximum values for the distances (vertical axis). Mark size (mm), Mark string size and kind of the marks in the plot. Garnish when on, draws a bounding box with decoration. Links to this page Multidimensional scaling 
Dissimilarity___Configuration__Get_stress__absolute_mds	Dissimilarity & Configuration: Get stress (absolute mds)... A command to obtain the stress value for the selected Dissimilarity and Configuration object. Behaviour Stress formula's are dependent of the scale of the Configuration: you will get another stress value if you had pre-multiplied the selected Configuration with any number greater than zero. 
Dissimilarity___Configuration__Get_stress__i-spline_mds	Dissimilarity & Configuration: Get stress (i-spline mds)... A command to obtain the stress value for the selected Dissimilarity and Configuration object. Behaviour We use stress formula's that are independent of the scale of the Configuration: you would have got the same stress value if you had pre-multiplied the selected Configuration with any number greater than zero. 
Dissimilarity___Configuration__Get_stress__interval_mds	Dissimilarity & Configuration: Get stress (interval mds)... A command to obtain the stress value for the selected Dissimilarity and Configuration object. Behaviour We use stress formula's that are independent of the scale of the Configuration: you would have got the same stress value if you had pre-multiplied the selected Configuration with any number greater than zero. 
Dissimilarity___Configuration__Get_stress__monotone_mds	Dissimilarity & Configuration: Get stress (monotone mds)... A command to obtain the stress value for the selected Dissimilarity and Configuration object. Behaviour We use stress formula's that are independent of the scale of the Configuration: you would have got the same stress value if you had pre-multiplied the selected Configuration with any number greater than zero. Links to this page Kruskal analysis Multidimensional scaling 
Dissimilarity___Configuration__Get_stress__ratio_mds___	Dissimilarity & Configuration: Get stress (ratio mds)... A command to obtain the stress value for the selected Dissimilarity and Configuration object. Behaviour We use stress formula's that are independent of the scale of the Configuration: you would have got the same stress value if you had pre-multiplied the selected Configuration with any number greater than zero. 
Dissimilarity___Configuration__To_Configuration__absolu	Dissimilarity & Configuration: To Configuration (absolute mds)... A command that creates a Configuration object from a Dissimilarity object. The selected Configuration object serves as a starting configuration for the minimization process. 
Dissimilarity___Configuration__To_Configuration__i-spli	Dissimilarity & Configuration: To Configuration (i-spline mds)... A command that creates a Configuration object from a Dissimilarity object. The selected Configuration object serves as a starting configuration for the minimization process. 
Dissimilarity___Configuration__To_Configuration__interv	Dissimilarity & Configuration: To Configuration (interval mds)... A command that creates a Configuration object from a Dissimilarity object. The selected Configuration object serves as a starting configuration for the minimization process. 
Dissimilarity___Configuration__To_Configuration__kruska	Dissimilarity & Configuration: To Configuration (kruskal)... A command to fit an optimal Configuration for the selected Dissimilarity object. The selected Configuration will be used as the starting configuration in the kruskal analysis. 
Dissimilarity___Configuration__To_Configuration__monoto	Dissimilarity & Configuration: To Configuration (monotone mds)... A command that creates a Configuration object from a Dissimilarity object. The selected Configuration object serves as a starting configuration for the minimization process. 
Dissimilarity___Configuration__To_Configuration__ratio_	Dissimilarity & Configuration: To Configuration (ratio mds)... A command that creates a Configuration object from a Dissimilarity object. The selected Configuration object serves as a starting configuration for the minimization process. 
Dissimilarity___Weight__To_Configuration___	Dissimilarity & Weight: To Configuration... A command that creates a Configuration object from a Dissimilarity object. With the selected Weight object the influence of each dissimilarity on stress can be influenced. Settings May be different and depend on the representation function, i.e. the scale of measurement. Dissimilarity: To Configuration (monotone mds)... Dissimilarity: To Configuration (i-spline mds)... Dissimilarity: To Configuration (interval mds)... Dissimilarity: To Configuration (ratio mds)... Dissimilarity: To Configuration (absolute mds)... 
Dissimilarity__Get_additive_constant	Dissimilarity: Get additive constant A command that calculates the additive constant from the selected Dissimilarity. Distances dij will be obtained from dissimilarities δij according to: distanceij = dissimilarityij + additiveConstant We use a procedure by Cailliez (1983) to solve the additive constant problem, i.e. find the smallest additiveConstant such that all distanceij in the above equation have a Euclidean representation. Links to this page Dissimilarity: To Distance... 
Dissimilarity__To_Configuration__absolute_mds____	Dissimilarity: To Configuration (absolute mds)... A command that creates a Configuration object from a Dissimilarity object. The disparities d′ij will be obtained from dissimilarities δij according to: d′ij = δij Links to this page Dissimilarity & Configuration & Weight: To Configuration... Dissimilarity & Weight: To Configuration... Dissimilarity & Weight: To Configuration... 
Dissimilarity__To_Configuration__i-spline_mds____	Dissimilarity: To Configuration (i-spline mds)... A command that creates a Configuration object from a Dissimilarity object. Dissimilarities δij and disparities d′ij will be related by a spline function: d′ij = ∑k=1..(numberOfInteriorKnots+order) splinek (knots, order, δij), where splinek (·) is the value of the kth I-spline of order order and knot sequence knot evaluated at δij. Settings Number of dimensions determines the dimensionality of the configuration. Number of interior knots determines the number of segment boundaries. Each interior knot is the boundary between two segments. The splines in each segment will be joined as continuously as possible. Order of I-spline The order of the polynomial basis of the I-spline. Finding the optimal Configuration involves a minimization process: Tolerance When successive values for the stress differ by less than Tolerance, the minimization process stops. Maximum number of iterations Minimization stops after this number of iterations has been reached. Number of repetitions If chosen larger than 1, the minimization process will be repeated, each time with another random start configuration. The configuration that results in minimum stress, will be saved. Hints If numberOfInteriorKnots is zero, polynomial regression will be performed. Therefore , the combination numberOfInteriorKnots = 0 and order = 1 also gives interval scaling (in fact, it is the implementation in this program). In the limit when order = 0 and numberOfInteriorKnots = numberOfDissimilarities, monotone regression is performed. Links to this page Dissimilarity & Configuration & Weight: To Configuration... Dissimilarity & Weight: To Configuration... Dissimilarity & Weight: To Configuration... 
Dissimilarity__To_Configuration__interval_mds____	Dissimilarity: To Configuration (interval mds)... A command that creates a Configuration object from a Dissimilarity object. The disparities d′ij will be obtained from dissimilarities δij according to: d′ij = a + b · δij Links to this page Dissimilarity & Configuration & Weight: To Configuration... Dissimilarity & Weight: To Configuration... Dissimilarity & Weight: To Configuration... 
Dissimilarity__To_Configuration__kruskal____	Dissimilarity: To Configuration (kruskal)... A command that creates a Configuration object from a Dissimilarity object. Settings Number of dimensions (standard value: 2) The dimensionality of the Configuration. Distance metric (standard value: 2, i.e. Euclidean) the general distance between points xi and xj (i,j = 1..numberOfPoints) is: (∑k=1..numberOfDimensions |xik –xjk|metric)1/metric Sort distances determines the handling of ties in the data. When off, whenever two or more dissimilarities are equal we do not care whether the fitted distances are equal or not. Consequently, no constraints are imposed on the fitted distances. When on, however, we impose the constaint that the fitted distances be equal whenever the dissimilarities are equal. For the calculation of stress: Formula1 (default) stress = √(∑(distancek – fittedDistancek)2 / ∑ distancek2) Formula2 stress = √(∑(distancek – fittedDistancek)2 / ∑ (distancek – averageDistance)2) Note that values of stress 2 are generally more than double those of stress 1 for the same degree of fit. Finding the optimal Configuration involves a minimization process: Tolerance When successive values for the stress differ less than Tolerance the minimization process stops. Maximum number of iterations Minimization stops after this number of iterations has been reached. Number of repetitions When chosen larger than 1, the minimalization process will be repeated, each time with another random start configuration. The configuration that results in minimum stress will be saved. Precautions When there are few objects it is impossible to recover many dimensions. A rough rule of thumb is that there should be at least twice as many number of observations, i.e. the numberOfPoints · (numberOfPoints - 1) / 2 (dis)similarities, than parameters to be estimated, i.e. the numberOfPoints · numberOfDimensions position coordinates. A practical guide is: for numberOfDimensions = 1 you need ≥ 5 objects for numberOfDimensions = 2 you need ≥ 9 objects for numberOfDimensions = 3 you need ≥ 13 objects There is no feasible way to be certain that you have found the true global minimum. However, by using a great number of different random starting configurations to scale the same data it is often possible to obtain practical certainty. Although the procedure for obtaining an initial configuration is based on a linear relation between distance and (dis)similarity, it gives a very good approximation of the optimal Configuration and the Minimizer practically always finds the global minimum from it (I guess...). A way to find out is to try the numberOfRepetitions parameter which gives you the possibility to fit many times and each time start with another random initial configuration. Algorithm 1. The Dissimilarity object is converted to a Distance object in the same way as in Dissimilarity: To Distance....) 2. From the Distance object an initial Configuration is found by first transforming the Distance object to a matrix with scalar products of distances and subsequently solving for the first numberOfDimensions eigenvectors of this matrix. 3. A minimalization algorithm is started that tries to minimize a function. In this function: • 3.1 We normalize the current Configuration from the minimizer • 3.2 Calculate a new Distance object from the configuration • 3.3 Do a monotone regression of this Distance on the Dissimilarity. This results in a new Distance object. • 3.4 Calculate stress from this Distance and the Distance obtained from Dissimilarity. The optimization process is ccontrolledby a conjugate gradient minimization algorithm that tries to minimize the stress function. In Kruskal (1964), a steepest descent algorithm is used wwhichis less efficient. 
Dissimilarity__To_Configuration__monotone_mds____	Dissimilarity: To Configuration (monotone mds)... A command that creates a Configuration object from a Dissimilarity object. Dissimilarities δij and disparities d′ij are related by: d′ij ≤ d′kl if δij ≤ δkl Settings Number of dimensions determines the number of dimensions of the configuration. Primary or secondary approach to ties When dissimilarities are equal, i.e., δij = δkl, the primary approach imposes no conditions on the corresponding disparities d′ij and d′kl, while the secondary approach demands that also d′ij = d′kl. Finding the optimal Configuration involves a minimization process: Tolerance When successive values for the stress differ less than Tolerance the minimization process stops. Maximum number of iterations Minimization stops after this number of iterations has been reached. Number of repetitions When chosen larger than 1, the minimalization process will be repeated, each time with another random start configuration. The configuration that results in minimum stress will be saved. Links to this page Dissimilarity & Configuration & Weight: To Configuration... Dissimilarity & Weight: To Configuration... Dissimilarity & Weight: To Configuration... Kruskal analysis Multidimensional scaling 
Dissimilarity__To_Configuration__ratio_mds____	Dissimilarity: To Configuration (ratio mds)... A command that creates a Configuration object from a Dissimilarity object. The disparities d′ij will be obtained from dissimilarities δij according to: d′ij = b · δij Links to this page Dissimilarity & Configuration & Weight: To Configuration... Dissimilarity & Weight: To Configuration... Dissimilarity & Weight: To Configuration... 
Dissimilarity__To_Distance___	Dissimilarity: To Distance... A command that creates a Distance object from a selected Dissimilarity object. Settings Scale when on, the additiveConstant is determined, when off the additiveConstant = 0. dissimilarities are transformed to distances according to: distanceij = dissimilarityij + additiveConstant. Links to this page Create INDSCAL Carroll & Wish example... Dissimilarity: To Configuration (kruskal)... INDSCAL analysis Multidimensional scaling 
Dissimilarity__To_Weight	Dissimilarity: To Weight Creates an object of type Weight for each selected Dissimilarity object. The values in the weight matrix will be: wii = 0 wij = 1 if δij > 0 Links to this page Multidimensional scaling 
Distance	Distance One of the types of objects in PRAAT. An object of type Distance represents distances between objects in a metrical space. Creation Confusion: To Dissimilarity (pdf)... Dissimilarity: To Distance... Links to this page Configuration: To Distance Distance & Configuration & Salience: Get VAF... Distance & Configuration & Salience: To Configuration (indscal)... Distance & Configuration: Get VAF... Distance & Configuration: To Configuration (indscal)... Distance: To Configuration (indscal)... Distance: To Configuration (ytl)... Distance: To ScalarProduct... INDSCAL analysis Multidimensional scaling 
Distance___Configuration___Salience__Get_VAF___	Distance & Configuration & Salience: Get VAF... Calculates the variance accounted for from the selected collection of Distance objects, the selected Configuration and the selected Salience. 
Distance___Configuration___Salience__To_Configuration__	Distance & Configuration & Salience: To Configuration (indscal)... A command that creates a new Configuration from the selected collection of Distance objects, the selected Configuration and the selected Salience. The selected Configuration and Salience serve as start values for the INDSCAL analysis. 
Distance___Configuration__Draw_scatter_diagram___	Distance & Configuration: Draw scatter diagram... 
Distance___Configuration__Get_VAF___	Distance & Configuration: Get VAF... Calculates the variance accounted for from the selected collection of Distance objects and the selected Configuration. The optimal Salience necessary for the calculation will be inferred from the selected Distance and Configuration objects. 
Distance___Configuration__To_Configuration__indscal____	Distance & Configuration: To Configuration (indscal)... Performs an INDSCAL analysis on the selected objects of type Distance and calculates a Configuration from them. Uses the selected Configuration object as the initial Configuration in the iteration process. 
Distance__To_Configuration__indscal____	Distance: To Configuration (indscal)... Perform an INDSCAL analysis on the selected object(s) of type Distance that results in a Configuration and a Salience object. Links to this page Create INDSCAL Carroll & Wish example... 
Distance__To_Configuration__ytl____	Distance: To Configuration (ytl)... A command that creates one Configuration and one Salience object from a collection of one or more Distance objects. This Configuration and Salience object normally serve as starting points for an individual difference scaling such as an INDSCAL analysis. The algorithm is ddescribedin Young, Takane & Lewyckyj (1978). 
Distance__To_ScalarProduct___	Distance: To ScalarProduct... A command that creates a ScalarProduct for each selected Distance. Setting Make sum of squares equal 1.0 when selected, the elements in the resulting matrix part will be scaled such that the sum of all the squared elements in the matrix equals 1.0. Algorithm ScalarProduct entries bij are created from distances dij bij double centering the matrix with elements –1/2 dij2, i.e., bij= –1/2(dij2 – d·j2 – di·2 + d··2), where the dot (·) means averaging over that dimension. 
Distributions	Distributions One of the types of objects in Praat. Inherits most actions from TableOfReal. Actions Distributions: To Strings... Links to this page OT learning 2.9. Output distributions OT learning 7. Learning from overt forms OTGrammar: Input to outputs... OTGrammar: To output Distributions... Strings: To Distributions 
Distributions__To_Strings___	Distributions: To Strings... A command to create a Strings object from every selected Distributions object. Settings Column number the column (in the Distributions object) that contains the distribution that you are interested in. Often the Distributions object will only contain a single distribution, so this argument will often be 1. If the Distributions object contains nine distributions, specify any number between 1 and 9. Number of strings the number of times a string will be drawn from the chosen distribution. This is the number of strings that the resulting Strings object is going to contain. Behaviour Every string in the resulting Strings object will be a row label of the Distributions object. The number in each row at the specified column will be considered the relative frequency of occurrence of that row. Example. Suppose we have the following Distributions: File type = ooTextFile Object class = Distributions 2 (number of columns) English French (column labels) 3 (number of rows) the 108 1.5 a 58.1 33 pour 0.7 15.5 If you set Column to 1 and Number of strings to 1000, you will get a Strings object with approximately 647 occurrences of the, 348 occurrences of a, and 4 occurrences of pour. If you had set Column to 2 (French), you would have gotten about 30 times the, 660 times a, and 310 times pour. The actual numbers will vary because the choice of a string will not depend on previous choices. Links to this page OT learning 7. Learning from overt forms 
Drag	Drag Dragging is one of the ways to control Editors. How to drag 1. Position the mouse above the object that you want to drag. 2. Press the (left) mouse button. 3. Keeping the mouse button pressed, move the mouse across the window. A shadow of the object will follow. 4. Release the mouse button when it is above the location where you want your object to be moved (the drop site). If the drop site makes any sense, the object will move there. See also Shift-drag. Usage in the Praat program Dragging is used for manipulating the time and value of one or more marks, targets, or boundaries: ManipulationEditor TextGridEditor time selection 
Draw_inner_box	Draw inner box One of the commands in the Margins menu of the Picture window. Purpose To draw a rectangle inside the drawing area, leaving margins on all four sides for drawing text and marks. Behaviour The widths of the margins depend on the current font size. Links to this page Pen menu 
Draw_menu	Draw menu A menu that occurs in the Dynamic menu for many objects. This menu contains commands for drawing the object to the Picture window, which will allow you to print the drawing or to copy it to your word processor. Links to this page Intro 4.5. The Pitch object Intro 5.4. The Formant object 
DTW	DTW One of the types of objects in PRAAT. An object of type DTW represents the dynamic time warp structure of two objects. Commands Creation: CC: To DTW... (from 2 objects with cepstral coefficients) Spectrogram: To DTW... (from 2 Spectrogram objects) Query: DTW: Get y time from x time... DTW: Get x time from y time... Links to this page DTW & Sounds: Draw warp (x)... DTW & Sounds: Draw... DTW & TextGrid: To TextGrid (warp times) DTW: Find path (band & slope)... DTW: Get distance (weighted) DTW: Get maximum consecutive steps... DTW: Get time along path... DTW: Swap axes DTW: To Polygon... What was new in 3.9? 
DTW___Sounds__Draw___	DTW & Sounds: Draw... Draws the distances, the path and the sounds for the selected DTW and the two selected Sounds. 
DTW___Sounds__Draw_warp__x____	DTW & Sounds: Draw warp (x)... Draws the warp given a time on the x-direction for the selected DTW and the two selected Sounds. 
DTW___TextGrid__To_TextGrid__warp_times_	DTW & TextGrid: To TextGrid (warp times) Create a new TextGrid from the selected DTW and TextGrid by warping the times from the selected TextGrid to the newly created TextGrid. Algorithm First we check whether the y-domain of the DTW and the domain of the TextGrid are equal. If they are, a new TextGrid is created by copying the selected one. We then change its domain and make it equal to the x-domain of the DTW. Then for each tier we change the domain and calculate new times by using the path. Links to this page What was new in 5.2? 
DTW__Draw_warp__x____	DTW: Draw warp (x)... Draws the warp given a time on the x-direction 
DTW__Find_path__band___slope____	DTW: Find path (band & slope)... Finds the optimal path for the selected DTW that lies within the union of the sakoe-chiba band and local slope limits. Settings Sakoe-Chiba band (s), The maximum distance from the start/end of the sound where a path may start/finish. Slope constraint, determines the maximum and minimum local slopes in the optimal path. For example, the constraint 1/3 < slope < 3 forces the path locally after having taken three steps in the same direction direction to take the next step in the other direction, or after having taken two steps in the same direction to take the next step in the diagonal direction. At the same time the global consequences of the 1/3 < slope < 3 constraint mandates that the durations of the two domains do not differ by more than a factor of three. For more information see the article of Sakoe & Chiba (1978). 
DTW__Get_distance__weighted_	DTW: Get distance (weighted) Queries the selected DTW object for the weighted distance along the minimum path. Algorithm If the distance matrix has nx cells along the x-direction, ny cells along the y-direction and the sum of the distances along the minimum path is S, the weighted distance is given by S/(nx+ny). 
DTW__Get_maximum_consecutive_steps___	DTW: Get maximum consecutive steps... Get the maximum number of consecutive steps in the chosen direction along the optimal path from the selected DTW. 
DTW__Get_time_along_path___	DTW: Get time along path... Queries the selected DTW object for the time along the minimal path given the time along the x-direction. This command is deprecated, the new commands for querying are DTW: Get y time from x time... and DTW: Get x time from y time.... Setting Time (s) the time along the x-direction. Behaviour When the input time is in the interval [xmin, xmax], the returned time will be in the interval [ymin, ymax], where [xmin, xmax] and [ymin, ymax] are the domains of the two objects from which the DTW-object was constructed.For all other input times we assume that the two object are aligned. We like to have a continuous interpretation of time for the quantized times in the x and y direction; we make the path piecewise linear. There are two special cases: 1. The local path is horizontal. We calculate the y-time from the line that connects the lower-left position of the leftmost horizontal time block to the upper-right position of the rightmost horizontal time block. 2. The local path is vertical. We calculate the y-time from the line that connects the lower-left position of the bottommost vertical time block to the upper-right position of the topmost horizontal time block. 
DTW__Get_x_time_from_y_time___	DTW: Get x time from y time... Queries the selected DTW object for the time along the x-direction given the time along the y-direction. Setting Time (s) the time along the y-direction. Behaviour The behaviour is like DTW: Get y time from x time... Links to this page DTW & TextGrid: To TextGrid (warp times) DTW: Get time along path... 
DTW__Get_y_time_from_x_time___	DTW: Get y time from x time... Queries the selected DTW object for the time along the y-direction given the time along the x-direction. Setting Time (s) the time along the x-direction. Behaviour When the input time is in the interval [xmin, xmax], the returned time will be in the interval [ymin, ymax], where [xmin, xmax] and [ymin, ymax] are the domains of the two objects from which the DTW-object was constructed.For input times outside the domain we assume that the two object were aligned. We like to have a continuous interpretation of time for the quantized times in the x and y direction; we make the path a piecewise linear monotonically increasing function. There are special cases: 1. The local path is in the x-direction only. We calculate the y-time from the line that connects the lower-left position of the begin cell of this path to the upper-right position of the last cell. 2. The local path is in the x-direction only. We calculate the y-time from the line that connects the lower-left position of lowest cell to the upper-right position of the highest cell. 3. A cell is both part of a path in the x- and the y-direction. We then calculate the intersection point of the paths in the x- and the y-directions. The y-times in this cell are now calculated from the two line segments that originate from this intersection point. Links to this page DTW: Get time along path... DTW: Get x time from y time... 
DTW__Swap_axes	DTW: Swap axes Swap the x and y-axes of the selected DTW. 
DTW__To_Polygon___	DTW: To Polygon... A command to convert for a selected DTW the Sakoe-Chiba band and the local slope constraint to a Polygon object. The polygon will show the boundaries of the search domain for the optimal path. 
DurationTier	DurationTier One of the types of objects in Praat. A DurationTier object contains a number of (time, duration) points, where duration is to be interpreted as a relative duration (e.g. the duration of a manipulated sound as compared to the duration of the original). For instance, if your DurationTier contains two points, one with a duration value of 1.5 at a time of 0.5 seconds and one with a duration value of 0.6 at a time of 1.1 seconds, this is to be interpreted as a relative duration of 1.5 (i.e. a slowing down) for all original times before 0.5 seconds, a relative duration of 0.6 (i.e. a speeding up) for all original times after 1.1 seconds, and a linear interpolation between 0.5 and 1.1 seconds (e.g. a relative duration of 1.2 at 0.7 seconds, and of 0.9 at 0.9 seconds). See Intro 8.2. Manipulation of duration and Create DurationTier.... Links to this page constant extrapolation DurationTier: Add point... DurationTier: Get target duration... DurationTierEditor Get area... Get high index from time... Get low index from time... Get nearest index from time... linear interpolation Manipulation Manipulation: Extract duration tier Manipulation: Replace duration tier ManipulationEditor Remove point near... Remove point... Remove points between... time domain What was new in 3.7? 
DurationTier__Add_point___	DurationTier: Add point... A command to add a point to each selected DurationTier. For an example, see Create DurationTier.... Settings Time (s) the time at which a point is to be added. Relative duration the relative duration value of the requested new point. Behaviour The tier is modified so that it contains the new point. If a point at the specified time was already present in the tier, nothing happens. 
DurationTier__Get_target_duration___	DurationTier: Get target duration... A query to the selected DurationTier for the target duration of a specified time range. Settings From time (s) To time (s) the start and end of the (original) time range. Return value the target duration in seconds. 
DurationTierEditor	DurationTierEditor One of the editors in the Praat program, for viewing and editing a DurationTier object. To create a DurationTierEditor window, select a DurationTier and click View & Edit. 
Dynamic_menu	Dynamic menu A column of buttons in the right-hand part of the Object window, plus the Save menu in the Object window. If you select one or more objects in the list, the possible actions that you can perform with the selected objects will appear in the dynamic menu. These actions can include viewing & editing, saving, drawing, conversions to other types (including analysis and synthesis), and more. Example of analysis: Record a Sound, select it, and click on To Pitch.... This will create a new Pitch object and put it in the list of objects. You can then edit, write, and draw this Pitch object. Example of synthesis: Create a Speaker, create and edit an Artword, and click on To Sound.... Links to this page Action commands Draw menu Editors Formants & LPC menu History mechanism Intro 2. What to do with a sound Intro 3.5. The Spectrogram object List of Objects Modify Periodicity menu Scripting 7. Scripting the editors View & Edit 
EditCostsTable	EditCostsTable One of the types of objects in Praat. The EditCostsTable determines the string edit costs, i.e. the costs involved in changing one string of symbols (the source) into another one (the target). String edit costs are generally divided into insertion, deletion and substitution costs. The latter terms refer to the operations that may be performed on a source string to transform it to a target string. For example, to change the source string execution to the target string intention we would need one insertion (i), one deletion (d) and three substitutions (s) as the following figure shows. The figure above was produced with default values for the costs, i.e. the insertion and deletion costs were 1.0 while the substitution cost was 2.0. The actual edit distance between the target and source strings is calculated by the EditDistanceTable which uses an EditCostsTable to access the specific string edit costs. The figure above was produced by the following commands: target = Create Strings as characters: intention source = Create Strings as characters: execution plusObject: target edt = To EditDistanceTable Draw edit operations The default EditCostsTable which is in every new EditDistanceTable object has only two rows and two columns, where the cells in this EditCostsTable have the following interpretation: Cell [1][2]: defines the cost for the insertion of a target symbol in the source string. The default insertion cost is 1.0. Cell [2][1]: defines the cost of the deletion of a source symbol. The default value is 1.0. Cell [1][1]: defines the cost of substituting a target symbol for a source symbol where the target and source symbols don't match. The default substitution cost is 2.0. Cell [2][2]: defines the cost of substituting a target symbol for a source symbol where the target and source symbols do match. The deault value is 0.0. How to create a non-default EditCostsTable In general we can define a table for numberOfTargets target symbols and numberOfSources source symbols. These numbers do not necessarily have to be equal to the number of different symbols that may occur in the target and source strings. They only represent the number of symbols that you like to give special edit costs. The EditCostTable will provide one extra dimension to accommodate target symbol insertion costs and source symbol deletion costs and another extra dimension to represent other target and source symbols that don't have separate entries and can therefore be treated as one group. The actual dimension of the table will therefore be (numberOfTargets + 2) × (numberOfSources + 2). This is what the cells in the non-default table mean: The upper matrix part of dimension numberOfTargets × numberOfSources will show at cell [i][j] the costs of substituting the i-th target symbol for the j-th source symbol. The first numberOfSources values in row (numberOfTargets + 1) represent the costs of substituting one of the target symbols from the target rest category for the source symbol in the corresponding column. The target rest category is the group of targets that do not belong to the numberOfTargets targets represented in the upper part of the matrix. The first numberOfTargets values in the column (numberOfSources + 1) represent the costs of substituting the target symbol in the corresponding row for one of the source symbols from the source rest category. The source rest category is the group of source symbols that do not belong to the numberOfSources source symbols represented in the upper part of the matrix. The first numberOfSources cells in the last row represent the deletion cost of the corresponding source symbols. The first numberOfTargets cells in the last column represent the insertion costs of the corresponding target symbols. Finally the four numbers in the cells at the bottom-right corner have an interpretation analogous to the four numbers in the basic EditCostTable we discussed above (but now for the rest symbols). Example If we extend the basic table with one extra target and one extra source symbol, then the EditCostTable will be a 3 by 3 table. The numbers in the following table have been chosen to be distinctive and therefore probably will not correspond to any practical situation. s t 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 0.0 By issuing the following series of commands this particular table can be created: Create empty EditCostsTable: editCosts, 1, 1 Set target symbol (index): 1, t Set source symbol (index): 1, s Set insertion costs: t, 1.3 Set deletion costs: s, 1.7 Set substitution costs: t, s, 1.1 Set substitution costs: , s, 1.4 Set substitution costs: t, , 1.2 Set costs (others): 1.6, 1.8, 0, 1.5 In the first line we create the (empty) table, we name it editCosts and it creates space for one target and one source symbol. The next line defines the target symbol which becomes the label of the first row of the table. Line 3 defines the source symbol which will become the label of the first column of the table. We next define the insertion and deletion costs, they fill cells [1][3] and [3][1], respectively. Cell [1][1] is filled by the command in line 6. The command in line 7 fills cell [2][1] which defines the cost of substituting any target symbol unequal to t for s. The next line fills cell [1][2] which defines the substitution costs of t for any source symbol unequal to s. Finally, the command in the last line defines the little 2×2 matrix at the bottom-right that is analogous to the default cost matrix explained above. Therefore cell [2][2] defines the cost of substituting a target symbol unequal to t for a source symbol unequal to s where the target and source symbols don't match, while cell [3][3] defines the costs when they do match. Cell [3][2] defines the cost of the deletion of a source symbol unequal s, while cell [2][3] defines the cost for the insertion of a target symbol unequal t in the source string. How to use a special EditCostsTable After creating the special EditCostsTable you select it together with the EditDistanceTable and issue the command Set new edit costs. The EditDistanceTable will then find the minimum edit distance based on the new cost values. Links to this page Create empty EditCostsTable... 
EditDistanceTable	EditDistanceTable One of the types of objects in Praat. An EditDistanceTable shows the accumulated distances between a target string and a source string. For example, the accumulated distances between the target string intention and the source string execution can be expressed by the following EditDistanceTable: This figure was created by issuing the following commands: target = Create Strings as characters: intention source = Create Strings as characters: execution plusObject: target edt = To EditDistanceTable Draw: decimal, 1, 0 The target string is always displayed vertically while the source string is displayed horizontally and the origin is at the bottom-left corner of the table. Each cell of this table, dist[i, j], contains the accumulated distance between the first i characters of the target and the first j characters of the source. The cells on the path through this table which have the minimum accumulated cost are shown with boxes around them. Below we will explain how this path is calculated. The local directional steps in this path show which edit operations we have to perform on the source string symbols to obtain the target string symbols. Three edit operations exist: (1) insertion of a target symbol in the source string. This happens each time we take a step in the vertical direction along the path. (2) deletion of a symbol in the source string. This happens each time we take a step in horizontal direction along the path. (3) substitution of a source symbol by a target symbol happens at each diagonal step along the path. If we trace the path from its start at the origin to its end, we see that it first moves up, indicating the insertion of an i symbol in the source string. In the next step which is in the diagonal direction, the n target is substituted for the e source symbol. Next follows another substitution, t for x. The next diagonal step substitutes e for an identical e. This step is followed by a horizontal step in which the source symbol c is deleted. The next diagonal step substitutes an n for a u. The path now continues in the diagonal direction until the end point and only identical substitutions occur in the last part. The following figure shows these operations more explicitly. The value of the accumulated costs in a cell of the table is computed by taking the minimum of the accumulated distances from three possible paths that end in the current cell, i.e. the paths that come from the left, from the diagonal and from below. dist[i,j] = min (dleft, ddiag, dbelow), where dleft = dist[i-1,j] + insertionCost(target[i]) ddiag = dist[i-1,j-1] + substitutionCost(source[j],target[i]) dbelow = dist[i,j-1] + deletionCost(source[j]) Since the calculation is recursive we start at the origin. After calculating the accumulative distances for each cell in the table as based on the algorithm above, the cell at the top-right position will contain the accumulated edit distance. This distance happens to be 8 for the given example. The value 8 results from using the target-indepent value of 1.0 for the insertion cost, the source-independent value of 1.0 for the deletion costs and a constant value of 2.0 for the substitution costs. If target and source symbol happen to be equal no costs are assigned, or, equivalently the substitution costs are zero if target and source symbol match. If you want more control over these costs you can create an EditCostsTable and specify your special costs and then set the new edit costs. If during the calculations we also keep track of which of the three cells resulted in the local minimum accumulated distance, we can use this directional information to backtrack from the cell at the top-right position to the cell at the bottom-right position and obtain the minimum path. 
EditDistanceTable___EditCostsTable__Set_new_edit_costs	EditDistanceTable & EditCostsTable: Set new edit costs A command available in the dynamic menu if an EditDistanceTable and an EditCostsTable are chosen together. New accumulated cost values will be calculated and a new path based on these values will be calculated. 
Editors	Editors Many types of objects in Praat can be viewed and edited in their own windows. Editor windows • SoundEditor • LongSoundEditor • TextGridEditor • ManipulationEditor • SpectrumEditor • PitchEditor • PointEditor • PitchTierEditor • IntensityTierEditor • DurationTierEditor • SpectrogramEditor • ArtwordEditor • OTGrammarEditor • (any type: Inspect) How to open an editor for an object To open an editor window for an object in the list, select the object and choose View & Edit (if the View & Edit button exists, it is usually at the top of the Dynamic menu). The name of the object will appear as the title of the editor window. Objects that cannot be modified (e.g. LongSound) just have the command View instead of View & Edit. General behaviour Changes that you make to an object in its editor window will take effect immediately. For instance, you do not have close the editor window before saving the changed object to disk. If you Remove an object that you are viewing or editing from the List of Objects, the editor window will automatically disappear from the screen. All editors are independent windows: you can minimize and maximize them; if an editor window goes hiding behind another window, you can raise it by choosing the View & Edit command again. If you rename an object that you are viewing or editing (with Rename...), the title of the editor window immediately changes to the new name. Ways to control an editor window • Click • Shift-click • Drag • Shift-drag • Time selection • Keyboard shortcuts Links to this page File menu Query Query menu View View & Edit 
EEG	EEG EEG means electro-encephalography: brain potentials recorded via e.g. 32 or 64 electrodes on the scalp. In Praat, an EEG object looks like a combination of a Sound object with e.g. 32 or 64 channels and a TextGrid object that marks the events. 1. How to get an EEG object in Praat You typically create an EEG object in Praat by opening a BDF/EDF file with Read from file.... Praat tries to read the whole file into memory, so you may want to work with a 64-bit edition of Praat if you want to avoid out of memory messages. After you do Read from file..., an EEG object will appear in the list of objects. 2. How to look into an EEG object Once you have an EEG object in the list, you can click View & Edit to look into it. You will typically see the first 8 channels, but you scroll to the other channels by clicking on the up and down arrows. You can scroll and zoom in the same way as in a Sound window. The channel names that you see are often A1, A2, ... A32, B1, B2, ... B32, C1, C2, ... C32, and so on. These represent the cap electrodes. If the number of cap electrodes is 32, though, the channel names are Fp1, AF3, ... Cz, and if it is 64, the channel names are Fp1, AF7, ... O2. You can change these names with Set channel name... from the Modify menu. Below the cap electrodes you may see a number of channels for the external electrodes. These are typically named EXG1, EXG2, ... EXG8, but you can change these names with Edit external electrode names... from the Modify menu. Below the external electrodes you may see a number of special channels, perhaps named GSR1, GSR2, Erg1, Erg2, Resp, Plet, Temp, and Status. These represent recordings from other sensors than the electrodes. The Status channel is special. It is the 8-bit digital signal that you fed to your EEG apparatus. When reading the BDF file, Praat extracts all 8 bits from this status signal, and these 8 bits are shown in the EEG window as TextGrid interval tiers named S1, S2, ... S8. These bits are the place to mark events. For instance, in our lab we use S8 to mark any event, S5 to mark a standard event, and S4 to mark a deviant event. 3. What to do to an EEG object The raw EEG signal that you have read from a file is typically quite noisy and may have a very large DC (direct-current) component as compared to the small vibrations that you are interested in. There are several ways to clean it up. Subtracting a reference signal. The voltage on the whole scalp may rise and fall in time. You are unlikely to be interested in these global movements; instead, you are likely to be interested only in the voltage movements on the brain-influenced part of the scalp (the cap electrodes) with respect to the voltage movements on the non-brain-influenced part of the scalp (the external electrodes). If you have external electrode recordings that include the left and right mastoids, you can use these channels as a reference signal, i.e., you can use Subtract reference... to subtract the average of the two mastoid channels from all electrode channels (including the external electrodes themselves). If you have no such recordings, you can still regard the average of a range of electrode channels as a reference signal, and use Subtract mean channel... to subtract this from each electrode channel. Detrending. With Detrend, you subtract from each electrode channel a line in such a way that the first sample and the last sample become zero. Detrending and reference subtraction can be performed in either order. Filtering. With Filter..., you band-pass filter each electrode channel. Filtering has to be done after detrending, but filtering and reference subtraction can be performed in either order. 4. How to do an ERP analysis An ERP is an Event-Related Potential. Events are marked somewhere in S1, S2, ... S8. In the above example, we extract all the deviant events by doing To ERPTier..., setting From time to -0.11 seconds, To Time to 0.39 seconds, and Marker bit to 4. This way, an ERPTier object appears in the list, containing the parts of the EEG signal that lie in a time window of [-0.11, 0.39] seconds around each event on the S4 (deviant) tier. Thus, if S4 contains 150 events, the resulting ERPTier will contain 150 pieces of the original EEG signal (without the extra sensors). You are typically interested in the part of each ERP in the ERPTier after the event. That is, you are probably interested in how this part compares to the part not influenced by the event, i.e. the part before the event. To make this comparison easier, you can do Subtract baseline...: the waveform of the ERP will be moved up or down in such a way that the average amplitude of the part between the specified times becomes zero; the times you will typically fill in here are the starting time of the ERP (a negative number) and the time of the event (0.0). After you subtract the baseline, the part after the event contains the interesting part of the ERP: even its sign (positive or negative) is meaningful now. Some ERPs, however, will contain very large positive or negative peaks because of eye movements and other disturbing signals. To remove those ERPs from the ERPTier, do Reject artefacts..., while specifying the amount by which you allow the amplitude of an ERP to go above or below zero. Once you have an ERPTier, you can extract each of the 150 ERPs from it with Extract ERP.... It is perhaps more interesting to compute the average of all those 150 ERPs with To ERP (mean). These commands put a new ERP object in the list. Once you have an ERP object, you can look into it with View & Edit. If you want to see in the ERP window the scalp distribution at the time of the cursor, or the average scalp distribution in the selected time stretch, you have to switch on Show selection viewer in the Preferences window (available from the File menu). Links to this page What's new? 
Efron___Tibshirani__1993_	Efron & Tibshirani (1993) B. Efron & R.J. Tibshirani (1993): An introduction to the bootstrap. Chapman & Hall. Links to this page Bootstrap 
Eigen	Eigen One of the types of objects in Praat. An object of type Eigen represents the eigen structure of a matrix whose eigenvalues and eigenvectors are real. Inside an Eigen With Inspect you will see the following attributes: numberOfEigenvalues the number of eigenvalues and eigenvectors dimension the dimension of an eigenvector. eigenvalues[1..numberOfEigenvalues] the real eigenvalues. eigenvectors[1..numberOfEigenvalues][1..dimension] the real eigenvectors, stored by row. Links to this page Eigen & Matrix: Project... Eigen & SSCP: Project Eigen & TableOfReal: Project... Eigen: Draw eigenvalues... Eigen: Draw eigenvector... Eigen: Get contribution of component... Eigen: Get cumulative contribution of components... Eigen: Get eigenvalue... Eigen: Get eigenvector element... FFNet: Principal components PCA 
Eigen___Matrix__Project___	Eigen & Matrix: Project... A command to project the columns of the Matrix object onto the eigenspace of the Eigen object. Setting Number of dimensions defines the dimension, i.e., the number of rows, of the resulting object. Algorithm Project each column of the Matrix on the coordinate system given by the eigenvectors of the Eigen object. This can be done as follows: yji = Σk=1..numberOfColums ejk xki, where yji is the j-th element of the i-th column of the resulting (matrix) object, ejk is the k-th element of the j-th eigenvector and, xki is the k-th element of the i-th column of the selected matrix object. 
Eigen___SSCP__Project	Eigen & SSCP: Project A command to project the SSCP object onto the eigenspace of the Eigen object. Behaviour Transform the SSCP object as if it was calculated in a coordinate system given by the eigenvectors of the Eigen object. This can be done as follows: St = E′ S E, where where E′ is the transpose of the matrix with eigenvectors E, S is the square matrix with sums of squares and crossproducts, and St the newly created square matrix. The dimension of St may be smaller than the dimension of S. Links to this page Discriminant & SSCP: Project PCA & Covariance: Project PCA & SSCP: Project 
Eigen___TableOfReal__Project___	Eigen & TableOfReal: Project... A command to project the rows of the TableOfReal object onto the eigenspace of the Eigen object. Setting Number of dimensions defines the number of dimensions, i.e., the number of columns, of the resulting object. Algorithm Project each row of the TableOfReal on the coordinate system given by the eigenvectors of the Eigen object. This can be done as follows: yij = Σk=1..numberOfColums ejk xik, where ejk is the k-th element of the j-th eigenvector, xik is the k-th element of the i-th row and yij is the j-th element at the i-th row of the matrix part of the resulting object. Links to this page Discriminant & TableOfReal: To Configuration... PCA & TableOfReal: To Configuration... 
Eigen__Draw_eigenvalues___	Eigen: Draw eigenvalues... A command to draw the eigenvalues of the selected Eigen object(s). Settings Fraction of eigenvalues summed defines whether or not fractions are plotted. Fractions fi will be calculated for each number ei by dividing this number by the sum of all numbers ej: fi = ei / ∑j=1..numberOfEigenvalues ej. Cumulative defines whether or not cumulative values are plotted. Cumulative values ci will be calculated for each number ei by summing the first i numbers ej: ci = ∑j=1..i ej). A scree plot can be obtained if both Fraction of eigenvalues summed and Cumulative are unchecked. Links to this page Principal component analysis 
Eigen__Draw_eigenvector___	Eigen: Draw eigenvector... A command to draw an eigenvector from the selected Eigen. Settings Eigenvector number determines the eigenvector to be drawn. Component loadings when on, the eigenvector is multiplied with the square root of the corresponding eigenvalue. (For PCA-analysis this means that you will draw the so called component loading vector. You will be able to compare quantitatively the elements in different component loading vectors because the i-th element in the j-th component loading vector gives the covariance between the i-th original variable and the j-th principal component.) Element rang determine the first and last element of the vector that must be drawn. Minimum and Maximum determine the lower and upper bounds of the plot (choosing Maximum smaller than Minimum will draw the inverted eigenvector). Mark size, Mark string determine size and type of the marks that will be drawn. Garnish determines whether a bounding box and margins will be drawn. 
Eigen__Get_contribution_of_component___	Eigen: Get contribution of component... A command to ask the selected Eigen for the contribution of the jth eigenvalue to the total sum of eigenvalues. Details The contribution is defined as: eigenvalue[j] / Σi=1..numberOfEigenvalues eigenvalue[i] 
Eigen__Get_cumulative_contribution_of_components___	Eigen: Get cumulative contribution of components... A command to ask the selected Eigen for the contribution of the sum of the eigenvalues[from..to] to the total sum of eigenvalues. Details The contribution is defined as: Σi=from..to eigenvalue[i] / Σi=1..numberOfEigenvalues eigenvalue[i] 
Eigen__Get_eigenvalue___	Eigen: Get eigenvalue... A command to query the selected Eigen for the ith eigenvalue. 
Eigen__Get_eigenvector_element___	Eigen: Get eigenvector element... A command to query the selected Eigen for the jth element of the ith eigenvector. 
Encapsulated_PostScript	Encapsulated PostScript a kind of PostScript file that can easily be imported into word processors and drawing programs. In Praat, you can create an Encapsulated PostScript (EPS) file by choosing Save as EPS file.... Links to this page PostScript settings... Read from Praat picture file... 
end_time	end time - the end of the time domain (see there). 
epoch	epoch A term that is often used in the context of machine learning. An epoch is one complete presentation of the data set to be learned to a learning machine. Learning machines like feedforward neural nets that use iterative algorithms often need many epochs during their learning phase. A discriminant classifier is also a learning machine. However, in contrast with neural nets a discriminant classifier only needs one epoch to learn. Links to this page Feedforward neural networks 1.1. The learning phase 
equivalent_rectangular_bandwidth	equivalent rectangular bandwidth The equivalent rectangular bandwidth (ERB) of a filter is defined as the width of a rectangular filter whose height equals the peak gain of the filter and which passes the same total power as the filter (given a flat spectrum input such as white noise or an impulse). Links to this page Create Sound from gammatone... 
Erase_all	Erase all A command in the Edit menu of the Picture window. It erases all your drawings. 
Escudero___Boersma__2004_	Escudero & Boersma (2004) Paola Escudero & Paul Boersma (2004): Bridging the gap between L2 speech perception and phonological theory. Studies in Second Language Acquisition 26: 551–585. 
Espeak	Espeak Jonathan Duddington's Espeak speech synthesizer, available via http://espeak.sourceforge.net/ Links to this page Create SpeechSynthesizer... Kirshenbaum phonetic encoding SpeechSynthesizer 
Euclidean_distance	Euclidean distance The Euclidean distance between the n-dimensional vectors a and b can be calculated as follows: ΔEuclidean(x,y) = √(∑i=1..n(ai - bI)2) Links to this page kNN classifiers 1. What is a kNN classifier? Pattern & FeatureWeights: To Dissimilarity... Pattern to Dissimilarity Pattern: To Dissimilarity... 
Excitation	Excitation One of the types of objects in Praat. It represents the excitation pattern of the basilar membrane in the inner ear. Inside an Excitation object With Inspect, you will see the following attributes. xmin = 0 minimum place or frequency (Bark). xmax = 25.6 Bark maximum place or frequency (Bark). nx number of places or frequencies. dx = 25.6 / nx Place or frequency step (Bark). x1 = dx / 2 centre of first place or frequency band (Bark). ymin = ymax = dy = y1 = 1; ny = 1 dummies. z [1] intensity (sensation level) in phon. Links to this page Cochleagram Excitation: Formula... Excitation: Get loudness Excitations Excitations: To Pattern... Formulas 1.8. Formulas for modification Formulas 7. Attributes of objects 
Excitation__Formula___	Excitation: Formula... A command for changing the data in all selected Excitation objects. See the Formulas tutorial for examples and explanations. 
Excitation__Get_loudness	Excitation: Get loudness A query to ask the selected Excitation object for its loudness. Return value the loudness in sone units. Algorithm The loudness is defined as ∫df 2(e(f) - 40 phon) / 10 where f is the frequency in Bark, and e(f) the excitation in phon. For our discrete Excitation object, the loudness is computed as Δf ∑ 2(ei - 40) / 10 where Δf is the distance between the excitation channels (in Bark). Links to this page Sound: Get intensity (dB) 
Excitation_barkToHertz	Excitation_barkToHertz A routine for converting basilar place into frequency, the inverse of Excitation_hertzToBark. Syntax double Excitation_barkToHertz (double bark); Algorithm Returns 650 · sinh (bark / 7). 
Excitation_hertzToBark	Excitation_hertzToBark A routine for converting frequency into basilar place, the inverse of Excitation_barkToHertz. Syntax double Excitation_hertzToBark (double hertz); Algorithm Returns 7 · ln (hertz / 650 + √ (1 + (hertz / 650)2)). 
Excitations	Excitations A collection of objects of type Excitation. You can create an Excitations by selecting one or more Excitation's and selecting To Excitations. You can add one or more Excitation's to an Excitations by selecting one Excitations and one or more Excitation's and selecting Add to Excitations (the Excitation's will be removed from the list of objects). Links to this page Excitations: Append Excitations: To Pattern... Types of objects 
Excitations__Append	Excitations: Append You can choose this command after selecting two objects of type Excitations. A new object is created that contains the second object appended after the first. 
Excitations__To_Pattern___	Excitations: To Pattern... A command to convert every selected Excitations to a Pattern object. Setting Join the number of subsequent Excitation objects to combine into one row of Pattern. E.g. if an Excitation has length 26 and join = 2 then each row of Pattern contains 52 elements. The number of rows in Pattern will be my size / 2. In the conversion process the elements of an Excitation will be divided by 100.0 in order to guarantee that all patterns have values between 0 and 1. 
expectation-maximization	expectation-maximization Expectation-maximization (EM) is an iterative method used to find maximum likelihood estimates of parameters in probabilistic models, where the model depends on unobserved, also called latent, variables. EM alternates between performing an expectation (E) step, which computes an expectation of the likelihood by including the latent variables as if they were observed, and a maximization (M) step, which computes the maximum likelihood estimates of the parameters by maximizing the expected likelihood found in the E step. The parameters found on the M step are then used to start another E step, and the process is repeated until some criterion is satisfied. EM is frequently used for data clustering like for example in Gaussian mixtures or in the Baum-Welch training of a Hidden Markov Model. Links to this page GaussianMixture & TableOfReal: Improve likelihood... 
ExperimentMFC	ExperimentMFC One of the types of objects in Praat, for running a Multiple Forced Choice listening experiment. ExperimentMFC 1. When to use Praat ExperimentMFC 2. The first example ExperimentMFC 2.1. The experiment file ExperimentMFC 2.2. The stimuli ExperimentMFC 2.3. The carrier phrase ExperimentMFC 2.4. Breaks ExperimentMFC 2.5. Randomization strategies ExperimentMFC 2.6. Instructions ExperimentMFC 2.7. Response categories ExperimentMFC 2.8. Goodness judgments ExperimentMFC 2.9. How an experiment proceeds ExperimentMFC 3. More examples ExperimentMFC 3.1. A simple discrimination experiment ExperimentMFC 3.2. An AXB discrimination experiment ExperimentMFC 3.3. A 4I-oddity experiment ExperimentMFC 3.4. Variable inter-stimulus intervals ExperimentMFC 4. Special buttons ExperimentMFC 4.1. The replay button ExperimentMFC 4.2. The OK button ExperimentMFC 4.3. The oops button ExperimentMFC 5. Stimulus-dependent texts ExperimentMFC 5.1. The stimulus-dependent run text ExperimentMFC 5.2. Stimulus-dependent response buttons ExperimentMFC 6. Responses are sounds ExperimentMFC 7. Blanking the screen ExperimentMFC 8. Running multiple experiments Links to this page Acknowledgments Intro Strings & Permutation: Permute strings What was new in 4.0? What was new in 4.1? What was new in 4.4? What was new in 4.5? What was new in 5.0? What was new in 5.1? What was new in 5.3? 
ExperimentMFC_1__When_to_use_Praat	ExperimentMFC 1. When to use Praat With Praat's ExperimentMFC, you can do simple experiments on identification and discrimination. `Simple' means that for identification, the subject hears a sound and has to click on one of a set of labelled rectangles (optionally, you can have the subject give a goodness-of-fit judgment). For discrimination, you can have simple same-different choices, or more intricate things like AXB, 4I-oddity, and so on. The advantage of using Praat's ExperimentMFC for this is that it is free, it works on Windows, Unix, and Macintosh, and the whole experiment (experiment file plus sound files) is portable across computers (you can run it from a USB stick, for instance). Because of the limited possibilities, it is also quite easy to set up the experiment. Just read the description below. If you require more from your experiment design, you can use Praat's Demo window; with that less simple method you could for instance let the stimulus depend on the subject's previous responses. Alternatively, you could use a dedicated program like Presentation or E-prime instead of Praat; with these programs, you can also measure reaction times more accurately. Links to this page ExperimentMFC 
ExperimentMFC_2_1__The_experiment_file	ExperimentMFC 2.1. The experiment file An experiment is defined in a simple text file, which we call an experiment file. The following is an example of such an experiment file. The first two lines have to be typed exactly as in this example, the rest depends on your stimuli, on your response categories, and on the way the experiment is to be presented to the listener. The order of the elements in this file cannot be changed, and nothing can be skipped. ooTextFile ExperimentMFC 6 blankWhilePlaying? <no> stimuliAreSounds? <yes> stimulusFileNameHead = Sounds/ stimulusFileNameTail = .wav stimulusCarrierBefore = weSayTheWord stimulusCarrierAfter = again stimulusInitialSilenceDuration = 0.5 seconds stimulusMedialSilenceDuration = 0 stimulusFinalSilenceDuration = 0.5 seconds numberOfDifferentStimuli = 4 heed hid hood hud numberOfReplicationsPerStimulus = 3 breakAfterEvery = 0 randomize = <PermuteBalancedNoDoublets> startText = This is a listening experiment. After hearing a sound, choose the vowel that is most similar to what you heard. Click to start. runText = Choose the vowel that you heard. pauseText = You can have a short break if you like. Click to proceed. endText = The experiment has finished. maximumNumberOfReplays = 0 replayButton = 0 0 0 0 okButton = 0 0 0 0 oopsButton = 0 0 0 0 responsesAreSounds? <no> 0 0 0 numberOfDifferentResponses = 5 0.2 0.3 0.7 0.8 h I d 40 i 0.3 0.4 0.5 0.6 h E d 40 e 0.4 0.5 0.3 0.4 h A d 40 a 0.5 0.6 0.5 0.6 h O d 40 o 0.6 0.7 0.7 0.8 h U d 40 u numberOfGoodnessCategories = 5 0.25 0.35 0.10 0.20 1 (poor) 0.35 0.45 0.10 0.20 2 0.45 0.55 0.10 0.20 3 0.55 0.65 0.10 0.20 4 0.65 0.75 0.10 0.20 5 (good) This experiment will play 4 different stimuli to the listener, each 3 times. Thus, the listener is confronted with 12 trials. Links to this page ExperimentMFC ExperimentMFC 2. The first example ExperimentMFC 2.2. The stimuli ExperimentMFC 2.3. The carrier phrase ExperimentMFC 2.7. Response categories ExperimentMFC 2.8. Goodness judgments ExperimentMFC 3.1. A simple discrimination experiment ExperimentMFC 4.1. The replay button ExperimentMFC 4.2. The OK button ExperimentMFC 4.3. The oops button ExperimentMFC 5. Stimulus-dependent texts ExperimentMFC 5.1. The stimulus-dependent run text ExperimentMFC 5.2. Stimulus-dependent response buttons ExperimentMFC 6. Responses are sounds 
ExperimentMFC_2_2__The_stimuli	ExperimentMFC 2.2. The stimuli You can see that the example experiment contains four different stimuli: heed, hid, hood, and hud. These are the names of the four stimuli. Because in the example experiment stimuli are sounds, each of the four stimuli should be in a sound file. The names of these sound files must be identical to the names of the stimuli, bracketed with stimulusFileNamehead and stimulusFileNameTail. Hence, the stimuli are expected in the following four files: Sounds/heed.wav Sounds/hid.wav Sounds/hood.wav Sounds/hud.wav You need not use WAV files. You can also use AIFF files, in which case stimulusFileNameTail would probably be .aiff, or any other type of sound file that Praat supports. But all sound files must have the same number of channels (i.e. all mono or all stereo) and the same sampling frequency. In this example, the experiment will look for the sound files in the directory Sounds, which has to be in the same directory as your experiment file. In other words, Sounds/heed.wav is a relative file path. Instead of a relative path, you can also supply a full file path. Such a path depends on your computer and on your operating system. For instance, if you have a Windows computer and the stimuli are in the directory D:\Corpus\Autumn\Speaker23, you can write fileNameHead = D:\Corpus\Autumn\Speaker23\ If you have a Macintosh (OS X) or Unix computer and the stimuli are in /Users/mietta/Sounds/Dutch, you write fileNameHead = /Users/mietta/Sounds/Dutch/ But relative file paths will usually be preferred: they are more portable. The advantage of using relative file paths is that you can move your whole experiment (experiment file plus sounds) from one computer to another without changing the experiment file, as long as you put the experiment file in the same directory as where you put the directory Sounds. Or you can put the whole experiment on a USB stick and run the experiment directly from the stick. Since Praat supports the forward slash / as a directory separator on all computers, you can run the exact same experiment on Macintosh, Windows and Unix computers, independent of the type of computer where you have created your experiment. Links to this page ExperimentMFC ExperimentMFC 2. The first example 
ExperimentMFC_2_3__The_carrier_phrase	ExperimentMFC 2.3. The carrier phrase The stimuli can be embedded in a carrier phrase. In the example experiment, we see that the stimulus will be inserted between the sounds in the files weSayTheWord.wav and again.wav, both of which are expected to be in the directory Sounds. If you do not want a carrier phrase, you do stimulusCarrierBefore = stimulusCarrierAfter = If you want only an introductory phrase before the stimulus, and nothing after the stimulus, you do something like stimulusCarrierBefore = listenTo stimulusCarrierAfter = and of course you supply the file listenTo.wav in the directory Sounds. If you want to have a short silence before every stimulus (and before the carrier phrase), you supply a non-zero stimulusInitialSilenceDuration, as in the example. Since the carrier phrase is concatenated with the stimulus before it is played, it should have the same sampling frequency as the stimulus files. Links to this page ExperimentMFC ExperimentMFC 2. The first example 
ExperimentMFC_2_4__Breaks	ExperimentMFC 2.4. Breaks A new stimulus will arrive as soon as the listener makes her choice. To allow her some breathing time, you can insert a break after every so many trials. In the example, breakAfterEvery is 0, because there are only 12 trials. A typical experiment has perhaps 180 trials, and you may want to insert a break after every 40 trials. In that case, you do breakAfterEvery = 40 Links to this page ExperimentMFC ExperimentMFC 2. The first example 
ExperimentMFC_2_5__Randomization_strategies	ExperimentMFC 2.5. Randomization strategies The 3 times 4 stimuli will have to be played in a certain order. For the least random order, you say randomize = <CyclicNonRandom> In this case, the stimuli will be played in the order in which they were specified in the file, 3 times: heed hid hood hud heed hid hood hud heed hid hood hud The most likely case in which you would want to use this randomization strategy, is if you have, say, 120 different stimuli and you want to play them only once (numberOfReplicationsPerStimulus = 1) in a fixed order. The other extreme, the most random order, is randomize = <WithReplacement> In this case, a stimulus will be chosen at random 12 times without memory, for instance hid hood hood heed hid hood hud hud hid hood heed hid The order will probably be different for each listener. In this example, hood and hid occur four times each, heed and hud only twice each. This strategy is too random for most experiments. Usually, you will want to have the same number of replications of each stimulus. The most random way to do this is randomize = <PermuteAll> In this case, all stimuli will be played exactly 3 times, for instance heed hood hud hud hid heed heed hud hood hid hid hood Quite often, you will want a less random order, namely one in which the 12 trials are divided into 3 blocks of 4 stimuli. Within each block, all 4 different stimuli occur in a random order: randomize = <PermuteBalanced> In this case, each stimulus occurs exactly once within each block: heed hood hud hid hood hud hid heed heed hud hood hid This strategy ensures a certain spreading of the stimuli over the sequence of 12 trials. As we see here, it is still possible that the same stimulus (heed) occurs twice in a row, namely as the last stimulus of the second block and the first stimulus of the third. If you want to prevent that situation, you use randomize = <PermuteBalancedNoDoublets> This will ensure that the same stimulus is never applied twice in a row: heed hood hud hid hood hud hid heed hud heed hood hid This randomization strategy is used in our example, and advised for most listening experiments in which you want to minimize effects of stimulus order. The randomization procedure does not interfere in any way with the breaks. The order is determined before any breaks are inserted. Links to this page ExperimentMFC ExperimentMFC 2. The first example 
ExperimentMFC_2_6__Instructions	ExperimentMFC 2.6. Instructions Before the experiment begins, the listener will see the startText in the centre of the screen. During each trial, she will see the runText at the top of the screen. During breaks, she will see the pauseText in the centre of the screen. After all the trials have been performed, she will see the endText. As you can see in the example, all these texts can consist of multiple lines. Links to this page ExperimentMFC ExperimentMFC 2. The first example 
ExperimentMFC_2_7__Response_categories	ExperimentMFC 2.7. Response categories Every trial comes with the same set of response categories. The example experiment has five of them. For each response category, you supply the area of the screen where a rectangle will be drawn. The whole screen measures from 0.0 (left) to 1.0 (right) and from 0.0 (bottom) to 1.0 (top). Thus, 0.2 0.3 0.7 0.8 means that a rectangle will be drawn somewhere in the top left quadrant of the screen. You also supply the text that will be drawn in this rectangle, for instance the text h I d. After this you supply the font size for this text, for instance 40. The second text that you supply for every response is a response key on the keyboard. In the above example this is , i.e. the subject cannot press a key as a response. If you want the user to be able to press the m key instead of clicking in the h I d rectangle, the line in the experiment file would be: 0.2 0.3 0.7 0.8 h I d 40 m i The third text that you supply for each rectangle is the response category as it will be reported by Praat to you when the user clicks it, e.g. the text i. If you want Praat to ignore mouse clicks on this rectangle, specify an empty response category, i.e. . The border of the rectangles will be maroon, the background of the screen will be light grey. The colour of clickable rectangles will be yellow, that of non-clickable rectangles (those with empty category specifications) light grey. You can have a picture instead of a text on a response button, by using \FI: 0.2 0.3 0.7 0.8 \FIpictures/hello.jpg 40 m i In this example, the picture hello.jpg from the subdirectory pictures (i.e. a subdirectory of the directory where your experiment file is) will be drawn into the rectangle [0.2, 0.3] × [0.7, 0.8]. This currently (September 2011) works only on the Mac and Windows. Links to this page ExperimentMFC ExperimentMFC 2. The first example 
ExperimentMFC_2_8__Goodness_judgments	ExperimentMFC 2.8. Goodness judgments If numberOfGoodnessCategories is not 0, some more rectangles will be drawn, as in the example experiment. You specify again the locations of these rectangles (in the example, they touch each other), and the texts on them. Praat will record the number of the button when the listener clicks on it. Thus, if she clicks on the button labelled 1 (poor), Praat will record a goodness judgment of 1, because this is the first button in the list. If she clicks on 5 (good), Praat will record a goodness judgment of 5. Links to this page ExperimentMFC ExperimentMFC 2. The first example 
ExperimentMFC_2_9__How_an_experiment_proceeds	ExperimentMFC 2.9. How an experiment proceeds A text file with an ExperimentMFC object can be read into Praat with Read from file... (it is not a script but a data file, so do not try to read it with Open Praat script...). You can then choose Run. After the experiment finishes, you can close the experiment window and choose Extract results. The resulting ResultsMFC object contains for each trial the stimulus name (e.g. hood), the response category (e.g. u), and the goodness judgment (e.g. 4). You will want to save this ResultsMFC object to a text file with Save as text file.... You may want to call these text files by the names of the subjects, e.g. ts.ResultsMFC and mj.ResultsMFC. Once you have collected the results of all your subjects, you can read all the results files into Praat with Read from file..., then select all the resulting ResultsMFC objects (which will have automatically been named ts, mj, and so on), then choose Collect to table. This will result in a table whose first column contains the names of the subjects, the second column contains the stimulus names, the third column contains the responses, and the last column contains the approximate reaction times (measured from the start of the stimulus sound, i.e. after the initial silence duration). If there are goodness judgments, these will go into the fourth column. The table can be saved as a table file (with Save as tab-separated file...), which can be read by programs like Excel and SPSS. Links to this page ExperimentMFC ExperimentMFC 2. The first example ExperimentMFC 5.2. Stimulus-dependent response buttons 
ExperimentMFC_2__The_first_example	ExperimentMFC 2. The first example The following pages give an example of an experiment definition, and explain the main features of an identification task. ExperimentMFC 2.1. The experiment file ExperimentMFC 2.2. The stimuli ExperimentMFC 2.3. The carrier phrase ExperimentMFC 2.4. Breaks ExperimentMFC 2.5. Randomization strategies ExperimentMFC 2.6. Instructions ExperimentMFC 2.7. Response categories ExperimentMFC 2.8. Goodness judgments ExperimentMFC 2.9. How an experiment proceeds Links to this page ExperimentMFC 
ExperimentMFC_3_1__A_simple_discrimination_experiment	ExperimentMFC 3.1. A simple discrimination experiment The example experiment was an identification experiment: the subject had identify a single sound as one element of a set of categories. Phoneticians will often do discrimination experiments, which are experiments in which a stimulus consists of multiple sub-stimuli played in sequence, and the subject has to judge the similarity between these sub-stimuli. The simplest discrimination task has only two sub-stimuli, and the subject has to say whether these are the same or different. Suppose you have vowel-like sounds along an F1 continuum with seven steps, say 300, 320, 340, 360, 380, 400, and 420 hertz, and you are interested in knowing how well the listeners can distinguish these. As your stimuli, you create pairs of these sounds, separated by 0.8 seconds of silence. It is important to include stimuli in which the sounds are identical, e.g. stimuli in which both sounds have an F1 of 340 Hz (see the literature on signal detection theory). Since sounds that are very different acoustically will always be heard as different, you do not include pairs in which the distance is larger than 60 Hz. The experiment file will look like this: ooTextFile ExperimentMFC 6 blank while playing? <no> stimuli are sounds? <yes> stimuli/ .wav carrier phrase initial silence duration 0.5 seconds medial silence duration 0.8 seconds ! inter-stimulus interval final silence duration 0 seconds 37 different stimuli 300,300 300,320 300,340 300,360 320,300 320,320 320,340 320,360 320,380 340,300 340,320 340,340 340,360 340,380 340,400 360,300 360,320 360,340 360,360 360,380 360,400 360,420 380,320 380,340 380,360 380,380 380,400 380,420 400,340 400,360 400,380 400,400 400,420 420,360 420,380 420,400 420,420 10 replications per stimulus break after every 50 stimuli <PermuteBalancedNoDoublets> Click to start. Say whether these sounds were the same or different. You can have a short break if you like. Click to proceed. The experiment has finished. Call the experimenter. 0 replays replay button 0 0 0 0 ok button 0 0 0 0 oops button 0 0 0 0 responses are sounds? <no> 0 0 0 2 response categories 0.1 0.4 0.35 0.65 same 24 same 0.6 0.9 0.35 0.65 different 24 different 0 goodness categories In this example, the subject will have to click 370 times. After every 50 times, she will have the opportunity to sip her tea. A 0.5-seconds silence is played before every stimulus, so that the listener will not hear the stimulus immediately after her mouse click. The experimenter does not have to create the stimulus pairs as sound files. You can specify multiple sound files by separating them with commas. Thus, 320,300 means that Praat will play the files 320.wav and 300.wav. These two substimuli will be separated here by a silence of 0.8 seconds, called the inter-stimulus interval (or stimulusMedialSilenceDuration). Note that the text in this file is rather different from the previous example. It does not matter whether you write numberOfDifferentStimuli, or different stimuli, or anything else; Praat ignores these texts as long as they do not contain numbers, quoted strings, or things between <>. Links to this page ExperimentMFC ExperimentMFC 3. More examples 
ExperimentMFC_3_2__An_AXB_discrimination_experiment	ExperimentMFC 3.2. An AXB discrimination experiment In the AXB task, the subject will hear three stimuli in sequence, and has to say whether the second (X) is more similar to the first (A) or to the second (B). An experiment file could look like follows: ooTextFile ExperimentMFC 6 blankWhilePlaying? <no> stimuliAreSounds? <yes> stimuli/ .wav carrier initial silence 0.5 inter-stimulus interval 0.3 final silence 0 100 stimuli 300,300,320 300,320,340 300,340,340 300,340,360 ... (and 96 more triplets of substimuli) ... 4 replications break every 50 <PermuteBalancedNoDoublets> Click to start. Say whether the second sound is more similar to the first or to the third. You can have a short break if you like. Click to proceed. The experiment has finished. 0 replays replay button 0 0 0 0 ok button 0 0 0 0 oops button 0 0 0 0 responses are sounds? <no> 0 0 0 3 response categories 0.1 0.3 0.4 0.6 first 30 A 0.4 0.6 0.4 0.6 second 30 0.7 0.9 0.4 0.6 third 30 B 0 goodness categories In this example, the subject has to click 400 times. She sees three buttons, labelled first, second, and third, but the second button (the one with the empty response category) is not clickable: it has a light grey rather than a yellow interior and cannot be chosen by the subject. In your ResultsMFC object, you will only see A and B responses. Links to this page ExperimentMFC ExperimentMFC 3. More examples 
ExperimentMFC_3_3__A_4I-oddity_experiment	ExperimentMFC 3.3. A 4I-oddity experiment In the four-items-oddity task, the subject will hear four stimuli in sequence, and has to say whether the second or the third is the odd one out. The other three substimuli are identical. An experiment file could look as follows: ooTextFile ExperimentMFC 6 blankWhilePlaying? <no> stimuliAreSounds? <yes> stimulusFileNameHead = stimuli/ stimulusFileNameTail = .wav stimulusCarrierBefore = stimulusCarrierAfter = stimulusInitialSilenceDuration = 0.5 seconds stimulusMedialSilenceDuration = 0.3 seconds numberOfDifferentStimuli = 60 300,300,320,300 300,320,300,300 300,300,340,300 300,340,300,300 300,300,360,300 300,360,300,300 320,320,300,320 320,300,320,320 320,320,340,320 320,340,320,320 320,320,360,320 320,360,320,320 320,320,380,320 320,380,320,320 340,340,300,340 340,300,340,340 340,340,320,340 340,320,340,340 340,340,360,340 340,360,340,340 340,340,380,340 340,380,340,340 340,340,400,340 340,400,340,340 360,360,300,360 360,300,360,360 360,360,320,360 360,320,360,360 360,360,340,360 360,340,360,360 360,360,380,360 360,380,360,360 360,360,400,360 360,400,360,360 360,360,420,360 360,420,360,360 380,380,320,380 380,320,380,380 380,380,340,380 380,340,380,380 380,380,360,380 380,360,380,380 380,380,400,380 380,400,380,380 380,380,420,380 380,420,380,380 400,400,340,400 400,340,400,400 400,400,360,400 400,360,400,400 400,400,380,400 400,380,400,400 400,400,420,400 400,420,400,400 420,420,360,420 420,360,420,420 420,420,380,420 420,380,420,420 420,420,400,420 420,400,420,420 numberOfReplicationsPerStimulus = 5 breakAfterEvery = 40 randomize = <PermuteBalancedNoDoublets> startText = Click to start. runText = Say whether the second or the third sound is different from the rest. pauseText = You can have a short break if you like. Click to proceed. endText = The experiment has finished. maximumNumberOfReplays = 0 replayButton = 0 0 0 0 okButton = 0 0 0 0 oopsButton = 0 0 0 0 responsesAreSounds? <no> responseFileNameHead = responseFileNameTail = responseCarrierBefore = responseCarrierAfter = responseInitialSilenceDuration = 0 responseMedialSilenceDuration = 0 responseFinalSilenceDuration = 0 numberOfResponseCategories = 4 0.04 0.24 0.4 0.6 first 30 0.28 0.48 0.4 0.6 second 30 2 0.52 0.72 0.4 0.6 third 30 3 0.76 0.96 0.4 0.6 fourth 30 numberOfGoodnessCategories = 0 In this example, the subject has to click 300 times. She sees four buttons, but the first and fourth buttons cannot be chosen. In your ResultsMFC object, you will only see the responses 2 and 3. Links to this page ExperimentMFC ExperimentMFC 3. More examples 
ExperimentMFC_3_4__Variable_inter-stimulus_intervals	ExperimentMFC 3.4. Variable inter-stimulus intervals Praat only supports a fixed inter-stimulus interval, but sometimes you may want to test discrimination as a function of the inter-stimulus interval itself. You can achieve this by supplying an stimulusMedialSilenceDuration of 0 and using sound files with various silences: 300,silence0.5,320 300,silence1.5,320 300,silence4.5,320 In this example, you have to supply the sound files silence0.5.wav and so on. You can create them with the help of Create Sound from formula... (supply a formula of 0). Links to this page ExperimentMFC ExperimentMFC 3. More examples 
ExperimentMFC_3__More_examples	ExperimentMFC 3. More examples You can do many more kinds of experiments than simple identification experiments. ExperimentMFC 3.1. A simple discrimination experiment ExperimentMFC 3.2. An AXB discrimination experiment ExperimentMFC 3.3. A 4I-oddity experiment ExperimentMFC 3.4. Variable inter-stimulus intervals Links to this page ExperimentMFC 
ExperimentMFC_4_1__The_replay_button	ExperimentMFC 4.1. The replay button The example experiment contained the following lines: maximumNumberOfReplays = 0 replayButton = 0 0 0 0 This means that that experiment did not have a replay button. To add a replay button along the lower edge of the screen, you do something like maximumNumberOfReplays = 1000 replayButton = 0.3 0.7 0.01 0.07 Click here to play the last sound again If you supply a right edge (here 0.7) that is greater than the left edge (here 0.3), Praat will know that you want to show a replay button. When the participant clicks this button, Praat will play the current stimulus again. In this example, the button will be visible until the partipant has clicked it 1000 times. To assign a keyboard shortcut to the replay button, do something like maximumNumberOfReplays = 1000 replayButton = 0.1 0.9 0.01 0.07 Click here or press the space bar to play the last sound again Links to this page ExperimentMFC ExperimentMFC 4. Special buttons 
ExperimentMFC_4_2__The_OK_button	ExperimentMFC 4.2. The OK button The example experiment contained the following lines: okButton = 0 0 0 0 This means that that experiment did not have an OK button. To add an OK button in the lower right corner of the screen, you do something likw okButton = 0.8 0.95 0.05 0.15 OK If you supply a right edge (here 0.95) that is greater than the left edge (here 0.8), Praat will know that you want to show an OK button. The behaviour of the experiment changes appreciably if you include an OK button. If you do not include an OK button, Praat will present the next stimulus as soon as the participant has clicked a response category (and a goodness category, if there are such). If you do include an OK button, it will become visible to the participant as soon as she has chosen a response category (and a goodness category, if there are such). The participant can then click the OK button, but she can also choose to click the response (and goodness buttons) a bit more first. The OK button seems to be useful only if there is also a replay button, or if the response categories are sounds (see ExperimentMFC 6. Responses are sounds). To assign a keyboard shortcut (here, the space bar) to the OK button, do something like okButton = 0.8 0.95 0.05 0.15 OK Links to this page ExperimentMFC ExperimentMFC 4. Special buttons 
ExperimentMFC_4_3__The_oops_button	ExperimentMFC 4.3. The oops button The example experiment contained the following lines: oopsButton = 0 0 0 0 This means that that experiment did not have an oops button. To add an oops button in the lower left corner of the screen, you do something likw oopsButton = 0.05 0.2 0.05 0.15 oops If you supply a right edge (here 0.2) that is greater than the left edge (here 0.05), Praat will know that you want to show an oops button. If you include an oops button, it will become visible to the participant for every stimulus except the first, and it will also be visible on the pause (break) screens and on the final screen. If the participant clicks the oops button, Praat will forget everything the participant did with the current stimulus and the previous stimulus. The experiment will continue with playing the previous stimulus again and waiting for the participant's choice. Links to this page ExperimentMFC ExperimentMFC 4. Special buttons 
ExperimentMFC_4__Special_buttons	ExperimentMFC 4. Special buttons You can include up to three special buttons on the screen that the participant sees. It is probably inadvisable to use all three at the same time. ExperimentMFC 4.1. The replay button ExperimentMFC 4.2. The OK button ExperimentMFC 4.3. The oops button Links to this page ExperimentMFC 
ExperimentMFC_5_1__The_stimulus-dependent_run_text	ExperimentMFC 5.1. The stimulus-dependent run text The example experiment contained the following lines: numberOfDifferentStimuli = 4 heed hid hood hud ... ... runText = Choose the vowel that you heard. For every stimulus, the same `run text' was written at the top of the screen. But suppose you want to make that text dependent on the stimulus. You would do: heed Choose the vowel you heard. hid Click the vowel you heard. hood Select the vowel you heard. hud What's the vowel you heard? ... ... runText = In this case, each stimulus comes with its own text. The runText will only show up for stimuli for which you do not supply a separate text. This feature is useful mainly in cases where the responses are sounds but the stimulus is not (see ExperimentMFC 6. Responses are sounds) or if you want to cause some lexical priming. Links to this page ExperimentMFC ExperimentMFC 5. Stimulus-dependent texts 
ExperimentMFC_5_2__Stimulus-dependent_response_buttons	ExperimentMFC 5.2. Stimulus-dependent response buttons The example experiment contained the following lines: numberOfDifferentStimuli = 4 heed hid hood hud ... ... numberOfDifferentResponses = 5 0.2 0.3 0.7 0.8 h I d 40 i 0.3 0.4 0.5 0.6 h E d 40 e 0.4 0.5 0.3 0.4 h A d 40 a 0.5 0.6 0.5 0.6 h O d 40 o 0.6 0.7 0.7 0.8 h U d 40 u For every stimulus, the buttons contained the same visible texts, such as h I d and h A d. But suppose you have an experiment about the perception of voicing in plosives. The first stimulus starts with an ambiguous /b/ or /p/, and you want the participant to choose between bath and path. The next stimulus starts with an ambiguous /d/ or /t/, and you want the participant to choose between dart and tart. You would go about like this: numberOfDifferentStimuli = 6 bpath1 |bath|path bpath2 |bath|path bpath3 |bath|path dtart1 |dart|tart dtart2 |dart|tart dtart3 |dart|tart ... ... numberOfDifferentResponses = 2 0.2 0.4 0.7 0.8 40 left 0.6 0.8 0.7 0.8 40 right In this case, the two response buttons show either path and path, or dart and tart. In the ResultsMFC (see ExperimentMFC 2.9. How an experiment proceeds), the stimuli will be recorded as bpath1|bath|path and the like, not just as bpath1. Praat does this in order to be able to cope with balanced designs such as bpath1 |bath|path bpath1 |path|bath In other words, the button ordering is considered part of the stimulus. This trick can be combined with a stimulus-dependent run text: numberOfDifferentStimuli = 32 bpath1 Throw a...|bath|path bpath1 Walk a...|bath|path bpath2 Walk a...|bath|path dtart1 Throw a...|dart|tart dtart1 Carry a...|dart|tart ... runText = ... numberOfDifferentResponses = 2 0.2 0.4 0.7 0.8 40 left 0.6 0.8 0.7 0.8 40 right Links to this page ExperimentMFC ExperimentMFC 5. Stimulus-dependent texts 
ExperimentMFC_5__Stimulus-dependent_texts	ExperimentMFC 5. Stimulus-dependent texts In the example experiment, the text at the top of the screen stayed the same throughout the experiment, and so did the texts on the response buttons. There are ways to have these texts depend on the stimulus at hand. ExperimentMFC 5.1. The stimulus-dependent run text ExperimentMFC 5.2. Stimulus-dependent response buttons Links to this page ExperimentMFC 
ExperimentMFC_6__Responses_are_sounds	ExperimentMFC 6. Responses are sounds In the example experiment, the stimuli were sounds, and the responses were categories whose labels appeared on buttons. Sometimes you want it the other way around. An example is the /i/ prototype task: the top of the screen just says Please choose the best ee, and no stimulus sound is played. Instead, the participant can click repeatedly on an array of 40 buttons, each of which contains a different [i]-like sound. That is, if the participant clicks on a response button, an [i]-like sound is played, and every response button has its own sound. Such a task can be regarded as reversing the task of the example experiment, in which the stimulus was a sound and the reponse was a phonological category. In the /i/ prototype task, the stimulus is a phonological category, and the response is a sound. This is what the experiment file could look like: ooTextFile ExperimentMFC 6 blankWhilePlaying? <no> stimuliAreSounds? <no> 0 0 0 numberOfDifferentStimuli = 2 i Choose the best %%ee%. I Choose the best %%i%. numberOfReplicationsPerStimulus = 1 breakAfterEvery = 1 randomize = <CyclicNonRandom> startText = Click to start. runText = pauseText = You can have a short break if you like. Click to proceed. endText = The experiment has finished. maximumNumberOfReplays = 0 replayButton = 0 0 0 0 okButton = 0.8 0.95 0.45 0.55 OK oopsButton = 0 0 0 0 responsesAreSounds? <yes> responseFileNameHead = Sounds/ responseFileNameTail = .wav responseCarrierBefore = responseCarrierAfter = responseInitialSilenceDuration = 0.3 responseMedialSilenceDuration = 0 responseFinalSilenceDuration = 0 numberOfDifferentResponses = 16 0.2 0.3 0.7 0.8 10 i11 0.3 0.4 0.7 0.8 10 i12 0.4 0.5 0.7 0.8 10 i13 0.5 0.6 0.7 0.8 10 i14 0.2 0.3 0.6 0.7 10 i21 0.3 0.4 0.6 0.7 10 i22 0.4 0.5 0.6 0.7 10 i23 0.5 0.6 0.6 0.7 10 i24 0.2 0.3 0.5 0.6 10 i31 0.3 0.4 0.5 0.6 10 i32 0.4 0.5 0.5 0.6 10 i33 0.5 0.6 0.5 0.6 10 i34 0.2 0.3 0.4 0.5 10 i41 0.3 0.4 0.4 0.5 10 i42 0.4 0.5 0.4 0.5 10 i43 0.5 0.6 0.4 0.5 10 i44 numberOfGoodnessCategories = 5 0.25 0.35 0.10 0.20 1 (poor) 0.35 0.45 0.10 0.20 2 0.45 0.55 0.10 0.20 3 0.55 0.65 0.10 0.20 4 0.65 0.75 0.10 0.20 5 (good) The participant will see 16 squares on the screen. First she will have to find the best /i/, then the best /ɪ/. The sound files Sounds/i11.wav and so on must exist and have the same sampling frequency. A silence of 0.3 seconds is played just before each response sound. Links to this page ExperimentMFC ExperimentMFC 4.2. The OK button ExperimentMFC 5.1. The stimulus-dependent run text 
ExperimentMFC_7__Blanking_the_screen	ExperimentMFC 7. Blanking the screen In all the earlier examples, the flag blankWhilePlaying was set to <no>. This means that in all those cases the participant will immediately see the response categories when the sound starts playing (or even earlier, if there is an initial silence). This can be changed by setting blankWhilePlaying to <yes>. When you do that, the participant will see a blank screen while the stimulus is playing, and the response buttons will come up only after the sound has finished. This is useful if you want to prevent the participant from clicking before the sound has finished, or for priming experiments. Reaction times are measured from when the response buttons appear. If you want the response buttons to come up 0.5 seconds after the sound finishes playing, you set the stimulusFinalSilenceDuration to 0.5. Links to this page ExperimentMFC 
ExperimentMFC_8__Running_multiple_experiments	ExperimentMFC 8. Running multiple experiments In all the earlier examples, either the set of stimulus sounds or the set of response sounds stayed the same throughout the experiment. If you want more than one set of stimuli, or more than one set of responses, you can run several experiments after each other, simply by selecting more than one experiment, then clicking Run. You can put all these ExperimentMFC objects in one text file. The following example contains two experiments. The second line has to contain the text Collection, followed by the number of experiments: ooTextFile Collection 2 ExperimentMFC 6 i blankWhilePlaying? <no> stimuliAreSounds? <no> 0 0 0 numberOfDifferentStimuli = 1 i Choose the best %%ee%. numberOfReplicationsPerStimulus = 1 breakAfterEvery = 0 randomize = <CyclicNonRandom> startText = You are going to choose the best %%ee%. Click to start. runText = pauseText = endText = Thank you for choosing the best %%ee%. Click to proceed. maximumNumberOfReplays = 0 replayButton = 0 0 0 0 okButton = 0.8 0.95 0.45 0.55 OK oopsButton = 0 0 0 0 responsesAreSounds? <yes> responseFileNameHead = Sounds/ responseFileNameTail = .wav responseCarrierBefore = responseCarrierAfter = responseInitialSilenceDuration = 0.3 responseMedialSilenceDuration = 0 responseFinalSilenceDuration = 0 numberOfDifferentResponses = 6 0.2 0.3 0.7 0.8 10 i1 0.3 0.4 0.7 0.8 10 i2 0.4 0.5 0.7 0.8 10 i3 0.5 0.6 0.7 0.8 10 i4 0.6 0.7 0.7 0.8 10 i5 0.7 0.8 0.7 0.8 10 i6 numberOfGoodnessCategories = 0 ExperimentMFC 6 u blankWhilePlaying? <no> stimuliAreSounds? <no> 0 0 0 numberOfDifferentStimuli = 1 u Choose the best %%oo%. numberOfReplicationsPerStimulus = 1 breakAfterEvery = 0 randomize = <CyclicNonRandom> startText = You are going to choose the best %%oo%. Click to start. runText = pauseText = endText = All the experiments have finished. You can call the experimenter. maximumNumberOfReplays = 0 replayButton = 0 0 0 0 okButton = 0.8 0.95 0.45 0.55 OK oopsButton = 0 0 0 0 responsesAreSounds? <yes> responseFileNameHead = Sounds/ responseFileNameTail = .wav responseCarrierBefore = responseCarrierAfter = responseInitialSilenceDuration = 0.3 responseMedialSilenceDuration = 0 responseFinalSilenceDuration = 0 numberOfDifferentResponses = 6 0.2 0.3 0.7 0.8 10 u1 0.3 0.4 0.7 0.8 10 u2 0.4 0.5 0.7 0.8 10 u3 0.5 0.6 0.7 0.8 10 u4 0.6 0.7 0.7 0.8 10 u5 0.7 0.8 0.7 0.8 10 u6 numberOfGoodnessCategories = 0 In this example, the participant first has to choose the best /i/ from among six [i]-like sounds, which are in the sound files i1.wav through i6.wav. After that, she has to choose the best /u/ from among six [u]-like sounds, which are in the sound files u1.wav through u6.wav. The percent signs in %%ee% mean that ee will be italicized. If you read this file with Read from file..., you will see two ExperimentMFC objects, named i and u. They both stand selected. You then click Run, and after the participant finishes, you select both ExperimentMFC objects again (probably they still stand selected), and click Extract results. You will then get two ResultMFC objects. Links to this page ExperimentMFC 
Extract_one_channel___	Extract one channel... To extract the left channel of an existing stereo Sound as a new mono Sound, select that stereo Sound in the list and choose Extract one channel... from the Convert menu, Then set the Channel to 1 and click OK. A new mono Sound will appear in the list. For the right channel, set Channel to 2. Details The name of the new mono Sound will be based on the name of the original stereo Sound. For instance, if the original Sound is called hello and you extract channel 2, the new Sound will be called hello_ch2. This command also works if you select more than one stereo Sound. For each of them, Praat creates a new mono Sound. Links to this page stereo 
Extract_visible_formant_contour	Extract visible formant contour One of the commands in the Formant menu of the SoundEditor and the TextGridEditor. See Intro 5. Formant analysis Links to this page Intro 5.4. The Formant object 
Extract_visible_intensity_contour	Extract visible intensity contour One of the commands in the Intensity menu of the SoundEditor and the TextGridEditor. See Intro 6. Intensity analysis 
Extract_visible_pitch_contour	Extract visible pitch contour One of the commands in the Pitch menu of the SoundEditor and the TextGridEditor. See Intro 4. Pitch analysis Links to this page Intro 4.5. The Pitch object 
Extract_visible_spectrogram	Extract visible spectrogram One of the commands in the Spectrogram menu of the SoundEditor and the TextGridEditor. See Intro 3. Spectral analysis 
Fant__1960_	Fant (1960) Gunnar Fant (1960): Acoustic theory of speech production. Mouton, The Hague. Links to this page Create Vocal Tract from phone... Source-filter synthesis 
FAQ__Formant_analysis	FAQ: Formant analysis Problem: I get different formant values if I choose to analyse 3 formants than if I choose to analyse 4 formants. Solution: the number of formants in formant analysis determines the number of peaks with which the entire spectrum is modelled. For an average female voice, you should choose to analyse 5 formants in the region up to 5500 Hz, even if you are interested only in the first three formants. Problem: I often get only 1 formant in a region where I see clearly 2 formants in the spectrogram. This occurs mainly in back vowels (F1 and F2 close together) for male voices, if the maximum formant is set to the standard of 5500 Hz, which is appropriate for female voices. Set the maximum formant down to 5000 Hz. No, Praat comes without a guarantee: the formant analysis is based on LPC, and this comes with several assumptions as to what a speech spectrum is like. Question: what algorithm is used for formant analysis? Answer: see Sound: To Formant (burg).... Links to this page FAQ (Frequently Asked Questions) 
FAQ__Frequently_Asked_Questions_	FAQ (Frequently Asked Questions) FAQ: How to cite Praat Unicode FAQ: Formant analysis FAQ: Pitch analysis FAQ: Spectrograms FAQ: Scripts 
FAQ__How_to_cite_Praat	FAQ: How to cite Praat Question: how do I cite Praat in my articles? Answer: nowadays most journals allow you to cite computer programs and web sites. The style approved by the American Psychological Association, and therefore by many journals, is like the following (change the dates and version number as needed): Boersma, Paul & Weenink, David (2014). Praat: doing phonetics by computer [Computer program]. Version 5.4, retrieved 4 October 2014 from http://www.praat.org/ If the journal does not allow you to cite a web site, then try: Boersma, Paul (2001). Praat, a system for doing phonetics by computer. Glot International 5:9/10, 341-345. This paper can be downloaded from Boersma's website. Links to this page FAQ (Frequently Asked Questions) 
FAQ__Pitch_analysis	FAQ: Pitch analysis Question: what algorithm is used for pitch analysis? Answer: see Sound: To Pitch (ac).... The 1993 article is downloadable from http://www.fon.hum.uva.nl/paul/ Question: why does Praat consider my sound voiceless while I hear it as voiced? There are at least five possibilities. Most of them can be checked by zooming in on the waveform. The first possibility is that the pitch has fallen below the pitch floor. For instance, your pitch floor could be 75 Hz but the English speaker produces creak at the end of the utterance. Or your pitch floor could be 75 Hz but the Chinese speaker is in the middle of a third tone. If this happens, it may help to lower the pitch floor to e.g. 40 Hz (Pitch settings...), although that may also smooth the pitch curve too much in other places. The second possibility is that the pitch has moved too fast. This could happen at the end of a Chinese fourth tone, which drops very fast. If this happens, it may help to use the optimize for voice analysis setting, (Pitch settings...), although Praat may then hallucinate pitches in other places that you would prefer to consider voiceless. The third possibility is that the periods are very irregular, as in some pathological voices. If you want to see a pitch in those cases, it may help to use the optimize for voice analysis setting (Pitch settings...). Or it may help to lower the voicing threshold setting (Advanced pitch settings...) to 0.25 (instead of the standard 0.45) or so. The fourth possibility is that there is a lot of background noise, as in a recording on a busy street. In such a case, it may help to lower the voicing threshold setting (Advanced pitch settings...) to 0.25 (instead of the standard 0.45) or so. The disadvantage of lowering this setting is that for non-noisy recordings, Praat will become too eager to find voicing in some places that you would prefer to consider voiceless; so make sure to set it back to 0.45 once you have finished analysing the noisy recordings. The fifth possibility is that the part analysed as voiceless is much less loud than the rest of the sound, or that the sound contains a loud noise elsewhere. This can be checked by zooming in on the part analysed as voiceless: if Praat suddenly considers it as voiced, this is a sign that this part is much quieter than the rest. To make Praat analyse this part as voiced, you can lower the silence threshold setting to 0.01 (instead of the standard 0.03) or so. The disadvantage of lowering this setting is that Praat may start to consider some distant background sounds (and quiet echos, for instance) as voiced. Question: why do I get different results for the maximum pitch if...? If you select a Sound and choose Sound: To Pitch..., the time step will usually be 0.01 seconds. The resulting Pitch object will have values for times that are 0.01 seconds apart. If you then click Info or choose Get maximum pitch from the Query menu, the result is based on those time points. By contrast, if you choose Get maximum pitch from the Pitch menu in the SoundEditor window, the result will be based on the visible points, of which there tend to be a hundred in the visible window. These different time spacings will lead to slightly different pitch contours. If you choose Move cursor to maximum pitch, then choose Get pitch from the Pitch menu, the result will be different again. This is because Get maximum pitch can do a parabolic interpolation around the maximum, whereas Get pitch, not realizing that the cursor is at a maximum, does a stupid linear interpolation, which tends to lead to lower values. Links to this page FAQ (Frequently Asked Questions) 
FAQ__Scripts	FAQ: Scripts Question: how do I do something to all the files in a directory? Answer: look at Create Strings as file list.... Question: why doesn't the editor window react to my commands? Your commands are probably something like: Read from file: hello.wav View & Edit Zoom: 0.3, 0.5 Answer: Praat doesn't know it has to send the Zoom command to the editor window called 14. Sound hello. There could be several Sound editor windows on your screen. According to Scripting 7.1. Scripting an editor from a shell script, you will have to say this explicitly: Read from file: hello.wav View & Edit editor: Sound hello Zoom: 0.3, 0.5 Problem: a line like Number = 1 does not work. Solution: names of variables should start with a lower-case letter. Question: why do names of variables have to start with a lower-case letter? I would like to do things like F0 = Get mean pitch. Answer (using the shorthand script syntax): Praat scripts combine button commands with things that only occur in scripts. Button commands always start with a capital letter, e.g. Play. Script commands always start with lower case, e.g. echo Hello. A minimal pair is select, which simulates a mouse click in the object list, versus Select..., which sets the selection in editor windows. Variable names that start with a capital letter would be rather ambiguous in assignments, as in x = Get, where Get would be a variable, versus x = Get mean, where Get mean is a button command. To prevent this, Praat enforces a rigorous lower-case/upper-case distinction. Question: how do I convert a number into a string? Answer: a$ = string$ (a) Question: how do I convert a string into a number? Answer: a = number (a$) Links to this page FAQ (Frequently Asked Questions) 
FAQ__Spectrograms	FAQ: Spectrograms Problem: the background is grey instead of white (too little contrast) Solution: reduce the dynamic range in the spectrogram settings. The standard value is 50 dB, which is fine for detecting small things like plosive voicing in well recorded speech. For gross features like vowel formants, or for noisy speech, you may want to change the dynamic range to 40 or even 30 dB. Links to this page FAQ (Frequently Asked Questions) 
Fast_Fourier_Transform	Fast Fourier Transform An algorithm for fast computation of the Fourier transform of a sampled signal. It involves increasing the number of samples N to the next-highest power of two, and the computation time scales as N log N. In Praat, the Fast Fourier Transform is used: 1. For the Fourier transform of an entire sound: Sound: To Spectrum... with yes for the Fast setting, and Spectrum: To Sound. 2. For the Fourier transform of consecutive frames in a sound. See Sound: To Spectrogram.... 3. For the fast computation of correlations, e.g. in Sound: To Pitch (ac).... Links to this page FFT 
FeatureWeights	FeatureWeights One of the types of objects in Praat. A FeatureWeights object is a d-dimensional vector containing weight values used to transform a d-dimensional space. Feature weighting can be used to improve the classifcation accuracy of KNN classifiers. It can also be used to generate a Dissimilarity matrix from a Pattern object. Dissimilarity matrices in conjunction with MDS-analysis can aid the visualization of high-dimensional data. Links to this page KNN & FeatureWeights: Get accuracy estimate... KNN & Pattern & Categories & FeatureWeights: Evaluate... KNN & Pattern & Categories: To FeatureWeights... KNN & Pattern & FeatureWeights: To Categories... KNN & Pattern & FeatureWeights: To TableOfReal... kNN classifiers 2. Quick start KNN: To FeatureWeights... Pattern & FeatureWeights: To Categories... Pattern & FeatureWeights: To Dissimilarity... Pattern to Dissimilarity 
Feedforward_neural_networks	Feedforward neural networks This tutorial describes the use of FFNet feedforward neural networks in PRAAT. 1. What is a feedforward neural network? 1.1 The learning phase 1.2 The classification phase 2. Quick start 3. FFNet versus discriminant classifier 4. Command overview Links to this page Acknowledgments Intro kNN classifiers 2. Quick start 
Feedforward_neural_networks_1_1__The_learning_phase	Feedforward neural networks 1.1. The learning phase During the learning phase the weights in the FFNet will be modified. All weights are modified in such a way that when a pattern is presented, the output unit with the correct category, hopefully, will have the largest output value. How does learning take place? The FFNet uses a supervised learning algorithm: besides the input pattern, the neural net also needs to know to what category the pattern belongs. Learning proceeds as follows: a pattern is presented at the inputs. The pattern will be transformed in its passage through the layers of the network until it reaches the output layer. The units in the output layer all belong to a different category. The outputs of the network as they are now are compared with the outputs as they ideally would have been if this pattern were correctly classified: in the latter case the unit with the correct category would have had the largest output value and the output values of the other output units would have been very small. On the basis of this comparison all the connection weights are modified a little bit to guarantee that, the next time this same pattern is presented at the inputs, the value of the output unit that corresponds with the correct category is a little bit higher than it is now and that, at the same time, the output values of all the other incorrect outputs are a little bit lower than they are now. (The differences between the actual outputs and the idealized outputs are propagated back from the top layer to lower layers to be used at these layers to modify connection weights. This is why the term backpropagation network is also often used to describe this type of neural network. If you perform the procedure above once for every pattern and category pair in your data set you have have performed 1 epoch of learning. The hope is that eventually, probably after many epochs, the neural net will remember these pattern-category pairs. You even hope that the neural net when the learning phase has terminated, will be able to generalize and has learned to classify correctly any unknown pattern presented to it. Because real-life data many times contains noise as well as partly contradictory information these hopes can only be partly fulfilled. For learning you need to select 3 different objects together: a FFNet (the classifier), a Pattern (the inputs) and a Categories (the correct outputs). How long will the learning phase take? In general this question is hard to answer. It depends on the size of the neural network, the number of patterns to be learned, the number of epochs, the tolerance of the minimizer and the speed of your computer, how much computing time the learning phase may take. If computing time becomes excessive in your interactive environment then consider using the powerful scripting facilities in PRAAT to process your learning job as a batch job. Links to this page Feedforward neural networks Feedforward neural networks 1. What is a feedforward neural network? Feedforward neural networks 1.2. The classification phase 
Feedforward_neural_networks_1_2__The_classification_pha	Feedforward neural networks 1.2. The classification phase In the classification phase the weights of the network are fixed. A pattern, presented at the inputs, will be transformed from layer to layer until it reaches the output layer. Now classification can occur by selecting the category associated with the output unit that has the largest output value. For classification we only need to select an FFNet and a Pattern together and choose To Categories.... In contrast to the learning phase classification is very fast. Links to this page Feedforward neural networks Feedforward neural networks 1. What is a feedforward neural network? 
Feedforward_neural_networks_1__What_is_a_feedforward_ne	Feedforward neural networks 1. What is a feedforward neural network? A feedforward neural network is a biologically inspired classification algorithm. It consist of a (possibly large) number of simple neuron-like processing units, organized in layers. Every unit in a layer is connected with all the units in the previous layer. These connections are not all equal, each connection may have a different strength or weight. The weights on these connections encode the knowledge of a network. Often the units in a neural network are also called nodes. Data enters at the inputs and passes through the network, layer by layer, until it arrives at the outputs. During normal operation, that is when it acts as a classifier, there is no feedback between layers. This is why they are called feedforward neural networks. In the following figure we see an example of a 2-layered network with, from top to bottom: an output layer with 5 units, a hidden layer with 4 units, respectively. The network has 3 input units. The 3 inputs are shown as circles and these do not belong to any layer of the network (although the inputs sometimes are considered as a virtual layer with layer number 0). Any layer that is not an output layer is a hidden layer. This network therefore has 1 hidden layer and 1 output layer. The figure also shows all the connections between the units in different layers. A layer only connects to the previous layer. The operation of this network can be divided into two phases: 1. The learning phase 2. The classification phase Links to this page Feedforward neural networks kNN classifiers 1. What is a kNN classifier? 
Feedforward_neural_networks_2__Quick_start	Feedforward neural networks 2. Quick start You may create the iris example set with the Create iris example... command that you will find under the Neural nets option in the New menu. Three new objects will appear in the List of Objects: a FFNet, a Categories and a Pattern. The Pattern contains the iris data set in a 150 rows by 4 columns matrix. To guarantee that every cell in the Pattern is in the [0,1] interval, all measurement values were divided by 10. In the Categories the three iris species setosa, versicolor, and virginica were categorized with the numbers 1, 2 and 3, respectively. Because there are 4 data columns in the Pattern and 3 different iris species in the Categories, the newly created FFNet has 4 inputs and 3 outputs. If you have entered a positive number in one of the fields in the form, the FFNet will have this number of units in a hidden layer. The name of the newly created FFNet will reflect its topology. If you did opt for the default, 0 hidden units, the FFNet will be named 4-3. Learning the iris data The first thing you probably might want to do is to let the FFNet learn the association in each pattern-category pair. To do this select all three objects together and choose Learn.... A form will appear, asking you to supply some settings for the learning algorithm. Learning starts after you have clicked the OK-button. Since the example network does not have too many weights that need to be adjusted and the learning data set is very small and computers nowadays are very fast, this will only take a very short time. Classify Now, if you are curious how well the FFNet has learned the iris data, you may select the FFNet and the Pattern together and choose To Categories.... A new Categories appears in the List of Objects with the name 4-3_iris (if 4-3 was the name of the FFNet and iris the name of the Pattern). We have two different Categories in the list of objects, the topmost one has the original categories, the other the categories as were assigned by the FFNet classifier. The obvious thing to do now is to compare the original categories with the assigned categories by making a confusion table. Select the two Categories and choose To Confusion and a newly created Confusion appears. Pressing the Info button will show you an info window with, among others, the fraction correct. You might also want to compare the FFNet classifier with a discriminant classifier. Create other neural net topologies With a Pattern and a Categories selected together, you can for example create a new FFNet of a different topology. Links to this page Feedforward neural networks 
Feedforward_neural_networks_3__FFNet_versus_discriminan	Feedforward neural networks 3. FFNet versus discriminant classifier You might want to compare the FFNet classifier with a discriminant classifier. Unlike the FFNet, a discriminant classifier does not need any iterative procedure in the learning phase and can be used immediately after creation for classification. The following three simple steps will give you the confusion matrix based on discriminant analysis: 1. Select the Pattern and the Categories together and choose To Discriminant. A newly created Discriminant will appear. 2. Select the Discriminant and the Pattern together and choose To Categories.... A newly created Categories will appear. 3. Select the two appropriate Categories and choose To Confusion. A newly created Confusion will appear. After pushing the Info button, the info window will show you the fraction correct. See also the Discriminant analysis tutorial for more information. Links to this page Feedforward neural networks Feedforward neural networks 2. Quick start 
Feedforward_neural_networks_4__Command_overview	Feedforward neural networks 4. Command overview FFNet commands Creation: Pattern & Categories: To FFNet... Create FFNet... Learning: FFNet & Pattern & Categories: Learn... FFNet & Pattern & Categories: Learn slow... Classification: FFNet & Pattern: To Categories... Drawing: FFNet: Draw topology FFNet: Draw weights... FFNet: Draw cost history... Queries FFNet & Pattern & Categories: Get total costs... FFNet & Pattern & Categories: Get average costs... FFNet & Pattern & Activation: Get total costs... FFNet & Pattern & Activation: Get average costs... Analysis: FFNet & Pattern: To Activation... Modification: FFNet: Reset... FFNet: Select biases... FFNet: Select all weights Links to this page Feedforward neural networks 
FFNet	FFNet One of the types of objects in PRAAT. A FFNet models a feedforward neural net. A feedforward neural net can learn associations between its input and its output. The Feedforward neural networks tutorial gives you an introduction to feedforward neural nets. Links to this page Create FFNet (linear outputs)... Create FFNet... Create iris example... epoch Feedforward neural networks 2. Quick start FFNet & Pattern & Activation: Get average costs... FFNet & Pattern & Activation: Get total costs... FFNet & Pattern & Categories: Get average costs... FFNet & Pattern & Categories: Get total costs... FFNet & Pattern & Categories: Learn slow... FFNet & Pattern & Categories: Learn... FFNet & Pattern: To Categories... FFNet: Draw cost history... FFNet: Draw topology FFNet: Draw weights... FFNet: Extract weights... FFNet: Get number of hidden units... FFNet: Get number of hidden weights... FFNet: Get number of inputs FFNet: Get number of outputs FFNet: Principal components FFNet: Reset... FFNet: Select biases... kNN classifiers 2. Quick start Pattern & Categories: To FFNet... 
FFNet___Pattern___Activation__Get_average_costs___	FFNet & Pattern & Activation: Get average costs... Query the selected FFNet, Pattern and Activation for the average costs. Algorithm All patterns are propagated and the total costs are calculated as is shown in FFNet & Pattern & Categories: Learn.... These total costs are then divided by the number of patterns. Links to this page Feedforward neural networks 4. Command overview 
FFNet___Pattern___Activation__Get_total_costs___	FFNet & Pattern & Activation: Get total costs... Query the selected FFNet, Pattern and Activation for the total costs. Algorithm All patterns are propagated and the total costs are calculated as is shown in FFNet & Pattern & Categories: Learn.... Links to this page Feedforward neural networks 4. Command overview 
FFNet___Pattern___Categories__Get_average_costs___	FFNet & Pattern & Categories: Get average costs... Query the selected FFNet, Pattern and Categories for the average costs. Algorithm All patterns are propagated and the total costs are calculated as is shown in FFNet & Pattern & Categories: Learn.... These total costs are then divided by the number of patterns. Links to this page Feedforward neural networks 4. Command overview 
FFNet___Pattern___Categories__Get_total_costs___	FFNet & Pattern & Categories: Get total costs... Query the selected FFNet, Pattern and Categories for the total costs. Algorithm All patterns are propagated and the total costs are calculated as is shown in FFNet & Pattern & Categories: Learn.... Links to this page Feedforward neural networks 4. Command overview 
FFNet___Pattern___Categories__Learn___	FFNet & Pattern & Categories: Learn... You can choose this command after selecting one Pattern, one Categories and one FFNet. Settings Maximum number of epochs the maximum number of times that the complete Pattern dataset will be presented to the neural net. Tolerance of minimizer when the difference in costs between two successive learning cycles is smaller than this value, the minimization process will be stopped. Cost function Minimum-squared-error: costs = ∑allPatterns ∑allOutputs (ok - dk)2, where ok : actual output of unit k dk : desired output of unit k Minimum-cross-entropy: costs = - ∑allPatterns ∑allOutputs (dk · ln ok + (1-dk) · ln (1-ok)) Algorithm The minimization procedure is a variant of conjugate gradient minimization, see for example Press et al. (1992), chapter 10, or Nocedal & Wright (1999), chapter 5. Links to this page Feedforward neural networks 1.1. The learning phase Feedforward neural networks 2. Quick start Feedforward neural networks 4. Command overview FFNet & Pattern & Activation: Get average costs... FFNet & Pattern & Activation: Get total costs... FFNet & Pattern & Categories: Get average costs... FFNet & Pattern & Categories: Get total costs... 
FFNet___Pattern___Categories__Learn_slow___	FFNet & Pattern & Categories: Learn slow... To learn an association you have to select a FFNet, a Pattern and a Categories object. Preconditions The number of columns in a Pattern must equal the number of input units of FFNet. Algorithm Steepest descent Preconditions The number of rows in a Pattern must equal the number of categories in a Categories. The number of unique categories in a Categories must equal the number of output units in FFNet. Links to this page Feedforward neural networks 4. Command overview 
FFNet___Pattern__To_Categories___	FFNet & Pattern: To Categories... The FFNet is used as a classifier. Each pattern from the Pattern will be classified into one of the FFNet's categories. Links to this page Categories Feedforward neural networks 1.1. The learning phase Feedforward neural networks 1.2. The classification phase Feedforward neural networks 2. Quick start Feedforward neural networks 4. Command overview 
FFNet__Categories	FFNet: Categories The categories for training a neural net with a Pattern. Preconditions The number of categories in a Categories must equal the number of rows in Pattern. 
FFNet__Draw_cost_history___	FFNet: Draw cost history... You can choose this command after selecting 1 or more FFNet's. Settings Iteration range determines the horizontal range of the plot. Cost range determines the vertical range of the plot. Garnish determines whether a box and axis labels are drawn. Behaviour Draws the history of the cost versus iteration number during previous learning. Links to this page Feedforward neural networks 4. Command overview 
FFNet__Draw_topology	FFNet: Draw topology You can choose this command after selecting 1 or more FFNet's. Behaviour Draws all units and all connections of a feedforward neural net. Links to this page Feedforward neural networks 4. Command overview 
FFNet__Draw_weights___	FFNet: Draw weights... Draws the weights in a layer of the selected FFNet feedforward neural net. Settings Layer number determines the layer. Garnish determines whether additional information is drawn. Behaviour The weights are arranged in a matrix. The columns of this matrix are indexed by the units in the layer, while the rows are indexed by the units in the previous layer. There is one extra row for the biases.The values of the weights are shown as rectangles. The area of a rectangle is proportional to the value. Negative values are shown as filled black rectangles. Links to this page Feedforward neural networks 4. Command overview 
FFNet__Extract_weights___	FFNet: Extract weights... Extract all the weights, from all the units in the specified layer of the selected FFNet, to a TableOfReal. Settings Layer number determines the layer. Behaviour The weights will be arranged in the TableOfReal as follows: The table columns will be indexed by the unit numbers in the selected layer, while the rows will be indexed by the unit numbers from the previous layer. There will be one extra row to accommodate the bias weights. The rows and columns are labelled with layer number and unit number as Li-j, where i is the layer number and j the unit number from that layer. The layer number for the rows is one less than the layer number in the columns. The last row is labelled as Bias. 
FFNet__Get_number_of_hidden_units___	FFNet: Get number of hidden units... Queries the selected FFNet for the number of units in a hidden layer. Settings Hidden layer number determines the layer that is queried. Layer numbering The number of hidden layers is always one less than the total number of layers in a FFNet. A network with the output units connected to the inputs therefore has only 1 layer, the output layer and no hidden layers. 
FFNet__Get_number_of_hidden_weights___	FFNet: Get number of hidden weights... Queries the selected FFNet for the number of weights in a hidden layer. Settings Hidden layer number determines the layer that is queried. 
FFNet__Get_number_of_inputs	FFNet: Get number of inputs Queries the selected FFNet for the number of inputs. For a network with only one layer, the inputs are connected directly to the output layer. In a two-layer network the inputs are connected to a hidden layer. 
FFNet__Get_number_of_outputs	FFNet: Get number of outputs Queries the selected FFNet for the number of output units in the output layer. 
FFNet__Pattern	FFNet: Pattern A Pattern is a Matrix in which each row forms one input pattern (vector) for the neural net. The number of columns is the dimensionality of the input. The number of rows is the number of patterns. 
FFNet__Principal_components	FFNet: Principal components When you select FFNet and Eigen the decision planes of layer 1 are drawn in the PC-plane. 
FFNet__Reset___	FFNet: Reset... You can choose this command after selecting 1 or more FFNet's. WARNING This command destroys all previous learning. Settings Range determines the upper limit of the [-range, +range] interval from which new weights will be randomly selected. Behaviour All (selected) weights are reset to random numbers uniformly drawn from the interval [-range, +range]. This command also clears the cost history. Links to this page Feedforward neural networks 4. Command overview 
FFNet__Select_biases___	FFNet: Select biases... Selects only the biases in one particular layer as subject for modification during learning of the FFNet. Settings Layer number determines the layer whose biases will be modified. Behaviour This command induces very specific behaviour during a following learning phase. Instead of all the weights, only the biases in the specified layer will be changed during learning and the rest of the weights stay fixed. 
FFT	FFT An abbreviation for Fast Fourier Transform. Links to this page Matrix 
Figueiredo___Jain__2002_	Figueiredo & Jain (2002) Mario A.T. Figueiredo & Anil K. Jain (2002): Unsupervised learning of finite mixture models. IEEE Transactions on Pattern Analysis and Machine Intelligence 24(3): 381–396. Links to this page GaussianMixture & TableOfReal: To GaussianMixture (CEMM)... 
File_menu	File menu One of the menus in all editors, in the manual, and in the Picture window. Links to this page Intro 2.1. Saving a sound to disk Intro 8.1. Manipulation of pitch Intro 8.2. Manipulation of duration ScriptEditor Scripting 7.2. Scripting an editor from within 
FilterBank__Draw_filter_functions___	FilterBank: Draw filter functions... 
FilterBank__Draw_frequency_scales___	FilterBank: Draw frequency scales... 
FilterBank__Get_frequency_in_Bark___	FilterBank: Get frequency in Bark... 
FilterBank__Get_frequency_in_Hertz___	FilterBank: Get frequency in Hertz... A query to the selected FilterBank object. Return value a frequency value in Hertz. 
FilterBank__Get_frequency_in_mel___	FilterBank: Get frequency in mel... 
Filtering	Filtering This tutorial describes the use of filtering techniques in Praat. It assumes you are familiar with the Intro. Frequency-domain filtering Modern computer techniques make possible an especially simple batch filtering method: multiplying the complex spectrum in the frequency domain by any real-valued filter function. This leads to a zero phase shift for each frequency component. The impulse response is symmetric in the time domain, which also means that the filter is acausal: the filtered signal will show components before they start in the original. • Spectrum: Filter (pass Hann band)... • Spectrum: Filter (stop Hann band)... • Sound: Filter (pass Hann band)... • Sound: Filter (stop Hann band)... • Sound: Filter (formula)... Spectro-temporal: • band filtering in the frequency domain Fast time-domain filtering Some very fast Infinite Impulse Response (IIR) filters can be defined in the time domain. These include recursive all-pole filters and pre-emphasis. These filters are causal but have non-zero phase shifts. There are versions that create new Sound objects: • Sound: Filter (one formant)... • Sound: Filter (pre-emphasis)... • Sound: Filter (de-emphasis)... And there are in-line versions, which modify the existing Sound objects: • Sound: Filter with one formant (in-line)... • Sound: Pre-emphasize (in-line)... • Sound: De-emphasize (in-line)... Convolution A Finite Impulse Response (FIR) filter can be described as a sampled sound. Filtering with such a filter amounts to a convolution of the original sound and the filter: • Sounds: Convolve... Described elsewhere Described in the Source-filter synthesis tutorial: • Sound & Formant: Filter • Sound & FormantGrid: Filter • LPC & Sound: Filter... • LPC & Sound: Filter (inverse) Links to this page Sound Types of objects 
Fischer__2005_	Fischer (2005) Markus Fischer (2005): A Robbins-Monro type learning algorithm for an entropy maximizing version of stochastic Optimality Theory. Master’s thesis, Humboldt University, Berlin. [Rutgers Optimality Archive 767, http://roa.rutgers.edu/] Links to this page OT learning 1. Kinds of grammars 
Fisher__1936_	Fisher (1936) R.A. Fisher (1936): The use of multiple measurements in taxonomic problems. Annals of Eugenics 7: 179–188. Links to this page iris data set 
fisherQ	fisherQ fisherQ (f, df1, df2) returns the area under Fisher's F-distribution from f to +∞. Links to this page invFisherQ 
Fixed_menu_commands	Fixed menu commands The commands in the fixed menus of the Object window (Praat, New, Open, Help, Goodies, Preferences, and Technical) and the Picture window (File, Edit, Margins, World, Select, Pen, Font, Help). These commands are always clickable (if not hidden) and scriptable (if not added). Links to this page ButtonEditor 
FLAC_files	FLAC files A way for storing a Sound object on disk. File format A lossless compressed audio file format. Reading With Read from file.... Saving With Save as FLAC audio file.... 
Flanagan__1960_	Flanagan (1960) J.L. Flanagan (1960): Models for approximating basilar membrane displacement. Bell System Technical Journal 39: 1163–1191. Links to this page gammatone 
Flanagan___Landgraf__1968_	Flanagan & Landgraf (1968) James L. Flanagan & L.L. Landgraf (1968): Self-oscillating source for vocal-tract synthesizers. IEEE Transactions on Audio and Electroacoustics AU-16: 57-64. Reprinted in: James L. Flanagan & Lawrence R. Rabiner (eds.) (1973): Speech synthesis, Dowden, Hutchinson & Ross, Stroudsburg. The authors show that if we model each vocal cord as a single mass-spring system, the vocal cords will vibrate passively as a result of the interaction with a glottal airflow. Links to this page Ishizaka & Flanagan (1972) 
Font_menu	Font menu One of the menus of the Picture window. It allows you to choose the font of the text to be used in subsequent drawing, as well as its size (character height). Sizes You can choose any of the sizes 10, 12, 14, 18, or 24 directly from this menu, or fill in any other size in the Font size... form. The widths of the margins depend on the current font size, so if you want to change the font size, do so before making your drawing. Fonts With these commands, you set the font in which subsequent text will be drawn: Times, Helvetica, Palatino, or Courier. You can mix the Symbol and IPA alphabets with the normal Roman alphabets and use sequences of backslash + digraph for special symbols (see also phonetic symbols). For instance, you can get an ë by typing \e, or a ß by typing \ss; you can get an ε by typing \ep, or a ɔ, which is a turned c, by typing \ct. Styles There are no commands in the menu for text styles (bold, italic), but you can still use them in the Picture window: see text styles. Links to this page Margins Text... Viewport text... 
Formant	Formant One of the types of objects in Praat. A Formant object represents spectral structure as a function of time: a formant contour. Unlike the time-stamped FormantGrid object, it is sampled into a number of frames centred around equally spaced times, Each frame contains frequency and bandwidth information about several formants. Inside a Formant object With Inspect, you will see the following attributes: xmin start time, in seconds. xmax end time, in seconds. nx the number of frames (≥ 1). dx time step = frame length = frame duration, in seconds. x1 the time associated with the first frame, in seconds. This will usually be in the range [xmin, xmax]. The time associated with the last frame (i.e., x1 + (nx – 1) dx)) will also usually be in that range. framei, i = 1 ... nx the frames (see below). Attributes of a formant frame Each framei contains the following attributes: intensity an indication of the maximum intensity (a squared sound amplitude) in this frame. nFormants the number of formants in this frame (usually between 2 and 6). formantj, j = 1 ... nFormants the information about each formant (see below). Attributes of each formant Each formantj contains the following attributes: frequency the formant's centre frequency (in Hz). bandwidth the formant's bandwidth (in Hz). See also Linear Prediction Links to this page Formant: Down to FormantGrid Formant: Draw tracks... Formant: Formula (bandwidths)... Formant: Formula (frequencies)... Formant: Get bandwidth at time... Formant: Get maximum... Formant: Get mean... Formant: Get minimum... Formant: Get number of formants Formant: Get quantile... Formant: Get standard deviation Formant: Get time of maximum... Formant: Get time of minimum... Formant: Get value at time... Formant: Speckle... Formant: Track... Formants: Extract smoothest part (constrained)... Formulas 7. Attributes of objects Get frame number from time... Get number of frames Get time from frame number... Get time step Intro 5.4. The Formant object Sound & Formant: Filter Sound & Formant: Filter (no scale) Sound: To Formant (burg)... Sound: To Formant (keep all)... Sound: To Formant (robust)... Sound: To Formant (sl)... Source-filter synthesis 4. Using existing sounds time domain What was new in 3.7? 
Formant___Spectrogram__To_IntensityTier___	Formant & Spectrogram: To IntensityTier... Determines the formant intensities from the selected Spectrogram. The intensities at the frequencies of the selected formant are copied from the corresponding positions in the spectrogram. If the selected formant doesn't exist in a particular frame, then a large negative value (< -200 dB) is substituted instead. Because the values in the spectrogram are expressed in Pa2/Hz, the units in the intensity tier are in dB/Hz. 
Formant__Down_to_FormantGrid	Formant: Down to FormantGrid A command to convert every selected Formant into a FormantGrid. This performs a trivial copying of frames to points. Each formant tier and each bandwidth tier of the resulting FormantGrid contains a point for each original frame. The intensity information is lost. Links to this page Source-filter synthesis 4. Using existing sounds 
Formant__Draw_tracks___	Formant: Draw tracks... A command to draw the selected Formant objects to the Picture window. Behaviour Every formant value is drawn as one or two short line segments, connected, if possible, with a line segment of the corresponding formant values in the adjacent frames. Settings From time (s) To time (s) the time domain of the drawing. If To time is not greater than From time, the entire formant contour is drawn. Maximum frequency (Hz) the height of the y axis. For speech, 5000 Hz is a usual value. Garnish determines whether axes, numbers, and texts (Time, Formant frequency) will be drawn in the margins around the picture. Turn this button off if you prefer to garnish your picture by yourself with the Margins menu. Usage Unlike Formant: Speckle..., this procedure assumes that e.g. the second formant in frame i has something to do with the second formant in frame i+1. To make this assumption more plausible, use Formant: Track... first. 
Formant__Formula__bandwidths____	Formant: Formula (bandwidths)... A command to modify each selected Formant object with a specified formula. For what you can do with formulas, see Matrix: Formula.... The ith row contains the values of the ith bandwidth contour. See Formant: Formula (frequencies)... for more information. Links to this page Source-filter synthesis 4. Using existing sounds 
Formant__Formula__frequencies____	Formant: Formula (frequencies)... A command to modify each selected Formant object with a specified formula. For what you can do with formulas, see Matrix: Formula.... The ith row contains the values of the ith frequency contour. For an example, see Source-filter synthesis. Links to this page Formant: Formula (bandwidths)... Source-filter synthesis 4. Using existing sounds What was new in 3.7? 
Formant__Get_bandwidth_at_time___	Formant: Get bandwidth at time... A query to the selected Formant object for the bandwidth of the specified formant at the specified time. Settings Formant number the ordinal number of the formant, counting up from 0 Hz. Specify 2 for F2 etc. Time (s) the time at which to evaluate the bandwidth. Units the units of the result (hertz or Bark). Return value the estimated bandwidth in hertz or Bark. If Time is not within half a frame width of any frame centre, or If the specified Formant number is greater than the number of formants in the frame, the return value is undefined; otherwise, the formant is considered to belong to the frame whose centre is nearest to the specified time. Algorithm If possible (i.e. if the adjacent frame has enough formants), a linear interpolation is performed between the centre of the frame and the centre of the adjacent frame. With Bark units, the hertz-to-Bark transformation is performed on the two frequencies F ± 1/2 B (after interpolation), and the result is the difference between these two values 
Formant__Get_maximum___	Formant: Get maximum... A query to ask the selected Formant object for the maximum value of the specified formant. Return value the maximum, in hertz or Bark. Settings Formant number the ordinal number of the formant, counting up from 0 Hz. Specify 2 for F2 etc. From time (s) To time (s) the selected time domain. Values outside this domain are ignored. If To time is not greater than From time, the entire time domain of the formant contour is considered. Units the units of the result (Hertz or Bark). Interpolation the interpolation method (None or Parabolic). See vector peak interpolation. 
Formant__Get_mean___	Formant: Get mean... A query to ask the selected Formant object for the mean value of the specified formant. Return value the mean, in hertz or Bark. Settings Formant number the ordinal number of the formant, counting up from 0 Hz. Specify 2 for F2 etc. From time (s) To time (s) the selected time domain. Values outside this domain are ignored. If To time is not greater than From time, the entire time domain of the formant contour is considered. Units the units of the result (Hertz or Bark). Scripting You can use this command to put the mean into a script variable: selectObject: Formant hallo mean = Get mean: 2, 0, 0, Hertz In this case, the value will not be written into the Info window. 
Formant__Get_minimum___	Formant: Get minimum... A query to ask the selected Formant object for the minimum value of the specified formant. Return value the minimum, in hertz or Bark. Settings Formant number the ordinal number of the formant, counting up from 0 Hz. Specify 2 for F2 etc. From time (s) To time (s) the selected time domain. Values outside this domain are ignored. If To time is not greater than From time, the entire time domain of the formant contour is considered. Units the units of the result (Hertz or Bark). Interpolation the interpolation method (None or Parabolic). See vector peak interpolation. 
Formant__Get_number_of_formants	Formant: Get number of formants A query to ask the selected Formant object for the number of formants in a specified frame. Setting Frame number the frame number whose formant count is sought. Return value the number of formants. 
Formant__Get_quantile___	Formant: Get quantile... A query to ask the selected Formant object for an estimation of the specified quantile of the distribution that underlies the attested values of the specified formant. Return value the quantile, in hertz or Bark. Settings Formant number the ordinal number of the formant, counting up from 0 Hz. Specify 2 for F2 etc. From time (s) To time (s) the selected time domain. Values outside this domain are ignored. If To time is not greater than From time, the entire time domain of the formant contour is considered. Units the units of the result (Hertz or Bark). Quantile the fraction (between 0 and 1) of the values of the underlying distribution expected to lie below the result. For instance, if Quantile is 0.10, the algorithm estimates the formant value below which 10% of all formant values are expected to lie. To get an estimate of the median of the underlying distribution, specify a quantile of 0.50. Algorithm First, the available formant values within the selected time domain are collected in an array. This array is then sorted and the quantile algorithm is performed. With Bark units, the hertz-to-Bark transformation is performed before the quantile algorithm. 
Formant__Get_standard_deviation	Formant: Get standard deviation A query to ask the selected Formant object for the standard deviation of the attested values of the specified formant within a specified time domain. Return value the standard deviation, in hertz or Bark. Settings Formant number the ordinal number of the formant, counting up from 0 Hz. Specify 2 for F2 etc. From time (s) To time (s) the selected time domain. Values outside this domain are ignored. If To time is not greater than From time, the entire time domain of the formant contour is considered. Units the units of the result (Hertz or Bark). 
Formant__Get_time_of_maximum___	Formant: Get time of maximum... A query to ask the selected Formant object for the time associated with the maximum value of a specified formant within a specified time domain. Settings Formant number the ordinal number of the formant, counting up from 0 Hz. Specify 2 for F2 etc. From time (s) To time (s) the selected time domain. Values outside this domain are ignored, except for interpolation. If To time is not greater than From time, the entire time domain of the formant contour is considered. Units the units of the result (Hertz or Bark). Interpolation the interpolation method (None or Parabolic). See vector peak interpolation. Return value the time expressed in seconds. If no relevant formants are found, the value is undefined. 
Formant__Get_time_of_minimum___	Formant: Get time of minimum... A query to ask the selected Formant object for the time associated with the minimum value of a specified formant within a specified time domain. Settings Formant number the ordinal number of the formant, counting up from 0 Hz. Specify 2 for F2 etc. From time (s) To time (s) the selected time domain. Values outside this domain are ignored, except for interpolation. If To time is not greater than From time, the entire time domain of the formant contour is considered. Units the units of the result (Hertz or Bark). Interpolation the interpolation method (None or Parabolic). See vector peak interpolation. Return value the time expressed in seconds. If no relevant formants are found, the value is undefined. 
Formant__Get_value_at_time___	Formant: Get value at time... A query to ask the selected Formant object for the frequency of the specified formant at the specified time. Settings Formant number the ordinal number of the formant, counting up from 0 Hz. Specify 2 for F2 etc. Time (s) the time at which to evaluate the formant frequency. Units) the units of the result (Hertz or Bark). Interpolation the interpolation method, see vector value interpolation. Always Linear. Return value the bandwidth in hertz or Bark. If Time is not within half a frame width of any frame centre, or if Formant number is greater than the number of formants in the frame, the value is undefined; otherwise, the formant is considered to belong to the frame whose centre is nearest to Time. Algorithm If possible (i.e. if the adjacent frame has enough formants), a linear interpolation is performed between the centre of the frame and the centre of the adjacent frame. With Bark units, the hertz-to-Bark transformation is performed before interpolation. 
Formant__Speckle___	Formant: Speckle... A command to draw the selected Formant objects to the Picture window. Behaviour Every formant value is drawn as a small circle, filled with the current colour. Settings From time (s) To time (s) the time domain of the drawing. If To time is not greater than From time, the entire formant contour is drawn. Maximum frequency (Hz) the height of the y axis. For speech, 5000 Hz is a usual value. Dynamic range (dB) determines the signal intensity (as stored in each formant frame) below which no formants will be drawn. If zero, all formants will be drawn. The standard value is 30 dB, which would mean that formants in frames with intensities less than the maximum intensity minus 30 dB will not be drawn. Garnish determines whether axes, numbers, and texts (Time, Formant frequency) will be drawn in the margins around the picture. Turn this button off if you prefer to garnish your picture by yourself with the Margins menu. Links to this page Formant: Draw tracks... Source-filter synthesis 4. Using existing sounds 
Formant__Track___	Formant: Track... A command to extract a specified number of formant tracks from each selected Formant object. The tracks represent the cheapest paths through the measured formant values in consecutive frames. How to use In order to be capable of producing three tracks (i.e. F1, F2, and F3), there must be at least three formant candidates in every frame of the Formant object. The typical use of this command, therefore, is to analyse five formants with Sound: To Formant (burg)... and then use the tracking command to extract three tracks. When to use, when not This command only makes sense if the whole of the formant contour makes sense. For speech, formant contours make sense only for vowels and the like. During some consonants, the Formant object may have fewer than three formant values, and trying to create three tracks through them will fail. You will typically use this command for the contours in diphthongs, if at all. Settings To be able to interpret the settings, you should know that the aim of the procedure is to minimize the sum of the costs associated with the three tracks. Number of tracks the number of formant tracks that the procedure must find. If this number is 3, the procedure will try to find tracks for F1, F2, and F3; if the Formant object contains a frame with less than three formants, the tracking procedure will fail. Reference F1 (Hz) the preferred value near which the first track wants to be. For average (i.e. adult female) speakers, this value will be around the average F1 for vowels of female speakers, i.e. 550 Hz. Reference F2 (Hz) the preferred value near which the second track wants to be. A good value will be around the average F2 for vowels of female speakers, i.e. 1650 Hz. Reference F3 (Hz) the preferred value near which the third track wants to be. A good value will be around the average F3 for vowels of female speakers, i.e. 2750 Hz. This argument will be ignored if you choose to have fewer than three tracks, i.e., if you are only interested in F1 and F2. Reference F4 (Hz) the preferred value near which the fourth track wants to be. A good value may be around 3850 Hz, but you will usually not want to track F4, because traditional formant lore tends to ignore it (however inappropriate this may be for the vowel [i]), and because Formant objects often contain not more than three formant values in some frames. So you will not usually specify a higher Number of tracks than 3, and in that case, this argument will be ignored. Reference F5 (Hz) the preferred value near which the five track wants to be. In the unlikely case that you want five tracks, a good value may be around 4950 Hz. Frequency cost (per kiloHertz) the local cost of having a formant value in your track that deviates from the reference value. For instance, if a candidate (i.e. any formant in a frame of the Formant object) has a formant frequency of 800 Hz, and Frequency cost is 1.0/kHz, the cost of putting this formant in the first track is 0.250, because the distance to the reference F1 of 550 Hz is 250 Hz. The cost of putting the formant in the second track would be 0.850 (= (1.650 kHz - 0.600 kHz) · 1.0/kHz), so we see that the procedure locally favours the inclusion of the 800 Hz candidate into the F1 track. But the next two cost factors may override this local preference. Bandwidth cost the local cost of having a bandwidth, relative to the formant frequency. For instance, if a candidate has a formant frequency of 400 Hz and a bandwidth of 80 Hz, and Bandwidth cost is 1.0, the cost of having this formant in any track is (80/400) · 1.0 = 0.200. So we see that the procedure locally favours the inclusion of candidates with low relative bandwidths. Transition cost (per octave) the cost of having two different consecutive formant values in a track. For instance, if a proposed track through the candidates has two consecutive formant values of 300 Hz and 424 Hz, and Transition cost is 1.0/octave, the cost of having this large frequency jump is (0.5 octave) · (1.0/octave) = 0.500. Algorithm This command uses a Viterbi algorithm with multiple planes. For instance, if the selected Formant object contains up to five formants per frame, and you request three tracks, the Viterbi algorithm will have to choose between ten candidates (the number of combinations of three out of five) for each frame. The formula for the cost of e.g. track 3, with proposed values F2i (i = 1...N, where N is the number of frames) is: ∑i=1..N frequencyCost·|F3i – referenceF3|/1000 + + ∑i=1..N bandWidthCost·B3i/F3i + + ∑i=1..N-1 transitionCost·|log2(F3i/F3,i+1)| Analogous formulas compute the cost of track 1 and track 2. The procedure will assign those candidates to the three tracks that minimize the sum of three track costs. Links to this page Formant: Draw tracks... 
FormantFilter	FormantFilter One of the types of objects in PRAAT. An object of type FormantFilter represents an acoustic time-frequency representation of a sound: the power spectral density P(f, t), expressed in dB's. It is sampled into a number of points around equally spaced times ti and frequencies fj (on a linear frequency scale). Inside a FormantFilter With Inspect you will see that this type contains the same attributes a Matrix. Links to this page Sound & Pitch: To FormantFilter... Sound: To FormantFilter... What was new in 4.0? 
FormantGrid	FormantGrid One of the types of objects in Praat. A FormantGrid object represents spectral structure as a function of time: a formant contour. Unlike the evenly sampled Formant object, it consists of a number of formant tiers and bandwidth tiers, each of which contains a number of formant or bandwidth points (or targets), sorted by time. For examples, see Source-filter synthesis. FormantGrid commands Creation: From scratch: • Create FormantGrid... • FormantGrid: Add formant point... • FormantGrid: Add bandwidth point... Copy from another object: • Formant: Down to FormantGrid: trivial copying of frames to points. Synthesis: • Sound & FormantGrid: Filter: see Source-filter synthesis. Modification: • FormantGrid: Add formant point... • FormantGrid: Add bandwidth point... • FormantGrid: Remove formant points between... • FormantGrid: Remove bandwidth points between... Links to this page constant extrapolation KlattGrid linear interpolation Sound & FormantGrid: Filter (no scale) Sound: To KlattGrid (simple)... Source-filter synthesis 2. Filtering a source Source-filter synthesis 4. Using existing sounds What was new in 5.1? 
FormantGrid__Add_bandwidth_point___	FormantGrid: Add bandwidth point... A command to add a bandwidth point to each selected FormantGrid. For examples, see Source-filter synthesis. Settings Formant number the number of the formant (e.g. 1, 2,...) to which a bandwidth point is to be added. Time (s) the time at which a bandwidth point is to be added. Bandwidth (Hz) the bandwidth value of the requested new point. Example To set the bandwidth of F2 at 0.3 seconds to 130 Hz, you set Formant number to 2, Time to 0.3 s, and Bandwidth to 130 Hz. Behaviour The formant tier is modified so that it contains the new point. If a bandwidth point at the specified time was already present in the formant tier, nothing happens. Links to this page Create FormantGrid... Source-filter synthesis 4. Using existing sounds 
FormantGrid__Add_formant_point___	FormantGrid: Add formant point... A command to add a formant point to each selected FormantGrid. For examples, see Source-filter synthesis. Settings Formant number the number of the formant (e.g. 1, 2,...) to which a formant point is to be added. Time (s) the time at which a formant point is to be added. Frequency (Hz) the formant frequency value of the requested new point. Example To set the value of F2 at 0.3 seconds to 2200 Hz, you set Formant number to 2, Time to 0.3 s, and Frequency to 2200 Hz. Behaviour The formant tier is modified so that it contains the new point. If a formant point at the specified time was already present in the formant tier, nothing happens. Links to this page Create FormantGrid... Source-filter synthesis 2. Filtering a source Source-filter synthesis 4. Using existing sounds 
FormantGrid__Remove_bandwidth_points_between___	FormantGrid: Remove bandwidth points between... A command to remove some points from a bandwidth tier in every selected FormantGrid. Settings Formant number the formant (1, 2,...) from whose bandwidth tier you want to remove some points. From time (s)) To time (s) the times between which you want to remove all bandwidth points. Example If you want to remove all bandwidth points in F2 between 0.5 and 0.7 seconds, you set Formant number to 2, From time to 0.5 s, and To time to 0.7 s. Links to this page Source-filter synthesis 4. Using existing sounds 
FormantGrid__Remove_formant_points_between___	FormantGrid: Remove formant points between... A command to remove some points from a formant tier in every selected FormantGrid. Settings Formant number the formant (1, 2,...) from which you want to remove some points. From time (s)) To time (s) the times between which you want to remove all formant points. Example If you want to remove all formant points in F2 between 0.5 and 0.7 seconds, you set Formant number to 2, From time to 0.5 s, and To time to 0.7. Links to this page Source-filter synthesis 4. Using existing sounds 
FormantModeler__Get_residual_sum_of_squares___	FormantModeler: Get residual sum of squares... Get the residual sum of squares for a formant in the selected FormantModeler. The residual sum of squares, RSS, is defined as follows RSS = ∑i=1n (fi - Fi)2, where fi is the frequency value of the i-ith data point, Fi is the frequency at the i-data point as estimated by the model and n is the number of data points. 
Formants___LPC_menu	Formants & LPC menu A menu that occurs in the Dynamic menu for a Sound. This menu contains commands for analysing the formant contours of the selected Sound: Sound: To Formant (burg)... Sound: To Formant (keep all)... Sound: To Formant (sl)... Sound: To LPC (autocorrelation)... Sound: To LPC (covariance)... Sound: To LPC (burg)... Sound: To LPC (marple)... Sound: To MFCC... Links to this page Intro 5.4. The Formant object 
Formants__Extract_smoothest_part___	Formants: Extract smoothest part... Extracts the part from one of the selected formants which shows the smoothest formant tracks in a given interval. Settings Time range (s) determines the position of the intervals that have to be compared. Fitter formant range determines which formant tracks will be modelled with a polynomial function. The goodness of fit of these models will be used in the comparison. Order of polynomials determines the maximum order of the polynomials that are used in modeling each formant track. Order 0 means a model which is a constant function; this model needs only one parameter. Order 1 means a model that is a straight line function; this order needs two parameters. Order 2 means that an additional parabolic function is used in the modeling; order 2 needs therefore 3 parameters. In general an order p model needs p+1 parameters. Use bandwidths to model formant tracks Bandwidths give an indication about the sharpness of a spectral peak. Sharp peaks have small bandwidths and, vice versa, broad peaks have large bandwidths. The width of a peak can also be interpreted as a measure of certainty for its formant frequency value. Setting this option on, the default setting, means that you force the modeling function to be closer to frequencies that are well defined, i.e. that have sharp peaks, than to the frequencies of broad peaks, if choices have to be made. The consequence is that in the model sharp peaks will be better represented than broad peaks. Bandwidths for smoothing test determines whether for the smoothnes determination the formant frequencies are still needed. Not using them anymore probably gives a better indication of the smoothness of a track. 
Formants__Extract_smoothest_part__constrained____	Formants: Extract smoothest part (constrained)... Extracts the best matching part from the slected Formants. Settings Minimum F1 (Hz) suppresses models whose average first formant frequency, f1, is below minimumF1 by a factor sqrt (minimumF1 - f1 + 1). You can use this constraint to disfavour models with a low average first formant. Sometimes due to the generally high frequency of the /a/ a lower harmonic of the fundamental frequency is taken as a candidate for the first formant. You can suppress these models with this constraint. Maximum F1 (Hz) suppresses models whose average first formant frequency, f1, is above maximumF1 by a factor sqrt (f1 - maximumF1 + 1).You can use this constraint to disfavour models in which the first formant is missing. Minimum F2 (Hz) suppresses models whose average second formant frequency, f2, is below minimumF2 by a factor sqrt (minimumF2 - f2 + 1). This constraint might be used for high front vowels that normally have a large distance between the first and second formant. Maximum F2 (Hz) suppresses models whose average second formant frequency, f2, is above maximumF2 by a factor sqrt (f2 - maximumF2 + 1). This factor is sometimes necessary to suppress models for high back vowels where the second formant is missing, i.e. where the third formant is playing the role of the second. Minimum F3 (Hz) suppress models whose average third formant frequency, f3, is below minimumF3 by a factor sqrt (minimumF3 - f3 + 1). This constraint might sometimes be usefull to suppress low lying third formants that can occur for /a/-like vowels. 
Formula___	Formula... See Matrix: Formula... Links to this page Dissimilarity Formulas Spectrum 
Formulas	Formulas You can use numeric expressions and string (text) expressions in many places in Praat: in the calculator in Praat's Goodies submenu; in the numeric fields of most settings windows; in a Praat script. For some types of objects (mainly Sound and Matrix), you can also apply formulas to all their contents at the same time: when you create a Sound or a Matrix from the New menu; when you choose Formula... from the Modify menu for a selected object. You can read this tutorial sequentially with the help of the < 1 and 1 > buttons. 1. My first formulas (where to use) 1.1. Formulas in the calculator 1.2. Numeric expressions 1.3. String expressions 1.4. Representation of numbers 1.5. Representation of strings 1.6. Formulas in settings windows 1.7. Formulas for creation 1.8. Formulas for modification 1.9. Formulas in scripts 2. Operators (+, -, *, /, ^) 3. Constants (pi, e, undefined) 4. Mathematical functions 5. String functions 6. Control structures (if then else fi, semicolon) 7. Attributes of objects 8. Data in objects Links to this page Acknowledgments binomialQ Cochleagram: Formula... Create Configuration... Create Sound from formula... Excitation: Formula... Harmonicity: Formula... Matrix: Formula... Scripting 5.2. Expressions Sound: Formula... Spectrogram: Formula... Spectrum: Formula... VocalTract: Formula... What was new in 4.1? 
Formulas_1_1__Formulas_in_the_calculator	Formulas 1.1. Formulas in the calculator To use the Praat calculator, go to the Praat menu and choose Calculator... from the Goodies submenu. Or simply type Command-U anywhere in Praat. Calculating numbers You can do arithmetic computations. Type the formula 8*17 and click OK. The Info window will pop up and show the result: 136 Calculating strings You can also do text computations. Type the formula see + king and click OK. The Info window will show the result: seeking Links to this page Formulas Formulas 1. My first formulas 
Formulas_1_2__Numeric_expressions	Formulas 1.2. Numeric expressions All the formulas whose outcome is a number are called numeric expressions. For the following examples, all the outcomes can be checked with the calculator. Examples with numbers Some numeric expressions involve numbers only: 8*17 computes a multiplication. Outcome: 136. 2^10 computes the tenth power of 2. Outcome: 1024. sqrt (2) / 2 computes the square root of 2, and divides the result by 2. Outcome: 0.7071067811865476. sin (1/4 * pi) computes the sine of π/4. Outcome: 0.7071067811865476 (again). Examples with strings Some numeric expressions compute numeric properties of strings: length (internationalization) computes the length of the string internationalization. Outcome: 20. index (internationalization, ation) computes the location of the first occurrence of the string ation in the string internationalization. Outcome: 7, because the first letter of ation lines up with the seventh letter of internationalization. If the substring does not occur, the outcome is 0. Links to this page Formulas Formulas 1. My first formulas 
Formulas_1_3__String_expressions	Formulas 1.3. String expressions All the formulas whose outcome is a text string are called string expressions. Again, the outcomes of the following examples can be checked with the calculator. see + king concatenates two strings. Outcome: seeking. left$ (internationalization, 6) computes the leftmost six letters of the string; the dollar sign is used for all functions whose result is a string. Outcome: intern. mid$ (internationalization, 6, 8) computes the 8-letter substring that starts at the sixth letter of internationalization. Outcome: national. date$ ( ) computes the current date and time. Outcome at the time I am writing this: Mon Dec 2 02:23:45 2002. Links to this page Formulas Formulas 1. My first formulas 
Formulas_1_4__Representation_of_numbers	Formulas 1.4. Representation of numbers Formulas can work with integer numbers as well as with real numbers. Real numbers You can type many real numbers by using a decimal notation, for instance 3.14159, 299792.5, or -0.000123456789. For very large or small numbers, you can use the e-notation: 6.022·1023 is typed as 6.022e23 or 6.022e+23, and -1.6021917·10-19 is typed as -1.6021917e-19. You can use also use the percent notation: 0.157 can be typed as 15.7%. There are some limitations as to the values that real numbers can have in Praat. The numbers must lie between -10308 and +10308. If you type 1e200 * 1e100 the outcome will be 1e+300 but if you type 1e300 * 1e100 the outcome will be --undefined-- Another limitation is that the smallest non-zero numbers lie near -10-308 and +10-308. If you type 1e-200 / 1e100 the outcome will be 1e-300 but if you type 1e-300 / 1e100 the outcome will be 0 Finally, the precision of real numbers is limited by the number of bits that every real number is stored with in the computer, namely 64. For instance, if you type pi the outcome will be 3.141592653589793 because only 16 digits of precision are stored. This can lead to unexpected results caused by rounding. For instance, the formula 0.34999999999999999 - 0.35 will result in 0 rather than the correct value of 1e-17. This is because the numbers 0.34999999999999999 and 0.35 cannot be distinguished in the computer's memory. If you simply type 0.34999999999999999 the outcome will be 0.35 (as in this example, the calculator will always come up with the minimum number of digits needed to represent the number unambiguously). Another example of inaccuracy is the formula 1 / 7 / 59 * 413 Because of rounding errors, the result will be 0.9999999999999999 Integer numbers Formulas can work with integer (whole) numbers between -1,000,000,000,000,000 and +1,000,000,000,000,000. You type them without commas and without the plus sign: 337, -848947328345289. You can work with larger numbers than that (up to 10308), but there will again be rounding errors. For instance, the formula 1000000000000000 + 1 correctly yields 1000000000000001 but the formula 10000000000000000 + 1 yields an incorrect outcome: 1e16 Links to this page Formulas Formulas 1. My first formulas 
Formulas_1_5__Representation_of_strings	Formulas 1.5. Representation of strings Formulas can work with strings that are put between two double quotes, as in goodbye or how are you doing?. If a string has to contain a double quote, you have to type it twice. For instance, if you type I asked: how are you doing? into the calculator, the outcome will be I asked: how are you doing? Links to this page Formulas Formulas 1. My first formulas 
Formulas_1_6__Formulas_in_settings_windows	Formulas 1.6. Formulas in settings windows Into numeric fields in settings windows you usually simply type a number. However, you can use any numeric expression instead. For instance, suppose you want to create a Sound that contains exactly 10000 samples. If the sampling frequency is 44100 Hz, the duration will be 10000/44100 seconds. You can create such a Sound by choosing Create Sound from formula... from the New menu, then typing 10000/44100 into the End time field. Into text fields in settings windows, you can only type text directly; there is no way to use string expressions (except if you use scripts; see Formulas 1.9. Formulas in scripts). Links to this page Formulas Formulas 1. My first formulas 
Formulas_1_7__Formulas_for_creation	Formulas 1.7. Formulas for creation With some commands in the New menu, you can supply a formula that Praat will apply to all elements of the new object. Creating a Sound from a formula Choose Create Sound from formula... and type the following into the Formula field: 1/2 * sin (2 * pi * 377 * x) When you click OK, a new Sound object will appear in the list. After you click View & Edit and zoom in a couple of times, you will see that the sound is a sine wave with a frequency of 377 hertz (cycles per second). This worked because the x in the formula represents the time, i.e. the formula was applied to every sample separately, with a different value of x for each sample. Creating a Matrix from a formula Choose Create simple Matrix... and type the following into the Formula field: 8 When you click OK, a new Matrix object will appear in the list. When you click Info, you will see that it is a matrix with 10 rows and 10 columns, and that all the 100 cells contain the value 8 (you can see this because both the minimum and the maximum are reported as being 8). A more interesting example is the formula row * col For the resulting Matrix, choose Paint cells... and click OK. The Picture window will show a 10×10 matrix whose elements are the product of the row and column numbers, i.e., they have values between 1 and 100. Beside row and col, you can use x for the distance along the horizontal axis and y for the distance along the vertical axis; see the following page for examples. Links to this page Formulas Formulas 1. My first formulas 
Formulas_1_8__Formulas_for_modification	Formulas 1.8. Formulas for modification Analogously to the formulas that you can use for creating new objects (see the previous page), you can use formulas for modifying existing objects. You do this with the command Formula... that you can find in the Modify menu when you select an object. Modifying a Sound with a formula Record a sound with your microphone and talk very lowly. If you don't know how to record a sound in Praat, consult the Intro. Once the Sound objetc is in the list, click Play. The result will sound very soft. Then choose Formula... from the Modify menu and type self * 3 Click OK, then click Play again. The sound is much louder now. You have multiplied the amplitude of every sample in the sound with a factor of 3. Replacing the contents of a Sound with a formula If you don't use self in your formula, the formula does not refer to the existing contents of the Sound. Hence, the formula 1/2 * sin (2 * pi * 377 * x) will simply replace your recorded speech with a 377-Hz sine wave. Modifying a Matrix with a formula Many objects can be thought of as matrices: they consist of a number of rows and columns with data in every cell: Sound: one row; columns represent samples. Spectrum: two rows (first row is real part, second row is imaginary part); columns represent frequencies. Spectrogram, Cochleagram: rows represent frequencies; columns represent times. Excitation: one row; columns represent frequency bands. Harmonicity: one row; columns represent time frames. The formula is performed on every column of every row. The formula self^2 will square all matrix elements. The formula first works on the first row, and in that row from the first column on; this can work recursively. The formula self + self [row, col - 1] integrates each row. Referring to the current position in the object You can refer to the current position in a Matrix (or Sound, etc.) by index or by x and y values: row the current row col the current column x the x value associated with the current column: for a Sound, Spectrogram, Cochleagram, or Harmonicity: time for a Spectrum: frequency (Hz) for an Excitation: frequency (Bark) y the y value associated with the current row: for a Spectrogram: frequency (Hz) for a Cochleagram: frequency (Bark) Referring to the contents of the object itself You can refer to values in the current Matrix (or Sound, etc.) by index. self refers to the value in the current Matrix at the current row and column, or to the value in the current Sound at the current sample. self [column-expression] refers to the value in the current Sound (or Intensity etc.) at the current sample (or frame). The column-expression is rounded to the nearest integer. If the index is out of range (less than 1 or greater than nx), the expression evaluates as 0. Example. An integrator is self [col - 1] + self * dx self [row-expression, column-expression] refers to the value in the current Matrix (or Spectrogram etc.) at the specified row and column. The expressions are rounded to the nearest integers. You can refer to values in the current Matrix (or Spectrogram, etc.) by x and y position: • self (x-expression, y-expression) the expressions are linearly interpolated between the four nearest matrix points. You can refer to values in the current Sound (or Intensity etc.) by x position: • self (x-expression) the expression is linearly interpolated between the two nearest samples (or frames). Links to this page Formulas Formulas 1. My first formulas Formulas 1.9. Formulas in scripts 
Formulas_1_9__Formulas_in_scripts	Formulas 1.9. Formulas in scripts In scripts, you can assign numeric expressions to numeric variables, and string expressions to string variables. You can also use numeric and string variables in expressions. Example: report a square Choose New Praat script from the Praat menu. A script editor window will become visible. Type the following lines into that window: x = 99 x2 = x * x writeInfoLine: The square of , x, is , x2, . This is an example of a simple Praat script; it assigns the results of the numeric formulas 99 and x * x to the numeric variables x and x2. Note that the formula x * x itself refers to the variable x. To run (execute) this script, type Command-R or choose Run from the Run menu. Praat will then write the following text into the Info window: The square of 99 is 9801. For more information on scripts, see the Scripting tutorial. Example: rename the city of Washington Type the following text into the script editor window: current$ = Bush previous$ = Clinton famous$ = Lincoln newCapital$ = current$ + mid$ (famous$, 2, 3) + right$ (previous$, 3) writeInfoLine: The new capital will be , newCapital$, . This script assigns the results of four string expressions to the four string variables current$, previous$, famous$, and newCapital$. The dollar sign is the notation for a string variable or for a function whose result is a string (like left$). Note that the formula in the fourth line refers to three existing variables. To see what the new name of the capital will be, choose Run. Example: numeric expressions in settings in scripts As in real settings windows, you can use numeric expressions in all numeric fields. The example of two pages back becomes: Create Sound from formula: sine, Mono, 0, 10000 / 44100, 44100, 0.9 * sin (2*pi*377*x) Example: string expressions in settings in scripts As in real settings windows, you can use string expressions in all text fields: soundName$ = hello Read from file: soundName$ + .wav Example: numeric expressions in creation in scripts Suppose you want to generate a sine wave whose frequency is held in a variable. This is the way: frequency = 377 Create Sound from formula: sine, Mono, 0, 1, 44100, 0.9 * sin (2*pi*frequency*x) In this example, Praat will protest if x is a variable as well, because that would be ambiguous with the x that refers to the time in the sound (see Formulas 1.8. Formulas for modification). Links to this page Formulas Formulas 1. My first formulas Formulas 1.6. Formulas in settings windows 
Formulas_1__My_first_formulas	Formulas 1. My first formulas 1.1. Formulas in the calculator 1.2. Numeric expressions 1.3. String expressions 1.4. Representation of numbers 1.5. Representation of strings 1.6. Formulas in settings windows 1.7. Formulas for creation 1.8. Formulas for modification 1.9. Formulas in scripts Links to this page Formulas 
Formulas_2__Operators	Formulas 2. Operators In formulas you can use the numerical and logical operators that are described on this page. The order of evaluation of the operators is the order that is most usual in programming languages. To force a different order, you use parentheses. The operators with the highest precedence are negation (-) and exponentation (^): --6 → 6 2^6 → 64 Sequences of negation and exponentiation are evaluated from right to left: 2^-6 → 0.015625 -(1+1)^6 → -64 4^3^2 → 4^9 → 262144 Note that changing the spacing does not change the meaning: 4^3 ^ 2 → 262144 To change the order of evaluation, you have to use parentheses: (4 ^ 3) ^ 2 → 4096 The following construction is not allowed because of an ambiguity between a negative number and negation of a positive number: -2^6 → ? Instead, you use any of the following: (-2)^6 → 64 -(2^6) → -64 -(2)^6 → -64 The operators with the next highest precedence are multiplication (*) and division (/). They are evaluated from left to right: 1/4*5 → 1.25 (from left to right) 1 / 4*5 → 1.25 (spacing does not help) 1 / (4*5) → 0.05 (use parentheses to change the order) 3 * 2 ^ 4 → 48 (exponentiation before multiplication) 3*2 ^ 4 → 48 (this spacing does not matter and is misleading) (3 * 2) ^ 4 → 1296 (use parentheses to change the order) Integer division operators (div and mod) have the same precedence as * and /, and are likewise evaluated from left to right: 54 div 5 → 10 (division rounded down) 54 mod 5 → 4 (the remainder) 54.3 div 5.1 → 10 (works for real numbers as well) 54.3 mod 5.1 → 3.3 (the remainder) -54 div 5 → -11 (division rounded down; negation before division) -54 mod 5 → 1 (the remainder) -(54 div 5) → -10 (use parentheses to change the order) -(54 mod 5) → -4 3 * 18 div 5 → 10 (from left to right) 3 * (18 div 5) → 9 3 * 18 mod 5 → 4 3 * (18 mod 5) → 9 54 div 5 * 3 → 30 (from left to right) 54 div (5 * 3) → 3 54 mod 5 * 3 → 12 54 mod (5 * 3) → 9 The operators with the next highest precedence are addition (+) and subtraction (-), evaluated from left to right: 3 - 8 + 7 → 2 (from left to right) 3 - (8 + 7) → -12 (use parentheses to change the order) 3 + 8 * 7 → 59 (multiplication before addition) (3 + 8) * 7 → 77 (use parentheses to change the order) 3 + - (2 ^ 4) → -13 (exponentiation, negation, addition) 3 + 5 / 2 + 3 → 8.5 (3 + 5) / (2 + 3) → 1.6 The operators with the next highest precedence are the comparison operators (= <> < > <= >=). These operators always yield 0 (false) or 1 (true): 5 + 6 = 10 → 0 (equal) 5 + 6 = 11 → 1 5 + 6 <> 10 → 1 (unequal) 5 + 6 <> 11 → 0 5 + 6 < 10 → 0 (less than) 5 + 6 < 11 → 0 5 + 6 > 10 → 1 (greater than) 5 + 6 > 11 → 0 5 + 6 <= 10 → 0 (less than or equal) 5 + 6 <= 11 → 1 5 + 6 >= 10 → 1 (greater or equal) 5 + 6 >= 11 → 1 The comparison operators are mainly used in if, while, and until conditions. The operators of lowest precedence are the logical operators (not, and, and or), of which not has the highest precedence and or the lowest: not 5 + 6 = 10 → 1 x > 5 and x < 10 (is x between 5 and 10?) not x <= 5 and not x >= 10 (same as previous line) not (x <= 5 or x >= 10) (same as previous line) String comparison a$ = b$ gives the value true (= 1) if the strings are equal, and false (= 0) otherwise. a$ <> b$ gives the value true if the strings are unequal, and false otherwise. a$ < b$ gives true if the string a$ precedes the string b$ in ASCII sorting order. Thus, ha < hal and ha < ja are true, but ha < JA is false, because all capitals precede all lower-case characters in the ASCII sorting order. a$ > b$ true if a$ comes after b$ in ASCII sorting order. a$ <= b$ gives the value true if the string a$ precedes the string b$ in ASCII sorting order, or if the strings are equal. a$ >= b$ true if a$ comes after b$ or the two are equal. String concatenation and truncation a$ + b$ concatenates the two strings. After text$ = hallo + dag The variable text$ contains the string hallodag. a$ - b$ subtracts the second string from the end of the first. After soundFileName$ = hallo.aifc textgridFileName$ = soundFileName$ - .aifc + .TextGrid the variable textgridFileName$ contains the string hallo.TextGrid. If the first string a$ does not end in the string b$, the result of the subtraction is the string a$. Links to this page Formulas 
Formulas_3__Constants	Formulas 3. Constants pi π, 3.14159265358979323846264338328 e e, 2.71828182845904523536028747135 undefined a special value, see undefined Links to this page Formulas 
Formulas_4__Mathematical_functions	Formulas 4. Mathematical functions abs (x) absolute value round (x) nearest integer; round (1.5) = 2 floor (x) round down: highest integer value not greater than x ceiling (x) round up: lowest integer value not less than x sqrt (x) square root: √x, x ≥ 0 min (x, ...) the minimum of a series of numbers, e.g. min (7.2, -5, 3) = -5 max (x, ...) the maximum of a series of numbers, e.g. max (7.2, -5, 3) = 7.2 imin (x, ...) the location of the minimum, e.g. imin (7.2, -5, 3) = 2 imax (x, ...) the location of the maximum, e.g. imax (7.2, -5, 3) = 1 sin (x) sine cos (x) cosine tan (x) tangent arcsin (x) arcsine, -1 ≤ x ≤ 1 arccos (x) arccosine, -1 ≤ x ≤ 1 arctan (x) arctangent arctan2 (y, x) argument angle sinc (x) sinus cardinalis: sin (x) / x sincpi (x) sincπ: sin (πx) / (πx) exp (x) exponentiation: ex; same as e^x ln (x) natural logarithm, base e log10 (x) logarithm, base 10 log2 (x) logarithm, base 2 sinh (x) hyperbolic sine: (ex - e-x) / 2 cosh (x) hyperbolic cosine: (ex + e-x) / 2 tanh (x) hyperbolic tangent: sinh (x) / cosh (x) arcsinh (x) inverse hyperbolic sine: ln (x + √(1+x2)) arccosh (x) inverse hyperbolic cosine: ln (x + √(x2–1)) arctanh (x) inverse hyperbolic tangent sigmoid (x) R → (0,1): 1 / (1 + e–x) or 1 – 1 / (1 + ex) invSigmoid (x) (0,1) → R: ln (x / (1 – x)) erf (x) the error function: 2/√π 0∫x exp(-t2) dt erfc (x) the complement of the error function: 1 - erf (x) randomUniform (min, max) uniform random deviate between min (inclusive) and max (exclusive) randomInteger (min, max) uniform random deviate between min and max (inclusive) randomGauss (μ, σ) Gaussian random deviate with mean μ and standard deviation σ randomPoisson (mean) Poisson random deviate lnGamma (x) logarithm of the Γ function gaussP (z) the area under the Gaussian distribution between –∞ and z gaussQ (z) the area under the Gaussian distribution between z and +∞: the one-tailed statistical significance p of a value that is z standard deviations away from the mean of a Gaussian distribution invGaussQ (q) the value of z for which gaussQ (z) = q chiSquareP (chiSquare, df) the area under the χ2 distribution between 0 and chiSquare, for df degrees of freedom chiSquareQ (chiSquare, df) the area under the χ2 distribution between chiSquare and +∞, for df degrees of freedom: the statistical significance p of the χ2 difference between two distributions in df+1 dimensions invChiSquareQ (q, df) the value of χ2 for which chiSquareQ (χ2, df) = q studentP (t, df) the area under the student T-distribution from -∞ to t studentQ (t, df) the area under the student T-distribution from t to +∞ invStudentQ (q, df) the value of t for which studentQ (t, df) = q fisherP (f, df1, df2) the area under Fisher's F-distribution from 0 to f fisherQ (f, df1, df2) the area under Fisher's F-distribution from f to +∞ invFisherQ (q, df1, df2) the value of f for which fisherQ (f, df1, df2) = q binomialP (p, k, n) the probability that in n experiments, an event with probability p will occur at most k times binomialQ (p, k, n) the probability that in n experiments, an event with probability p will occur at least k times; equals 1 - binomialP (p, k - 1, n) invBinomialP (P, k, n) the value of p for which binomialP (p, k, n) = P invBinomialQ (Q, k, n) the value of p for which binomialQ (p, k, n) = Q hertzToBark (x) from acoustic frequency to Bark-rate (perceptual spectral frequency; place on basilar membrane): 7 ln (x/650 + √(1 + (x/650)2)) barkToHertz (x) 650 sinh (x / 7) hertzToMel (x) from acoustic frequency to perceptual pitch: 550 ln (1 + x / 550) melToHertz (x) 550 (exp (x / 550) - 1) hertzToSemitones (x) from acoustic frequency to a logarithmic musical scale, relative to 100 Hz: 12 ln (x / 100) / ln 2 semitonesToHertz (x) 100 exp (x ln 2 / 12) erb (f) the perceptual equivalent rectangular bandwidth (ERB) in hertz, for a specified acoustic frequency (also in hertz): 6.23·10-6 f2 + 0.09339 f + 28.52 hertzToErb (x) from acoustic frequency to ERB-rate: 11.17 ln ((x + 312) / (x + 14680)) + 43 erbToHertz (x) (14680 d - 312) / (1 - d) where d = exp ((x - 43) / 11.17) phonToDifferenceLimens (x) from perceptual loudness (intensity sensation) level in phon, to the number of intensity difference limens above threshold: 30 · ((61/60) x – 1). differenceLimensToPhon (x) the inverse of the previous: ln (1 + x / 30) / ln (61 / 60). beta (x, y) besselI (n, x) besselK (n, x) Links to this page Formulas What was new in 3.7? What was new in 3.9? 
Formulas_5__String_functions	Formulas 5. String functions String functions are functions that either return a text string or have at least one text string as an argument. Since string computations are not very useful in the calculator, in settings windows, or in creation and modification formulas, this page only gives examples of strings in scripts, so that the example may contain string variables. length (a$) gives the length of the string. After string$ = hallo length = length (string$ + dag) the variable length contains the number 8 (by the way, from this example you see that variables can have the same names as functions, without any danger of confusing the interpreter). left$ (a$, n) gives a string consisting of the first n characters of a$. After head$ = left$ (hallo, 3) the variable head$ contains the string hal. right$ (a$, n) gives a string consisting of the last n characters of a$. After english$ = he + right$ (hallo, 3) the variable english$ contains the string hello. mid$ (hello , 3, 2) gives a string consisting of 2 characters from hello, starting at the third character. Outcome: ll. index (a$, b$) gives the index of the first occurrence of the string b$ in the string a$. After where = index (hallo allemaal, al) the variable where contains the number 2, because the first al starts at the second character of the longer string. If the first string does not contain the second string, index returns 0. rindex (a$, b$) gives the index of the last occurrence of the string b$ in the string a$. After where = rindex (hallo allemaal, al) the variable where contains the number 13, because the last al starts at the 13th character. If the first string does not contain the second string, rindex returns 0. startsWith (a$, b$) determines whether the string a$ starts with the string b$. After where = startsWith (internationalization, int) the variable where contains the number 1 (true). endsWith (a$, b$) determines whether the string a$ ends with the string b$. After where = endsWith (internationalization, nation) the variable where contains the number 0 (false). replace$ (a$, b$, c$, n) gives a string that is like a$, but where (at most n) occurrences of b$ are replaced with the string c$. After s$ = replace$ (hello, l, m, 0) the variable s$ contains the string hemmo. After s$ = replace$ (hello, l, m, 1) the variable s$ contains the string hemlo. The number n determines the maximum number of occurrences of b$ that can be replaced. If n is 0, all occurrences are replaced. index_regex (a$, b$) determines where the string a$ first matches the regular expression b$. After where = index_regex (internationalization, a.*n) the variable where contains the number 7. If there is no match, the outcome is 0. rindex_regex (a$, b$) determines where the string a$ last matches the regular expression b$. After where = rindex_regex (internationalization, a.*n) the variable where contains the number 16. If there is no match, the outcome is 0. replace_regex$ (a$, b$, c$, n) gives a string that is like a$, but where (at most n) substrings that match the regular expression b$ are replaced with the expression c$. After s$ = replace_regex$ (hello, ., &&, 0) the variable s$ contains the string hheelllloo. If there is no match, the outcome is the original string a$. After s$ = replace_regex$ (hello, ., &&, 1) the variable s$ contains the string hhello. The number n determines the maximum number of text pieces that can be replaced. If n is 0, all matching text pieces are replaced. string$ (number) formats a number as a string. Thus, string$ (5e6) becomes the string 5000000, and string$ (56%) becomes the string 0.56. fixed$ (number, precision) formats a number as a string with precision digits after the decimal point. Thus, fixed$ (72.65687, 3) becomes the string 72.657, and fixed$ (72.65001, 3) becomes the string 72.650. In these examples, we see that the result can be rounded up and that trailing zeroes are kept. At least one digit of precision is always given, e.g. fixed$ (0.0000157, 3) becomes the string 0.00002. The number 0 always becomes the string 0. percent$ (number, precision) the same as fixed$, but with a percent sign. For instance, percent$(0.157, 3) becomes 15.700%, percent$(0.000157, 3) becomes 0.016%, and percent$ (0.000000157, 3) becomes 0.00002%. The number 0 always becomes the string 0. number (a$) interprets a string as a number. string$ = 5e6 writeInfoLine: 3 + number (string$) the Info window contains the number 500003. date$ ( ) gives the date and time in the following format: Mon Jun 24 17:11:21 2002 To write the day of the month into the Info window, you type: date$ = date$ () day$ = mid$ (date$, 9, 2) writeInfoLine: The month day is , day$, . extractNumber (Type: Sound + newline$ + Name: hello there + newline$ + Size: 44007, Size:) looks for a number after the first occurrence of Size: in the long string. Outcome: 44007. This is useful in scripts that try to get information from long reports, as the following script that runs in the Sound editor window: report$ = Editor info maximumFrequency = extractNumber (report$, Spectrogram window length:) extractWord$ (Type: Sound + newline$ + Name: hello there + newline$ + Size: 44007, Type:) looks for a word without spaces after the first occurrence of Type: in the long string. Outcome: Sound. extractLine$ (Type: Sound + newline$ + Name: hello there + newline$ + Size: 44007, Name: ) looks for the rest of the line (including spaces) after the first occurrence of Name: in the long string. Outcome: hello there. Note how Name: includes a space, so that the `rest of the line' starts with the h. backslashTrigraphsToUnicode$ (x$), unicodeToBackslashTrigraphs$ (x$) converts e.g. \ct to ɔ or the reverse. See Special symbols. Links to this page Formulas What was new in 4.1? What was new in 4.5? 
Formulas_6__Control_structures	Formulas 6. Control structures if ... then ... else ... fi You can use conditional expressions in all formulas. For example, 3 * if 52% * 3809 > 2000 then 5 else 6 fi evaluates to 15. Instead of fi, you can also use endif. Another example: you can clip the absolute amplitude of a Sound to 0.5 by supplying the following formula: if abs(self)>0.5 then if self>0 then 0.5 else -0.5 fi else self fi The semicolon The semicolon ends the evaluation of the formula. This can be convenient if you do not want to overwrite a long formula in your text field: the formula 800;sqrt(2)*sin(2*pi*103*0.5)+10^(-40/20)*randomGauss(0,1) evaluates to 800. Links to this page Formulas 
Formulas_7__Attributes_of_objects	Formulas 7. Attributes of objects You can refer to several attributes of objects that are visible in the List of Objects. To do so, use the type and the name of the object, connected with an underscore. Thus, Sound_hallo refers to an existing Sound object whose name is hallo (if there is more than one such object, it refers to the one that was created last). You can also use the unique ID instead of the name. Thus, Object_113 refers to the 113th object that you created in the list. To refer to an attribute, you use the period ( `.'). Thus, Sound_hallo.nx is the number of samples of Sound_hallo, and 1 / Sound_hallo.dx is the sampling frequency of Sound_hallo. Attributes in the calculator Record a Sound (read the Intro if you do not know how to do that), name it mysound (or anything else), and type the following formula into the calculator: Sound_mysound.nx After you click OK, the Info window will show the number of samples. Since you could have got this result by simply choosing Get number of samples from the Query menu, these attribute tricks are not very useful in the calculator. We will see that they are much more useful in creation and modification formulas and in scripts. List of possible attributes The following attributes are available: xmin the start of the time domain (usually 0) for a Sound, Pitch, Formant, Spectrogram, Intensity, Cochleagram, PointProcess, or Harmonicity object, in seconds; the lowest frequency (always 0) for a Spectrum object, in hertz; the lowest frequency (usually 0) for an Excitation object, in Bark; the left edge of the x domain for a Matrix object. xmax the end of the time domain (usually the duration, if xmin is zero) for a Sound, Pitch, Formant, Spectrogram, Intensity, Cochleagram, PointProcess, or Harmonicity object, in seconds; the highest frequency (Nyquist frequency) for a Spectrum object, e.g. 11025 hertz; the highest frequency for an Excitation object, often 25.6 Bark; the right edge of the x domain for a Matrix object. ncol the number of columns in a Matrix, TableOfReal, or Table object. nrow the number of rows in a Matrix, TableOfReal, or Table object. col$ [i] the name of column i in a TableOfReal or Table object. row$ [i] the name of row i in a TableOfReal object. nx the number of samples in a Sound object; the number of analysis frames in a Pitch, Formant, Spectrogram, Intensity, Cochleagram, or Harmonicity object; the number of frequency bins in a Spectrum or Excitation object; the number of divisions of the x domain for a Matrix object (= ncol). dx the sample period (time distance between consecutive samples) in a Sound object (the inverse of the sampling frequency), in seconds; the time step between consecutive frames in a Pitch, Formant, Spectrogram, Intensity, Cochleagram, or Harmonicity object, in seconds; the width of a frequency bin in a Spectrum object, in hertz; the width of a frequency bin in an Excitation object, in Bark; the horizontal distance between cells in a Matrix object. ymin the lowest frequency (usually 0) for a Spectrogram object, in hertz; the lowest frequency (usually 0) for a Cochleagram object, in Bark; the bottom of the y domain for a Matrix object. ymax the highest frequency for a Spectrogram object, e.g. 5000 hertz; the highest frequency for a Cochleagram object, often 25.6 Bark; the top of the y domain for a Matrix object. ny the number of frequency bands in a Spectrogram or Cochleagram object; for a Spectrum object: always 2 (first row is real part, second row is imaginary part) the number of divisions of the y domain for a Matrix object (= nrow). dy the distance between adjacent frequency bands in a Spectrogram object, in hertz; the distance between adjacent frequency bands in a Cochleagram object, in hertz; the vertical distance between cells in a Matrix object. Attributes in a creation formula In formulas for creating a new object, you can refer to the attributes of any object, but you will often want to refer to the attributes of the object that is just being created. You can do that in two ways. The first way is to use the name of the object, as above. Choose Create Sound from formula..., supply hello for its name, supply arbitrary values for the starting and finishing time, and type the following formula: (x - Sound_hello.xmin) / (Sound_hello.xmax - Sound_hello.xmin) When you edit this sound, you can see that it creates a straight line that rises from 0 to 1 within the time domain. The formula above will also work if the Sound under creation is called goodbye, and a Sound called hello already exists; of course, in such a case Sound_hello.xmax refers to a property of the already existing sound. If a formula refers to an object under creation, there is a shorter way: you do not have to supply the name of the object at all, so you can simply write (x - xmin) / (xmax - xmin) The attributes that you can use in this implicit way are xmin, xmax, ncol, nrow, nx, dx, ny, and dy. To disambiguate in case there exists a script variable xmin as well, you can write Self.xmin. Attributes in a modification formula In formulas for modifying an existing object, you refer to attributes in the same way as in creation formulas, i.e., you do not have to specify the name of the object that is being modified. The formula self * 20 ^ (- (x - xmin) / (xmax - xmin)) causes the sound to decay exponentially in such a way that it has only 5 percent of its initial amplitude at the end. If you apply this formula to multiple Sound objects at the same time, xmax will refer to the finishing time of each Sound separately as it is modified. To disambiguate in case there exists a script variable xmin as well, you can write Self.xmin. More examples of the use of attributes are on the next page. Links to this page Formulas What was new in 4.5? 
Formulas_8__Data_in_objects	Formulas 8. Data in objects With square brackets, you can get the values inside some objects. Object contents in the calculator The outcomes of the following examples can be checked with the calculator. Matrix_hello [10, 3] gives the value in the cell at the third column of the 10th row of the Matrix called hello. Sound_hello [0, 10000] gives the value (in Pa) of the 1000th sample of the Sound hello, averaged over the channels. Sound_hello [1, 10000] gives the value (in Pa) of the 1000th sample of the left channel of the Sound hello. Sound_hello [2, 10000] gives the value (in Pa) of the 1000th sample of the right channel of the Sound hello. Sound_hello [10000] this can mean various things. In the calculator it means the same as Sound_hello [0, 10000], but in modification formulas it can mean Sound_hello [row, 10000], where row refers to the channel. This variation exists in order to make older Praat scripts (from the time that Praat did not support stereo) compatible with present-day Praat versions; because of possible confusions, the use of Sound_hello [10000] is not recommended. TableOfReal_tokens [5, 12] gives the value in the cell at the fifth row of the 12th column of the TableOfReal called tokens. TableOfReal_tokens [5, F1] gives the value in the cell at the fifth row of the column labelled F1 of the TableOfReal tokens. TableOfReal_tokens [\ct, F1] gives the value in the cell at the row labelled \ct of column F1 of the TableOfReal tokens. Table_listeners [3, m3ae] gives the numeric value in the cell at the third row of column m3ae of the Table listeners. Table_listeners [3, 12] gives the numeric value in the cell at the third row of the 12th column of the Table listeners. Table_results$ [3, response] gives the string value in the cell at the third row of column response of the Table results. Table_results$ [3, 12] gives the string value in the cell at the third row of the 12th column of the Table results. PitchTier_hello [8] gives the pitch (in Hertz) of the 8th point in the PitchTier hello. Cells (or samples, or points) outside the objects are considered to contain zeroes. Interpolation The values inside some objects can be interpolated. Sound_hello (0.7, 0) gives the value (in Pa) at a time of 0.7 seconds in the Sound hello, by linear interpolation between the two samples that are nearest to 0.7 seconds. The channels are averaged. Sound_hello (0.7, 1) gives the interpolated value (in Pa) at a time of 0.7 seconds in the left channel of the Sound hello. Sound_hello (0.7, 2) gives the interpolated value (in Pa) at a time of 0.7 seconds in the right channel of the Sound hello. Sound_hello (0.7) this can mean various things. In the calculator it means the same as Sound_hello (0.7, 0), but in modification formulas it can mean Sound_hello (0.7, row), where row refers to the channel. This variation exists in order to make older Praat scripts (from the time that Praat did not support stereo) compatible with present-day Praat versions; because of possible confusions, the use of Sound_hello (0.7) is not recommended. Spectrogram_hallo (0.7, 2500) gives the value at a time of 0.7 seconds and at a frequency of 2500 Hz in the Spectrogram hallo, by linear interpolation between the four samples that are nearest to that point. PitchTier_hullo (0.7) gives the pitch (in Hertz) at a time of 0.7 seconds in the PitchTier hullo. In the interpolation, times outside the time domain of the objects are considered to contain zeroes (this does not apply to PitchTiers and the like, which undergo constant extrapolation). Object contents in a modification formula Suppose you want to do the difficult way of reversing the contents of a Sound called hello (the easy way is to choose Reverse from the Modify menu). You select this sound, then choose Copy... to duplicate it to a new Sound, which you name hello_reverse. You select this new Sound and choose Formula... from the Modify menu. The formula will be Sound_hello [ncol + 1 - col] From this example, you see that the indices between [ ] may be formulas themselves, and that you can use implicit attributes like ncol and position references like col. An alternative formula is Sound_hello (xmax - x) at least if xmin is zero. The advantage of the second method is that is also works correctly if the two sounds have different sampling frequencies; the disadvantage is that it may do some interpolation between the samples, which deteriorates the sound quality. Object contents in a script In scripts, the indices between [ ] and the values between ( ) may be formulas themselves and contain variables. The following script computes the sum of all the cells along the diagonal of a Matrix named hello. sumDiagonal = 0 for i to Matrix_hello.ncol sumDiagonal += Matrix_hello [i, i] endfor writeInfoLine: The sum of cells along the diagonal is , sumDiagonal, . This example could have been written completely with commands from the dynamic menu: select Matrix hello sumDiagonal = 0 ncol = Get number of columns for i to ncol value = Get value in cell: i, i sumDiagonal += value endfor writeInfoLine: The sum of cells along the diagonal is , sumDiagonal, . The first version, which accesses the contents directly, is not only three lines shorter, but also three times faster. Links to this page Formulas 
frequency	frequency Frequency is how often something happens in a certain time, for instance the number of times the Praat home page www.praat.org is visited every day. In Praat, frequency is the number of vibration cycles per second. Although one can sometimes see the abbreviation cps, Praat always uses Hz (short for hertz), which means the same. Unfortunately, there are two very distinct kinds of vibrations in speech analysis. For pitch, frequency is the number of glottal cycles per second, and for spectral analysis, frequency is the number of sine wave cycles per second. Quite some bit of the training of an acoustic phonetician goes into the understanding of the difference between the ideas behind F0 and F1, and many years can be spent on understanding the influence they have on each other in production, acoustics, perception, or measurement... In order to prevent confusion, Praat always requires frequency to be expressed in Hz. So if you want to supply a sampling frequency of 20 kiloHertz (20 kHz), you fill in 20000 or 2e4 or 20e3. If you want to switch off pre-emphasis in some spectral analysis, you supply 1 GigaHertz (GHz) for its from-frequency, by typing 1e9. In Praat editor windows, frequency usually runs from bottom to top, since time already has to run from left to right. This goes for spectrograms, pitch contours, and formant contours. In spectral slices, frequency runs from left to right, since these have no time axis. Links to this page Intro 3.1. Viewing a spectrogram spectro-temporal representation 
Frequency_selection	Frequency selection The way to select a frequency domain in the SpectrumEditor. This works completely analogously to the time selection in other editors. 
Friedl__1997_	Friedl (1997) J.E.F. Friedl (1997): Mastering Regular Expressions. O'Reilly & Associates. Links to this page Regular expressions 
gammatone	gammatone A gammatone is the product of a rising polynomial, a decaying exponential function, and a cosine wave. It can be described with the following formula: gammaTone (t) = a tγ–1 e–2π·bandwidth·t cos (2π·frequency·t + initialPhase), where γ determines the order of the gammatone. The gammatone function has a monotone carrier (the tone) with an envelope that is a gamma distribution function. The amplitude spectrum is essentially symmetric on a linear frequency scale. This function is used in some time-domain auditory models to simulate the spectral analysis performed by the basilar membrane. It was popularized in auditory modeling by Johannesma (1972). Flanagan (1960) already used it to model basilar membrane motion. Links to this page Create Sound from gammatone... Sound: Filter (gammatone)... 
Ganong__1980_	Ganong (1980) W.F. Ganong III (1980): Phonetic categorization in auditory word perception. Journal of Experimental Psychology: Human Perception and Performance 6: 110–125. Links to this page Table: Line graph where... 
GaussianMixture	GaussianMixture A Gaussian mixture is a probability density function (p.d.f.). It is a combination of several Gaussian densities. The GaussianMixture's p.d.f. is defined as the weighted sum of K multivariate Gaussian p.d.f's: pdf(x) = Σi=1K pi N(x;μi,Σi), where each N(x;μi,Σi) is a multivariate p.d.f. with mean μi and covariance matrix Σi. The coefficients pi sum to 1. For an introduction to Gaussian mixtures see for example Bishop (2006). Links to this page GaussianMixture & PCA: Draw concentration ellipses... GaussianMixture & PCA: To Matrix (density)... GaussianMixture & TableOfReal: Get likelihood value... GaussianMixture & TableOfReal: Improve likelihood... GaussianMixture & TableOfReal: To ClassificationTable GaussianMixture & TableOfReal: To Correlation (columns) GaussianMixture & TableOfReal: To GaussianMixture (CEMM)... GaussianMixture & TableOfReal: To TableOfReal (BHEP normality tests)... GaussianMixture: Draw concentration ellipses... GaussianMixture: Draw marginal pdf... GaussianMixture: Get probability at position GaussianMixture: Split component... GaussianMixture: To Covariance (between) GaussianMixture: To Covariance (total) GaussianMixture: To Covariance (within) GaussianMixture: To PCA GaussianMixture: To TableOfReal (random sampling)... TableOfReal: To GaussianMixture (row labels)... TableOfReal: To GaussianMixture... 
GaussianMixture___PCA__Draw_concentration_ellipses___	GaussianMixture & PCA: Draw concentration ellipses... Draws the concentration ellipse for each component in the GaussianMixture in the plane spanned by the selected PCA. Settings Number of sigmas determines the data coverage. Links to this page GaussianMixture: Draw concentration ellipses... 
GaussianMixture___PCA__To_Matrix__density____	GaussianMixture & PCA: To Matrix (density)... Represent the GaussianMixture p.d.f. on the plane spanned by PCA. This makes it possible to draw the p.d.f. as grey values with one of the special Matrix image drawing methods. For each cell in the matrix of dimension numberOfRows × numberOfColumns, the p.d.f. will be evaluated. 
GaussianMixture___TableOfReal__Get_likelihood_value___	GaussianMixture & TableOfReal: Get likelihood value... Calculates how well the GaussianMixture model fits the data according to a criterion. Settings Maximum likelihood ML = Σi=1..n log (Σm=1..k αk pik) Minimum message length DL = ML - 0.5(N·Σm=1..k log(nαm/12) -k·log(n/12) -k(N+1)) Bayes information BIC = 2·ML - k·N·log(n) Akaike information AIC = 2(ML - k·N) Akaike corrected AICc = 2(ML - k·N·n/(n-k·N-1)) Complete-data ML Σi=1..nΣm=1..k γim log (γim) In the formulas above n is the number of data points, k is the number of mixture components, N is the number of parameters in one component, i.e. d + d(d+1)/2 for a full covariance matrix of dimension d with means. The αk are the mixing probabilities, the pik are the probabilities for the i-th data vector in the k-th component. The γik are defined as γim= αm·pim /(Σj=1..k αj·pij). 
GaussianMixture___TableOfReal__Improve_likelihood___	GaussianMixture & TableOfReal: Improve likelihood... Try to improve the likelihood of the parameters in the GaussianMixture by an expectation-maximization algorithm. Settings & EM Algorithm As decribed in TableOfReal: To GaussianMixture.... 
GaussianMixture___TableOfReal__To_ClassificationTable	GaussianMixture & TableOfReal: To ClassificationTable Create a ClassificationTable from the selected TableOfReal and the GaussianMixture. The classification table is a matrix with the same number of rows as the selected TableOfReal object. The number of columns equals the number of components in the mixture. Cell [i,j] of the classification table contains the probability that the data in row i of the TableOfReal belongs to component j of the mixture. Links to this page GaussianMixture & TableOfReal: To Correlation (columns) 
GaussianMixture___TableOfReal__To_Correlation__columns_	GaussianMixture & TableOfReal: To Correlation (columns) Create a Correlation matrix from the selected TableOfReal and the GaussianMixture. We start by calculating the ClassificationTable from the data and the GaussianMixture. Nex we calculate correlations between the columns of the ClassificationTable: cell [i,j] of the correlation matrix will then contain the value: p[i] · p[j] / (||p[i]||· ||p[j]||), where p[i] is the data in the i-th column of the classification table and ||p[i]|| is its Euclidean norm. The index i runs from 1 to the number of components in the mixture. Because all the elements in a column are positive numbers, i.e. probabilities, all correlations will be positive numbers too. 
GaussianMixture___TableOfReal__To_GaussianMixture__CEMM	GaussianMixture & TableOfReal: To GaussianMixture (CEMM)... Find the best GaussianMixture from the data according to a iterative component-wise optimization algorithm by which components may be deleted. Settings Minimum number of components defines the minimum number of components that have to survive the minimization process. If a value of zero is chosen all components will survive and no deletions will take place. Tolerance of minimizer defines when to stop optimizing. If the relative difference between the likelihoods at two successive iteration steps differs by less then the tolerance we stop, i.e. when |(L(i-1)-L(i))/L(i)| < tolerance. Maximum number of iterations defines another stop criterion. Iteration stops whenever the number of iterations reaches this value. Stability coefficient lambda defines the fraction of the totat covariance that is added to the covariance of each component to prevent these matrices from becoming singular. Criterion based on defines whether the function to be optimized is the log likelihood or the related miminum description length. Algorithm The component-wise optimization algorithm is described in Figueiredo & Jain (2002) where the function to be optimized is the minimum description length defined as: L(θ,Y) = N/2 Σm=1k ln(nαk/12) + k/2 ln(n/12) + k(N+1)/2 - ln p(Y|θ), where k is the number of components, N is the number of parameters of one component, i.e. d+d(d+1)/2 for a full covariance matrix of dimension d with means and d+d for a diagonal matrix with means; n is the number of data vectors. The term ln p(Y|θ) is the log likelihood of the data given the model. For the optimization we either optimize the complete function L(θ,Y) or only the likelihood ln p(Y|θ) term. 
GaussianMixture___TableOfReal__To_TableOfReal__BHEP_nor	GaussianMixture & TableOfReal: To TableOfReal (BHEP normality tests)... Tests the data in the TableOfReal that belong to the components of the GaussianMixture for normality according to an adapted version of the BHEP multivariate normality test. Setting Beta determines the smoothing parameter of the data. If beta equals zero the smoothing is determined automatically for each component of the mixture separately as: beta = 1/(√2) (2p+1)1/(p+4) n1/(p+4), where n is the effective number of elements in the component and p the dimension of the data. 
GaussianMixture__Draw_concentration_ellipses___	GaussianMixture: Draw concentration ellipses... Draws the concentration ellipse for each component in the GaussianMixture. The principal component plane will be determined from GaussianMixture: To PCA. You might also use another PCA and to combine it with a GaussianMixture for drawing (GaussianMixture & PCA: Draw concentration ellipses...). Settings Number of sigmas determines the data coverage. Principal component plane determines whether the principal component plane is used or not for drawing. 
GaussianMixture__Draw_marginal_pdf___	GaussianMixture: Draw marginal pdf... A command to draw the marginal p.d.f. (probability density function) of the selected GaussianMixture. A marginal distribution is the projection of the (multivariate) p.d.f. on one dimension or direction. This direction may also be externally defined by selecting a PCA and a GaussianMixture together. 
GaussianMixture__Get_probability_at_position	GaussianMixture: Get probability at position Evaluate the pdf of the GaussianMixture at the given position. 
GaussianMixture__Split_component___	GaussianMixture: Split component... Splits one component of the selected GaussianMixture into two components. The selected component is split based on a PCA analysis of its covariance matrix. The new means are situated around the old components mean, 1σ apart in the first principal components direction, and the new covariances are constructed with information from the old covariance matrix. The details of the algorith are described in Zhang et al. (2003). 
GaussianMixture__To_Covariance__between_	GaussianMixture: To Covariance (between) The covariance between the centers of the components of the GaussianMixture is calculated; each center is weighted according to its mixing probability. Links to this page GaussianMixture: To Covariance (total) 
GaussianMixture__To_Covariance__total_	GaussianMixture: To Covariance (total) The sum of the within and between covariances of the GaussianMixture is calculated. Links to this page GaussianMixture: To PCA 
GaussianMixture__To_Covariance__within_	GaussianMixture: To Covariance (within) The covariances of the components of the GaussianMixture are pooled. Links to this page GaussianMixture: To Covariance (total) 
GaussianMixture__To_PCA	GaussianMixture: To PCA Creates a PCA from the selected GaussianMixture. The PCA is calculated from the total covariance matrix of the GaussianMixture. Links to this page GaussianMixture: Draw concentration ellipses... 
GaussianMixture__To_TableOfReal__random_sampling____	GaussianMixture: To TableOfReal (random sampling)... The selected GaussianMixture is used as a generator of data. Setting Number of data points determines how many random data point have to be generated. Algorithm For each data point to be generated: 1. A random number decides to which component in the mixture the data point will belong. 2. According to the procedure described in Covariance: To TableOfReal (random sampling)..., one data point will be generated. 
generalized_singular_value_decomposition	generalized singular value decomposition For m > n, the generalized singular value decomposition (gsvd) of an m × n matrix A and a p × n matrix B is given by the pair of factorizations A = U Σ1 [0, R] Q′ and B = V Σ2 [0, R] Q′ The matrices in these factorizations have the following properties: • U [m × m], V [p × p] and Q [n × n] are orthogonal matrices. In the reconstruction formula's above we maximally need only the first n columns of matrices U and V (when m and/or p are greater than n). • R [r × r], is an upper triangular nonsingular matrix. r is the rank of [A′, B′]′ and r ≤ n. The matrix [0, R] is r × n and its first n × (n – r) part is a zero matrix. • Σ1 [m × r] and Σ2 [p × r] are real, nonnegative and diagonal. In practice, the matrices Σ1 and Σ2 are never used. Instead a shorter representation with numbers αi and βi is used. These numbers obey 0 ≤ αi ≤ 1 and αi2 + βi2 = 1. The following relations exist: Σ1′ Σ1 + Σ2′ Σ2 = I, Σ1′ Σ1 = diag (α12, ..., αr2), and, Σ2′ Σ2 = diag (β12, ..., βr2). The ratios αi / βi are called the generalized singular values of the pair A, B. Let l be the rank of B and k + l (= r) the rank of [A′, B′]′. Then the first k generalized singular values are infinite and the remaining l are finite. (When B is of full rank then, of course, k = 0). Special cases • If B is a square nonsingular matrix, the gsvd of A and B is equivalent to the singular value decomposition of A B–1. • The generalized eigenvalues and eigenvectors of A′ A - λ B′ B can be expressed in terms of the gsvd. The columns of the matrix X, constructed as X = Q*( I 0 ) ( 0 inv(R) ), form the eigenvectors. The important eigenvectors, of course, correspond to the positions where the l eigenvalues are not infinite. Links to this page SSCP: To CCA... TableOfReal: To Discriminant 
Get_area___	Get area... A query to the selected tier object (PitchTier, IntensityTier, DurationTier). Return value the area under the curve. Settings From time (s) To time (s) the selected time domain. Values outside this domain are ignored. If To time is not greater than From time, the entire time domain of the tier is considered. Algorithm The curve consists of a sequence of line segments. The contribution of the line segment from (t1, f1) to (t2, f2) to the area is 1/2 (f1 + f2) (t2 – t1) 
Get_first_formant	Get first formant One of the commands in the Query menu of the SoundEditor and the TextGridEditor. Links to this page Intro 5.3. Querying the formant contours 
Get_frame_number_from_time___	Get frame number from time... A command that becomes available in the Query menu if you select a sound-analysis object that is a function of time and that is evenly sampled in time (Pitch, Formant, Intensity, Harmonicity). The Info window will tell you the frame number belonging to the time that you specify. The result is presented as a real number. Setting Time (s) the time (in seconds) for which you want to know the frame number. Example If the Pitch object has a time step of 10 ms, and the first frame is centred around 18 ms, the frame number associated with a time of 0.1 seconds is 9.2. Scripting You can use this command to put the nearest frame centre into a script variable: selectObject: Pitch hallo frame = Get frame from time... 0.1 nearestFrame = round (frame) In this case, the value will not be written into the Info window. To round down or up, use leftFrame = floor (frame) rightFrame = ceiling (frame) Algorithm the result is 1 + (time – t1) / Δt where t1 is the time associated with the centre of the first frame, and Δt is the time step. Details for hackers If you select one of the above objects and click Inspect, you can see how the relation between frame numbers and times is stored in the object: t1 is the x1 attribute, and Δt is the dx attribute. 
Get_high_index_from_time___	Get high index from time... A query to ask the selected tier object (DurationTier, IntensityTier, PitchTier) which point is nearest to, but no earlier than, the specified time. Setting Time (s) the time from which you want to get the point index. Return value This query returns the index of the point with the lowest time greater than or equal to Time. It is undefined if there are no points. It is the number of points plus 1 (offright) if the specified time is greater than the time of the last point. 
Get_low_index_from_time___	Get low index from time... A query to ask the selected tier object (DurationTier, IntensityTier, PitchTier) which point is nearest to, but no later than, the specified time. Setting Time (s) the time from which you want to get the point index. Return value This query returns the index of the point with the highest time less than or equal to Time. It is undefined if there are no points. It is 0 (offleft) if the specified time is less than the time of the first point. 
Get_nearest_index_from_time___	Get nearest index from time... A query to ask the selected tier object (DurationTier, IntensityTier, PitchTier) which point is nearest to the specified time. Setting Time (s) the time near which you want to get the point index. Return value This query returns the index of the point with the highest time less than or equal to Time. It is undefined if there are no points. 
Get_number_of_frames	Get number of frames A command that becomes available in the Query menu if you select a sound-analysis object that is a function of time and that is evenly sampled in time (Pitch, Formant, Intensity, Harmonicity). The Info window will tell you the total number of time frames in the object. Details for hackers If you select one of the above objects and click Inspect, you can see how the number of frames is stored in the object: it is the nx attribute. 
Get_number_of_samples	Get number of samples A command that becomes available in the Query menu if you select a Sound or LongSound object. The Info window will tell you the total number of time samples in this object. Example If the sampling frequency is 44100 hertz, a recording with a duration of 60 seconds will contain 2,646,000 samples. Details for hackers If you select a Sound or LongSound and click Inspect, you can see how the number of samples is stored in the object: it is the nx attribute. 
Get_pitch	Get pitch One of the commands in the Query menu of the SoundEditor and the TextGridEditor. Links to this page Intro 4.3. Querying the pitch contour 
Get_sample_number_from_time___	Get sample number from time... A command that becomes available in the Query menu if you select a Sound or LongSound object. The Info window will tell you the sample number belonging to the time that you specify. The result is presented as a real number. Setting Time (s) the time (in seconds) for which you want to know the sample number. Example If the sound has a sampling frequency of 10 kHz, the sample number associated with a time of 0.1 seconds will usually be 1000.5. Scripting You can use this command to put the nearest sample number into a script variable: selectObject: Sound hallo sampleNumber = Get sample number from time... 0.1 nearestSample = round (sampleNumber) In this case, the value will not be written into the Info window. To round down or up, use leftSample = floor (sampleNumber) rightSample = ceiling (sampleNumber) Algorithm the result is 1 + (time – t1) / Δt where t1 is the time associated with the first sample, and Δt is the sampling period. Details for hackers If you select a Sound or LongSound and click Inspect, you can see how the relation between sample numbers and times is stored in the object: t1 is the x1 attribute, and Δt is the dx attribute. 
Get_sampling_frequency	Get sampling frequency A command that becomes available in the Query menu if you select a Sound object. The Info window will tell you the sampling frequency in hertz. Usage You will not often choose this command with the mouse, since the sampling frequency is included in the information that you get by clicking the Info button. This command is probably more useful in a Praat script: selectObject: Sound hello samplingFrequency = Get sampling frequency Algorithm The sampling frequency is defined as 1 / (Δt), where Δt is the sampling period. See Get sampling period. 
Get_sampling_period	Get sampling period A command that becomes available in the Query menu if you select a Sound object. The Info window will tell you the sampling period in seconds. Usage You will not often choose this command with the mouse, since the sampling period is included in the information that you get by clicking the Info button. This command is probably more useful in a Praat script: selectObject: Sound hello samplingPeriod = Get sampling period Details for hackers With Inspect, you can see how the sampling period is stored in a Sound object: it is the dx attribute. Links to this page Get sampling frequency 
Get_second_formant	Get second formant One of the commands in the Query menu of the SoundEditor and the TextGridEditor. Links to this page Intro 5.3. Querying the formant contours 
Get_time_from_frame_number___	Get time from frame number... A command that becomes available in the Query menu if you select a sound-analysis object that is a function of time and that is evenly sampled in time (Pitch, Formant, Intensity, Harmonicity). The Info window will tell you the time associated with the frame number that you specify. Setting Frame number the frame number whose time is sought. Algorithm the result is t1 + (frame_number - 1) · Δt where t1 is the time associated with the centre of the first frame, and Δt is the time step. Details for hackers If you select one of the above objects and click Inspect, you can see how the relation between frame numbers and times is stored in the object: t1 is the x1 attribute, and Δt is the dx attribute. 
Get_time_from_sample_number___	Get time from sample number... A command that becomes available in the Query menu if you select a Sound or LongSound object. The Info window will tell you the time (in seconds) associated with the sample number that you specify. Setting Sample number the sample number whose time is sought. Algorithm the result is t1 + (sample_number - 1) · Δt where t1 is the time associated with the first sample, and Δt is the sampling period. Details for hackers If you select a Sound or LongSound and click Inspect, you can see how the relation between sample numbers and times is stored in the object: t1 is the x1 attribute, and Δt is the dx attribute. 
Get_time_step	Get time step A command that becomes available in the Query menu if you select a sound-analysis object that is a function of time and that is evenly sampled in time (Pitch, Formant, Intensity, Harmonicity). The Info window will tell you the time difference between consecutive frames, e.g. the time difference between consecutive formant circles in the sound editor window. Details for hackers If you select one of the above objects and click Inspect, you can see how the time step is stored in the object: it is the dx attribute. 
Gifi__1990_	Gifi (1990) A. Gifi (1990): Nonlinear multivariate analysis. John Wiley & Sons Ltd., reprint 1996. Links to this page ContingencyTable: To Configuration (ca)... Correspondence analysis 
Golub___van_Loan__1996_	Golub & van Loan (1996) G. Golub & C. van Loan (1996): Matrix computations. Third edition. London: The Johns Hopkins University Press. Links to this page INDSCAL analysis Matrix: Solve equation... PCA & PCA: Get angle between pc1-pc2 planes PCA & PCA: To Procrustes... 
Goodies	Goodies The title of a submenu of the Praat menu. Links to this page Calculator... Difference of two proportions Formulas Formulas 1.1. Formulas in the calculator Statistics 
Green__Carmone___Smith__1989_	Green, Carmone & Smith (1989) P. Green, F. Carmone, S. Smith (1989): Multidimensional scaling: concepts and applications. Section 3. Allyn and Bacon. Links to this page Create letter R example... 
Greiner___Hormann__1998_	Greiner & Hormann (1998) G. Greiner & K. Hormann (1998): Efficient clipping of arbitrary polygons. ACM Transactions on Graphics 17: 71–83. 
Harmonicity	Harmonicity One of the types of objects in Praat. A Harmonicity object represents the degree of acoustic periodicity, also called Harmonics-to-Noise Ratio (HNR). Harmonicity is expressed in dB: if 99% of the energy of the signal is in the periodic part, and 1% is noise, the HNR is 10*log10(99/1) = 20 dB. A HNR of 0 dB means that there is equal energy in the harmonics and in the noise. Harmonicity can be used as a measure for: The signal-to-noise ratio of anything that generates a periodic signal. Voice quality. For instance, a healthy speaker can produce a sustained [a] or [i] with a harmonicity of around 20 dB, and an [u] at around 40 dB; the difference comes from the high frequencies in [a] and [i], versus low frequencies in [u], resulting in a much higher sensitivity of HNR to jitter in [a] and [i] than in [u]. Hoarse speakers will have an [a] with a harmonicity much lower than 20 dB. We know of a pathological case where a speaker had an HNR of 40 dB for [i], because his voice let down above 2000 Hz. Harmonicity commands Creation: Sound: To Harmonicity (cc)...: cross-correlation method (preferred). Sound: To Harmonicity (ac)...: autocorrelation method. Links to this page Formulas 1.8. Formulas for modification Formulas 7. Attributes of objects Get frame number from time... Get number of frames Get time from frame number... Get time step Harmonicity: Formula... Harmonicity: Get maximum... Harmonicity: Get mean... Harmonicity: Get minimum... Harmonicity: Get standard deviation... Harmonicity: Get time of maximum... Harmonicity: Get time of minimum... Harmonicity: Get value at time... Harmonicity: Get value in frame... time domain Voice 4. Additive noise What was new in 3.7? 
Harmonicity__Formula___	Harmonicity: Formula... A command for changing the data in all selected Harmonicity objects. See the Formulas tutorial for examples and explanations. 
Harmonicity__Get_maximum___	Harmonicity: Get maximum... A query to the selected Harmonicity object. Return value the maximum value, expressed in dB. Settings From time (s) To time (s) the selected time domain. Values outside this domain are ignored. If To time is not greater than From time, the entire time domain of the Harmonicity object is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is Parabolic because of the usual nonlinearity (logarithm) in the computation of harmonicity; sinc interpolation would be too stiff and may give unexpected results. 
Harmonicity__Get_mean___	Harmonicity: Get mean... A query to the selected Harmonicity object. Return value the mean value, expressed in dB. Setting Time range (s) the time range (t1, t2). Values outside this range are ignored. If t1 is not less than t2, the entire time domain of the Harmonicity is considered. Algorithm The mean harmonicity between the times t1 and t2 is defined as 1/(t2 - t1) ∫t1t2 dt x(t) where x(t) is the harmonicity (in dB) as a function of time. Frames in which the value is undefined (i.e. in silent intervals) are ignored. If all the frames are silent, the returned value is undefined. 
Harmonicity__Get_minimum___	Harmonicity: Get minimum... A query to the selected Harmonicity object. Return value the minimum value, expressed in dB. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored, except for purposes of interpolation. If t1 is not less than t2, the entire time domain of the Harmonicity is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is Parabolic because of the usual nonlinearity (logarithm) in the computation of harmonicity; sinc interpolation would be too stiff and may give unexpected results. 
Harmonicity__Get_standard_deviation___	Harmonicity: Get standard deviation... A query to the selected Harmonicity object. Return value the standard deviation, expressed in dB. Setting Time range (s) the time range (t1, t2). Values outside this range are ignored. If t1 is not less than t2, the entire time domain of the Harmonicity is considered. Algorithm The standard deviation between the times t1 and t2 is defined as 1/(t2 - t1) ∫t1t2 dt (x(t) - μ)2 where x(t) is the harmonicity (in dB) as a function of time, and μ its mean. For our discrete Harmonicity object, the standard deviation is approximated by 1/(n-1) ∑i=m..m+n-1 (xi - μ)2 where n is the number of frame centres between t1 and t2. Note the minus 1. 
Harmonicity__Get_time_of_maximum___	Harmonicity: Get time of maximum... A query to the selected Harmonicity object for the time associated with its maximum value. Return value the time (in seconds) associated with the maximum HNR value. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored, except for purposes of interpolation. If t1 is not less than t2, the entire time domain of the Harmonicity is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is Parabolic because of the usual nonlinearity (logarithm) in the computation of harmonicity; sinc interpolation would be too stiff and may give unexpected results. 
Harmonicity__Get_time_of_minimum___	Harmonicity: Get time of minimum... A query to the selected Harmonicity object. Return value the time (in seconds) associated with the minimum HNR value. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored, except for purposes of interpolation. If t1 is not less than t2, the entire time domain of the Harmonicity is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is Parabolic because of the usual nonlinearity (logarithm) in the computation of harmonicity; sinc interpolation would be too stiff and may give unexpected results. 
Harmonicity__Get_value_at_time___	Harmonicity: Get value at time... A query to the selected Harmonicity object to . Return value an estimate (in dB) of the value at a specified time. If this time is outside the time domain or outside the samples of the Harmonicity, the result is undefined. Settings Time (s) the time at which the value is to be evaluated. Interpolation the interpolation method, see vector value interpolation. The standard is Cubic because of the usual nonlinearity (logarithm) in the computation of harmonicity; sinc interpolation would be too stiff and may give unexpected results. 
Harmonicity__Get_value_in_frame___	Harmonicity: Get value in frame... A query to the selected Harmonicity object. Return value the value in a specified frame, expressed in dB. If the index is less than 1 or greater than the number of frames, the result is undefined. Setting Frame number the frame whose value is to be looked up. 
Hayes___MacEachern__1998_	Hayes & MacEachern (1998) Bruce P. Hayes & Margaret MacEachern (1998): Quatrain form in English folk verse. Language 74: 473–507. 
Heath_et_al___1986_	Heath et al. (1986) M.T. Heath, J.A. Laub, C.C. Paige & R.C. Ward (1986): Computing the singular value decomposition of a product of two matrices. SIAM J. Sci. Statist. Comput. 7: 1147–1159. 
Henze___Wagner__1997_	Henze & Wagner (1997) N. Henze & T. Wagner (1997): A new npproach to the BHEP Tests for Multivariate Normality. Journal of Multivariate Analysis 62: 1–23. Links to this page BHEP multivariate normality test 
Hermes__1988_	Hermes (1988) D.J. Hermes (1988): Measurement of pitch by subharmonic summation. Journal of the Acoustical Society of America 83: 257–264. Links to this page Sound: To Pitch (shs)... 
Hidden_commands	Hidden commands Some commands in Praat's fixed and dynamic menus are hidden by default. You can still call hidden commands from scripts, run them by clicking on them in a ButtonEditor, or make them visible with the help of the ButtonEditor. To hide commands that are visible by default, use the ButtonEditor. What commands are hidden by default? Commands that are expected to be of very limited use, are hidden by default. Examples are: 1. The commands Add menu command..., Hide menu command..., Show menu command..., Add action command..., Hide action command..., and Show action command... in the Praat menu of the Object window. These are used in the buttons file and could be used by an initialization script or a plug-in as well; in an interactive session, however, the functionality of these commands is part of the ScriptEditor and the ButtonEditor. 2. The command Read from old Praat picture file... in the File menu of the Picture window. For reading a file format that was in use before May, 1995. 3. In the Praat program, the action Sound: Save as Sesam file.... Writes a file format in common use in the Netherlands on Vax machines. In the Dutch phonetics departments, the plugs were pulled from the Vaxes in 1994. 4. In the Praat program, the action Sound: To Cochleagram (edb).... Needed by one person in 1994. An interesting, but undocumented procedure (De Boer's gammatone filter bank plus Meddis & Hewitt's synapse model), which does not create a normally interpretable Cochleagram object. 
Hillenbrand___Houde__1996_	Hillenbrand & Houde (1996) J. Hillenbrand & R.A. Houde (1996): Acoustic correlates of breathy vocal quality: Dysphonic voices and continuous speech, Journal of speech and hearing research 39: 311–321. Links to this page PowerCepstrogram: Smooth... 
Hillenbrand_et_al___1994_	Hillenbrand et al. (1994) J. Hillenbrand, R.A. Cleveland & R.L. Erickson (1994): Acoustic correlates of breathy vocal quality, Journal of speech and hearing research 37: 769–778. Links to this page PowerCepstrum: Get peak prominence... 
History_mechanism	History mechanism The easiest way to do scripting. The history is the sequence of all menu commands (in the Objects or Picture window or in the editors), action commands (in the dynamic menu), or mouse clicks on objects (in the list of objects), that you performed during your Praat session, together with the settings that you specified in the settings windows that popped up as a result of those commands. Viewing the history To view your history, you first open a ScriptEditor with New Praat script or Open Praat script.... You then choose Paste history from the Edit menu. Recording a macro To record a sequence of mouse clicks for later re-use, perform the following steps: 1. Choose Clear history from the Edit menu. This makes the history mechanism forget all previous clicks. 2. Perform the actions that you want to record. 3. Choose Paste history from the Edit menu. Because you cleared the history before you started, the resulting script contains only the actions that you performed in step 2. You can now already re-run the actions that you performed in step 2. 4. You can save the recorded actions to a script file by choosing Save from the File menu. 5. You can put this script file under a button in the dynamic menu by choosing Add to dynamic menu... from the File menu, or under a button in a fixed menu by choosing Add to fixed menu.... This button will be preserved across Praat sessions. This macro mechanism is much more flexible than the usual opaque macro mechanism used by most programs, because you can edit the script and make some of the arguments variable by putting them in the form clause at the top of the script. In this way, the script will prompt the user for these arguments, just as with all the menu and action commands that end in the three dots (...). See the Scripting tutorial for all the things that you can do in scripts. Links to this page Scripting 2. How to script settings windows 
HMM	HMM A HMM is a Hidden Markov Model. Markov models are often used to model observation sequences. The fundamental assumption in a markov model is that the probability of an observation (event) can only depend on the previous observation. A HMM can be visualised as a graph with a number of states. If states are connected they have line connecting them. The following picture shows a HMM with two states, labeled Rainy and Sunny. Each state can emit three symbols (these are not visible in the graph). For an introduction into HMM's see Rabiner (1989). Links to this page HMM & HMM & HMM_ObservationSequence: Get cross-entropy HMM & HMM: Get cross-entropy... HMM & HMM_ObservationSequence: Get cross-entropy HMM & HMM_ObservationSequence: Get probability HMM & HMM_ObservationSequence: To TableOfReal (bigrams)... HMM & HMM_ObservationSequences: Learn... HMM & HMM_StateSequence: Get probability HMM: Create simple HMM... HMM: Extract emission probabilities HMM: Extract transition probabilities HMM: Get emission probability... HMM: Get expected duration in state... HMM: Get p (time, state)... HMM: Get p (time, state, symbol)... HMM: Get probability staying in state... HMM: Get start probability... HMM: Get transition probability... HMM: To HMM_ObservationSequence... HMM_ObservationSequence HMM_StateSequence 
HMM___HMM___HMM_ObservationSequence__Get_cross-entropy	HMM & HMM & HMM_ObservationSequence: Get cross-entropy Get the (symmetric) cross-entropy for the two selected HMM models and an observation sequence. See HMM & HMM: Get cross-entropy.... 
HMM___HMM__Get_cross-entropy___	HMM & HMM: Get cross-entropy... Calculates the cross-entropy between the two selected HMM models based on observation sequences. Settings Observation length defines the number of observations that have to generated. Symmetric defines whether the symmetric formula is used in the calculation. Algorithm The cross-entropy is a measure of the distance between two models λ1 and λ2. It is defined as D(λ1,λ2) = 1/N (log p(O2|λ1) - log p(O2|λ2)), where O2 is an observation sequence of length N generated by model λ2. The symmetrized version is: Ds(λ1,λ2) = (D(λ1,λ2) + D(λ2,λ1))/2. Links to this page HMM & HMM & HMM_ObservationSequence: Get cross-entropy 
HMM___HMM_ObservationSequence__Get_cross-entropy	HMM & HMM_ObservationSequence: Get cross-entropy Calculates the cross-entropy between the selected HMM model and the HMM_ObservationSequence. The cross-entropy is a useful upper bound for the entropy of a model. An approximation to the cross-entropy for a model on a observation sequence O of length N is: H(O) = -1/N log p(O), where p(O) is the probability of the observation sequence given the model. 
HMM___HMM_ObservationSequence__Get_probability	HMM & HMM_ObservationSequence: Get probability Get the natural logarithm of the probability that the selected state sequence was generated by the selected HMM. Algorithm Viterbi 
HMM___HMM_ObservationSequence__To_TableOfReal__bigrams_	HMM & HMM_ObservationSequence: To TableOfReal (bigrams)... Get a table with bigrams and marginals form the selected HMM_ObservationSequence and the HMM. The entry at row i and column j shows how often the j-th symbol follows the i-th symbol in the observation sequence. Remark The row and colum marginals for the first and the last element in the obsevation sequence will not be equal because there is no transition to the first and no transition from the last one. Links to this page HMM_ObservationSequence: To TableOfReal (bigrams)... 
HMM___HMM_ObservationSequences__Learn___	HMM & HMM_ObservationSequences: Learn... Train the transition and emission probabilities of the HMM from the observations. Algorithm The Baum-Welch expectation-maximization procedure. It uses the forward and backward procedures to (re)estimate the parameters until convergence is reached. 
HMM___HMM_StateSequence__Get_probability	HMM & HMM_StateSequence: Get probability Get the natural logarithm of the probability that the selected state sequence was generated by the selected HMM. 
HMM__Create_simple_HMM___	HMM: Create simple HMM... Creates a Hidden Markov Model from given states and observation symbols. Settings Name determines the name (for the list of objects). States determines the number of and the names of the states. Symbols determines the number and the names of the observation symbols. You can define a (not hidden) Markov model by leaving either the States or the Symbols field empty. The model is initialised with equal probabilities for all the transitions and emissions. 
HMM__Extract_emission_probabilities	HMM: Extract emission probabilities Extract the emission probabilities of the selected HMM as a TableOfReal. The row label shows the from state and the column label the to symbol, therefore the cell element in row i and column j shows the probability of emitting symbol j from state i. 
HMM__Extract_transition_probabilities	HMM: Extract transition probabilities Extract the transition probabilities of the selected HMM as a TableOfReal. The row label shows the from state and the column label the to state, therefore the cell element in row i and column j shows the probability of making a transition from state i to state j. 
HMM__Get_emission_probability___	HMM: Get emission probability... For the selected HMM get the probability that in a given state a particular symbol will be emitted. 
HMM__Get_expected_duration_in_state___	HMM: Get expected duration in state... For the selected HMM get the number of time units that the system is expected to stay in that state. 
HMM__Get_p__time__state____	HMM: Get p (time, state)... For the selected HMM get the probability that after a given number of time steps the HMM will be in a particular state. 
HMM__Get_p__time__state__symbol____	HMM: Get p (time, state, symbol)... For the selected HMM get the probability that after a given number of time steps the HMM will be in a particular state and emits a certain symbol. This probability is the product of the probability being in particular state at that time (index) and the probability of emitting a certain symbol in that state. 
HMM__Get_probability_staying_in_state___	HMM: Get probability staying in state... For the selected HMM get the probability that it stays exactly the given number of times in that state. This probability is αiinumberOfTimes-1(1 - αii), where αii is the probability of staying in state i. 
HMM__Get_start_probability___	HMM: Get start probability... For the selected HMM get the probabilities that the model will start in a particular state. 
HMM__Get_transition_probability___	HMM: Get transition probability... For the selected HMM get the probability to make a transition from one state to the other. 
HMM__Set_emission_probabilities___	HMM: Set emission probabilities... Sets the probabilities for emitting the symbols from the state. The values given will be scaled as probabilities. Examples For an HMM with four symbols the input 1 3 3 3 will result in the same probabilities as the input 0.1 0.3 0.3 0.3. 
HMM__Set_start_probabilities___	HMM: Set start probabilities... Sets the probabilities that the model starts in the particular states. The values given will be scaled as probabilities. 
HMM__Set_transition_probabilities___	HMM: Set transition probabilities... Sets the probabilities for making a transition from one state to all other states. Settings Probabilities the list of transition probabilities from the given state. The values given will be scaled as probabilities. A zero is used to mark a transition that will never occur. Examples For a three state model the input 1 3 7 will result in the same probabilities as the input 0.1 0.3 0.7. 
HMM__To_HMM_ObservationSequence___	HMM: To HMM_ObservationSequence... Use the selected HMM as a generator for an observation sequence. Settings Start state defines the state in which the HMM starts. If a zero is given the start state is randomly chosen according to the start probabilities. Number of observations defines the number of observations to generate. For models of finite duration such as left-to-right models, the HMM generator may stop before this number is reached. 
HMM_ObservationSequence	HMM_ObservationSequence An HMM_ObservationSequence models a sequence of observations. The observation sequence can be generated by the HMM or it can be used to train a model. Links to this page HMM & HMM_ObservationSequence: Get cross-entropy HMM & HMM_ObservationSequence: Get probability HMM & HMM_ObservationSequence: To TableOfReal (bigrams)... HMM_ObservationSequence: To TableOfReal (bigrams)... 
HMM_ObservationSequence__To_TableOfReal__bigrams____	HMM_ObservationSequence: To TableOfReal (bigrams)... Get a table with bigrams form the selected HMM_ObservationSequence. See also HMM & HMM_ObservationSequence: To TableOfReal (bigrams).... 
HMM_StateSequence	HMM_StateSequence An HMM_StateSequence models the sequence of states that an HMM has traversed. Links to this page HMM & HMM_StateSequence: Get probability 
Hormann___Agathos__2001_	Hormann & Agathos (2001) K. Hormann & A. Agathos (2001): The point in polygon problem for arbitrary polygons. Computational Geometry 20: 131–144. Links to this page Polygon: Get location of point... 
How_to_concatenate_sound_files	How to concatenate sound files You can concatenate any combination of AIFF, AIFC, WAV, NeXT/Sun, NIST and FLAC audio files, and other files that you have read into memory. For instance, if you want to concatenate a 30-minute AIFF file, a 4-minute Kay sound file, and a 60-minute Next/Sun file, by saving them into a 94-minute WAV file, you do the following: 1. Open the AIFF file with Open long sound file... from the Open menu. A LongSound object will appear in the list. 2. Read the Kay sound file into memory with Read from file.... A Sound object will appear in the list. 3. Open the AIFF file with Open long sound file... from the Open menu. A second LongSound object will appear in the list. 4. Select the three objects and choose Save as WAV file... from the Save menu. This only works if all the sounds have the same sampling frequency and the same number of channels. Available formats The format of the original sound files may be 16-bit linear (with big-endian or little-endian byte order), 8-bit linear (signed or unsigned), 8-bit μ-law, or 8-bit A-law. The format of the resulting sound file is always 16-bit linear, with an appropriate default byte order. The following commands are available in the Save menu of you select any combination of LongSound and/or Sound objects: • Save as WAV file... (little-endian) • Save as AIFF file... (big-endian) • Save as AIFC file... (big-endian) • Save as NeXT/Sun file... (big-endian) • Save as NIST file... (little-endian) • Save as FLAC file... Links to this page Sounds: Concatenate 
identity_permutation	identity permutation The identity permutation is (1,2,3,...,numberOfElements), i.e. the numbers 1 to numberOfElements in their natural order. Links to this page Create Permutation... Permutation: Sort 
Igor_Kononenko__1994_	Igor Kononenko (1994) Igor Kononenko (1994): Estimating attributes: Analysis and extensions of relief. In ECML-94: Proceedings of the European Conference on Machine Learning, Secaucus, NJ, USA, 171–182. New York: Springer. Links to this page kNN classifiers 1.1.1.1. Filter-based feature weighting 
incompleteBeta	incompleteBeta incompleteBeta (a, b, x) Ix(a,b) = 1/beta(a,b)∫0x ta-1(1-t)b-1 dt, for 0 ≤ x ≤ 1 and a and b and a+b not equal to a negative integer. 
incompleteGammaP	incompleteGammaP incompleteGammaP (a, x) incompleteGammaP = 1/Γ(a)∫0x e-tta-1 dt, For x≥ 0 and a not a negative integer. 
Index	Index One of the types of objects in the PRAAT program. Links to this page Index: Extract part... Index: To Permutation... Strings: To Index 
Index__Extract_part___	Index: Extract part... Creates a new Index by copying a part of selected Index. Example Given the following Index: 1 (number of columns) (no column name) dag allemaal hallo tot morgen 6 (number of elements) 2 1 2 3 2 3 The command Extract part... 1 2 gives you the new Index: 1 (number of columns) (no column name) dag allemaal hallo tot morgen 6 (number of elements) 2 1 Note that all classes stay intact and may have zero references like for example the tot morgen class. 
Index__To_Permutation___	Index: To Permutation... Generates a Permutation from the selected Index by randomly permuting blocks of equivalent elements. Suppose your data consists of groups of equivalent elements and the number of elements in the groups are not equal. You want to make random ordering of your data such that the elements in a group stay together. The following example shows you how. Setting Permute within classes determines whether the elements within a class will be randomly permuted. Example Suppose your data, for example a Strings, consists of groups of equivalent elements and the number of elements in the groups are not equal. You want to make a random ordering of your data such that the elements in a group stay together. The following example shows you how. We start from the following Strings: 6 (number of strings) hallo dag allemaal hallo tot morgen hallo tot morgen We choose To Index which will give us the following Index: 1 (number of columns) (no column name) dag allemaal hallo tot morgen 6 (number of elements) 2 1 2 3 2 3 We choose To Permutation and with Permute within classes off, this might generate the permutation (2,4,6,1,3,5). Selecting the Permutation and the Strings together and choosing Permute strings will generate the following Strings: dag allemaal tot morgen tot morgen hallo hallo hallo We see that the permutation always keeps identical strings together. 
individual_difference_scaling	individual difference scaling The purpose of individual difference scaling is to represent objects, whose dissimilarities are given, as points in a metrical space. The distances in the space should be in accordance with the dissimilarities as well as is possible. Besides the configuration a Salience matrix is calculated. The basic Euclidean model is: δijk ≈ (∑s=1..r wks(xis – xjs)2)1/2 Here δijk is the (known) dissimilarity between objects i and j, as measured on data source k. The x's are the coordinates of the objects in an r-dimensional space and the w's are weights or saliences. Because straight minimization of the expression above is difficult, one applies transformations on this expression. Squaring both sides gives the model: δ2ijk ≈ ∑s=1..r wks(xis – xjs)2 and the corresponding least squares loss function: ∑k=1..numberOfSources ∑i=1..numberOfPoints ∑j=1..numberOfPoints (δ2ijk – d2ijk)2 This loss function is minimized in the (ratio scale option of the) ALSCAL program of Takane, Young & de Leeuw (1976). The transformation used by Carroll & Chang (1970) in the INDSCAL model, transforms the data from each source into scalar products of vectors. For the dissimilarities: βijk = –{ δ2ijk – δ2i.k – δ2.jk + δ2..k } / 2, where dots replacing indices indicate averaging over the range of that index. In the same way for the distances: zijk = –{ d2ijk – d2i.k – d2.jk + d2..k } / 2. βijk ≈ zijk = ∑s=1..numberOfDimensions wks xis xjs Translated into matrix algebra, the equation above translates to: Bk ≈ Zk = X Wk X′, where X is a numberOfPoints × numberOfDimensions configuration matrix, Wk, a non-negative numberOfDimensions × numberOfDimensions matrix with weights, and Bk the kth slab of βijk. This translates to the following INDSCAL loss function: f(X, W1,..., WnumberOfSources) = ∑k=1..numberOfSources | Bk – XWkX′ |2 Distance: To Configuration (ytl)... INDSCAL analysis Multidimensional scaling 
INDSCAL_analysis	INDSCAL analysis A method for individual difference scaling analysis in PRAAT. An INDSCAL analysis can be performed on objects of type Distance. If you start with Dissimilarity objects you first have to transform them to Distance objects. Dissimilarity: To Distance... If you start with a Confusion you can use: Confusion: To Dissimilarity (pdf)... Examples Distance: To Configuration (indscal)... Perform an INDSCAL analysis on one or more objects of type Distance to calculate a Configuration. Distance & Configuration: To Configuration (indscal)... Perform an INDSCAL analysis on one or more objects of type Distance to calculate a Configuration. Use the selected Configuration object as the initial Configuration in the iteration process. Algorithm The function to be minimized in INDSCAL is the following: f(X, W1,..., WnumberOfSources) = ∑i=1..numberOfSources |Si – XWiX′|2 where X an unknown numberOfPoints x numberOfDimensions configuration matrix, the Wi are numberOfSources unknown diagonal numberOfDimensions x numberOfDimensions matrices with weights, often called saliences, and the Si are known symmetric matrices with scalar products of dimension numberOfPoints x numberOfPoints. In the absence of an algorithm that minimizes f, Carroll & Chang (1970) resorted to the CANDECOMP algorithm, which instead of the function given above minimizes the following function: g(X, Y, W1,..., WnumberOfSources) = ∑i=1..numberOfSources |Si – XWiY′|2. Carroll & Chang claimed that for most practical circumstances X and Y converge to matrices that will be columnwise proportional. However, INDSCAL does not only require symmetry of the solution, but also non-negativity of the weights. Both these aspects cannot be guaranteed with the CANDECOMP algorithm. Ten Berge, Kiers & Krijnen (1993) describe an algorithm that automatically satisfies symmetry because it solves f directly, and, also, can guarantee non-negativity of the weights. This algorithm proceeds as follows: Let xh be the h-th column of X. We then write the function f above as: f(xh, w1h, ..., wnumberOfSources h) = ∑i=1..numberOfSources |Sih – xhwihx′h|2, with Sih defined as: Sih = (Si - ∑j≠h, j=1..numberOfDimensions xjwijx′j). Without loss of generality we may require that x′hxh = 1 Minimizing f over xh is equivalent to minimizing ∑i=1..numberOfSources |Sih|2 – 2tr ∑ Sihxhwihx′h + ∑ w2ih This amounts to maximizing g(xh) = x′h(∑ wihSih)xh subject to x′hxh = 1. The solution for xh is the dominant eigenvector of (∑ wihSih), which can be determined with the power method (see Golub & van Loan (1996)). The optimal value for the wih, given that all other parameters are fixed: wih = x′hSihxh In an alternating least squares procedure we may update columns of X and the diagonals of the W matrices in any sensible order. Links to this page Create INDSCAL Carroll & Wish example... Distance & Configuration & Salience: To Configuration (indscal)... Distance: To Configuration (ytl)... Multidimensional scaling Types of objects 
Info	Info One of the fixed buttons in the Object window. Availability You can choose this command after choosing one object. Purpose To get some information about the selected object. Behaviour The information will appear in the Info window. Links to this page Feedforward neural networks 2. Quick start Feedforward neural networks 3. FFNet versus discriminant classifier Scripting 6.2. Writing to the Info window 
Info_window	Info window A text window into which many query commands write their answers. You can select text from this window and copy it to other places. In a Praat script, you can bypass the Info window by having a query command writing directly into a script variable. Apart from the Info command, which writes general information about the selected object, the following more specific commands also write into the Info window: Categories: Difference Intro 4.3. Querying the pitch contour Intro 5.3. Querying the formant contours Log files Query Scripting 6.2. Writing to the Info window TextGrid: Count labels... undefined 
initialization_script	initialization script Your initialization script is a normal Praat script that is run as soon as you start Praat. On Unix or MacOS X, you create an initialization script by creating a file named praat-startUp in the directory /usr/local, or putting a file .praat-user-startUp or praat-user-startUp in your home directory (if you rename the Praat executable, these names have to change as well). If you have more than one of these files, they are run in the above order. Example If you like to be greeted by your husband when Praat starts up, you could put the following lines in your initialization script: Read from file: /Users/miep/helloMiep.wav Play Remove What not to use an initialization script for You could set preferences like the default font in your initialization script, but these will be automatically remembered between invocations of Praat anyway (in your preferences file), so this would often be superfluous. For installing sets of menu commands at start-up you will probably prefer to use plug-ins rather than a single start-up file. Links to this page Add action command... Add menu command... Add to dynamic menu... Add to fixed menu... ButtonEditor Hidden commands 
Insert_picture_from_file___	Insert picture from file... A command in the World menu of the Picture window. Purpose To draw a picture file (PNG; on Mac and Windows also JPEG or TIFF; other picture formats may also work) into the Picture window (or into the Demo window). Settings File name the name of the picture file. If you use this command in a script, you can use a relative path name such as pictures/myface.png or ~/Desktop/hello.png. From x To x The horizontal location (in world coordinates) where the picture will appear. Use the Axes... command to set world coordinates if they have not been set implicitly by an earlier Draw or Paint command. If you set From x and To x to the same value, the picture will be horizontally centred around this x value and obtain a width that preserves the aspect ratio (width-to-height ratio) of the original picture. From y To y The vertical location (in world coordinates) where the picture will appear. Use the Axes... command to set world coordinates if they have not been set implicitly by an earlier Draw or Paint command. If you set From y and To y to the same value, the picture will be vertically centred around this y value and obtain a height that preserves the aspect ratio (width-to-height ratio) of the original picture. Behaviour From the description above, you see that if From x is unequal to To x and From y is unequal to To y, the picture will probably obtain an aspect ratio different from the original picture. To preserve the aspect ratio, either make To x equal to From x or make To y equal to From y. To show the picture on the same number of pixels as the original, make To x equal to From x and To y equal to From y. Praat will then show the picture with the original width and height (in pixels), centred around the given x and y values. Usage You will usually use this in a script, and often in a script that runs the Demo window. Links to this page What was new in 5.2? What was new in 5.3? What's new? 
Inspect	Inspect One of the fixed buttons in the Object window. You can use this command after selecting one object in the list. The contents of the selected object will become visible in a Data Editor. You can then view and change the data in the object, but beware: changing the data directly in this way may render them inconsistent. Changes that you make to the data with another Editor (e.g., a SoundEditor), or with the commands under Modify, are immediately reflected in the top-level Data Editor; any subeditors are destroyed, however, because they may now refer to invalid data. Changes that you make to the data with a Data Editor, are immediately reflected in any open type-specific Editors (e.g., a SoundEditor). Links to this page BarkFilter Categories Configuration Confusion Editors Eigen Excitation Formant FormantFilter Get frame number from time... Get number of frames Get number of samples Get sample number from time... Get sampling period Get time from frame number... Get time from sample number... Get time step Ltas Manipulation Matrix MelFilter OT learning 7. Learning from overt forms OTGrammar Pattern PCA Pitch Proximity Sound Source-filter synthesis 4. Using existing sounds Spectrogram SSCP time domain WordList 
Intensity	Intensity One of the types of objects in Praat. An Intensity object represents an intensity contour at linearly spaced time points ti = t1 + (i – 1) dt, with values in dB SPL, i.e. dB relative to 2·10-5 Pascal, which is the normative auditory threshold for a 1000-Hz sine wave. Links to this page Formulas 7. Attributes of objects Get frame number from time... Get number of frames Get time from frame number... Get time step Intensity & PointProcess: To IntensityTier... Intensity: Get maximum... Intensity: Get mean... Intensity: Get minimum... Intensity: Get standard deviation... Intensity: Get time of maximum... Intensity: Get time of minimum... Intensity: Get value at time... Intensity: Get value in frame... Intensity: To IntensityTier Intensity: To TextGrid (silences)... Intro 6.4. The Intensity object Sound & IntensityTier: Multiply Sound: To Intensity... Source-filter synthesis 2. Filtering a source time domain What was new in 3.7? 
Intensity___PointProcess__To_IntensityTier___	Intensity & PointProcess: To IntensityTier... A command to copy information from an Intensity, at times specified by a PointProcess, to points on an IntensityTier. Behaviour For all the times of the points in the PointProcess, an intensity is computed from the information in the Intensity object, by linear interpolation. 
Intensity__Get_maximum___	Intensity: Get maximum... A query to the selected Intensity object. Return value the maximum value within the specified time domain, expressed in dB. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored. If t1 is not less than t2, the entire time domain of the Intensity is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is Parabolic because of the usual nonlinearity (logarithm) in the computation of intensity; sinc interpolation would be too stiff and may give unexpected results. 
Intensity__Get_mean___	Intensity: Get mean... A query to the selected Intensity object. Return value the mean (in dB) of the intensity values of the frames within a specified time domain. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored. If t1 is not less than t2, the entire time domain of the Intensity is considered. Averaging method the units in which the averaging is performed. If the method is energy, the returned dB value is based on the mean power (in Pa2/s) between t1 and t2. If the method is dB, the returned value is the mean of the intensity curve in dB. If the method is sones, the returned value is in between these two, and based on averaging properties of the human ear. Algorithm If the averaging method is dB, the mean intensity between the times t1 and t2 is defined as 1/(t2 - t1) ∫t1t2 x(t) dt where x(t) is the intensity as a function of time, in dB. If the method is energy, the result is 10 log10 { 1/(t2 - t1) ∫t1t2 10x(t)/10 dt } If the method is sones, the result is 10 log2 { 1/(t2 - t1) ∫t1t2 2x(t)/10 dt } Behaviour After you do Sound: To Intensity..., the mean intensity of the resulting Intensity, if the averaging method is energy, should be close to the mean SPL of the original Sound, which can be found with Info. Links to this page Intro 6.2. Configuring the intensity contour 
Intensity__Get_minimum___	Intensity: Get minimum... A query to the selected Intensity object. Return value the minimum value within a specified time domain, expressed in dB. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored. If t1 is not less than t2, the entire time domain of the Intensity is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is Parabolic because of the usual nonlinearity (logarithm) in the computation of intensity; sinc interpolation would be too stiff and may give unexpected results. 
Intensity__Get_standard_deviation___	Intensity: Get standard deviation... A query to the selected Intensity object. Return value the standard deviation (in dB) of the intensity values of the frames within a specified time domain. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored. If t1 is not less than t2, the entire time domain of the Intensity is considered. Algorithm The standard deviation between the times t1 and t2 is defined as √ {1/(t2 - t1) ∫t1t2 dt (x(t) - μ)2} where x(t) is the intensity (in dB) as a function of time, and μ its mean. For our discrete Intensity object, the standard deviation is approximated by √ {1/(n-1) ∑i=m..m+n-1 (xi - μ)2} where n is the number of frames between t1 and t2. Note the minus 1. 
Intensity__Get_time_of_maximum___	Intensity: Get time of maximum... A query to the selected Intensity object. Return value the time (in seconds) associated with the maximum intensity within a specified time domain. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored, except for purposes of interpolation. If t1 is not less than t2, the entire time domain of the Intensity is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is Parabolic because of the usual nonlinearity (logarithm) in the computation of intensity; sinc interpolation would be too stiff and may give unexpected results. 
Intensity__Get_time_of_minimum___	Intensity: Get time of minimum... A query to the selected Intensity object. Return value the time (in seconds) associated with the minimum intensity within a specified time domain. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored, except for purposes of interpolation. If t1 is not less than t2, the entire time domain of the Intensity is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is Parabolic because of the usual nonlinearity (logarithm) in the computation of intensity; sinc interpolation would be too stiff and may give unexpected results. 
Intensity__Get_value_at_time___	Intensity: Get value at time... A query to the selected Intensity object. Return value the intensity (in dB) at a specified time. If time is outside the frames of the Intensity, the result is 0. Settings Time (s) the time at which the value is to be evaluated. Interpolation the interpolation method, see vector value interpolation. The standard is Cubic because of the usual nonlinearity (logarithm) in the computation of intensity; sinc interpolation would be too stiff and may give unexpected results. 
Intensity__Get_value_in_frame___	Intensity: Get value in frame... A query to the selected Intensity object. Setting Frame number the frame whose value is to be looked up. Return value the intensity value (in dB) in the specified frame. If the index is less than 1 or greater than the number of frames, the result is 0; otherwise, it is z [1] [frame number]. 
Intensity__To_IntensityTier	Intensity: To IntensityTier A command to convert each selected Intensity object to an IntensityTier. Behaviour Every sample in the Intensity object is copied to a point on the IntensityTier. Postconditions Equal time domains: • result. xmin == intensity. xmin • result. xmax == intensity. xmax Equal number of points: • result. points. size == intensity. nx For all points i = 1 ... intensity. nx: Explicit times: • result. points. item [i]. time == intensity. x1 + (i – 1) * intensity. dx Equal number of points: • result. points. item [i]. value == intensity. z [1] [i] 
Intensity__To_TextGrid__silences____	Intensity: To TextGrid (silences)... A command that creates a TextGrid in which the silent and sounding intervals of the selected Intensity are marked. Settings Silence threshold (dB) determines the maximum silence intensity value in dB with respect to the maximum intensity. For example, if imax is the maximum intensity in dB then the maximum silence intensity is calculated as imax - silenceThreshold; intervals with an intensity smaller than this value are considered as silent intervals. Minimum silent interval duration (s) determines the minimum duration for an interval to be considered as silent. If you don't want the closure for a plosive to count as silent then use a large enough value. Minimum sounding interval duration (s) determines the minimum duration for an interval to be not considered as silent. This offers the possibility to filter out small intense bursts of relatively short duration. Silent interval label determines the label for a silent interval in the TextGrid. Sounding interval label determines the label for a sounding interval in the TextGrid. Algorithm First the intensity contour is evaluated and the intervals above and below the silence threshold are marked as sounding and silent. We then remove sounding intervals with a duration smaller than the Minimum sounding interval duration. This step is followed by joining the neighbouring silent intervals that resulted because of this removal. Finally we remove silent intervals with a duration smaller than the Minimum silent interval duration. This is followed by joining the neighbouring sounding intervals that resulted because of this removal. Experience showed that first removing short intensity bursts instead of short silences gave better results than doing it the other way around. Important The effectiveness of the Minimum silent interval duration and Minimum sounding interval duration depends on the effective analysis window duration that was used to determine the intensity contour. For example, if you have chosen 100 Hz for the Minimum pitch parameter in the Sound: To Intensity... analysis, the effective analysis window duration was 32 ms. Don't expect to find sounding or silent intervals with a duration smaller than this effective analysis window duration. Links to this page Sound: To TextGrid (silences)... Sound: Trim silences... 
IntensityTier	IntensityTier One of the types of objects in Praat. An IntensityTier object represents a time-stamped intensity contour, i.e., it contains a series of (time, intensity) points. The intensity values are in dB. For examples, see Source-filter synthesis. IntensityTier commands Creation: From scratch: • Create IntensityTier... • IntensityTier: Add point... Copy from another object: • Intensity: To IntensityTier: trivial copying of linearly spaced points. • Intensity & PointProcess: To IntensityTier...: copying interpolated values at specified points. • PointProcess: Up to IntensityTier...: equal values at specified points. Viewing and editing: • IntensityTierEditor Conversion: • IntensityTier: Down to PointProcess: copy times. Synthesis (see Source-filter synthesis): • Sound & IntensityTier: Multiply Queries: • Get low index from time... • Get high index from time... • Get nearest index from time... Modification: • Remove point... • Remove point near... • Remove points between... • IntensityTier: Add point... Links to this page AmplitudeTier constant extrapolation Get area... Intro 8.3. Manipulation of intensity linear interpolation Sound: To KlattGrid (simple)... Source-filter synthesis 2. Filtering a source Source-filter synthesis 3. The ba-da continuum What was new in 3.7? 
IntensityTier__Add_point___	IntensityTier: Add point... A command to add a point to each selected IntensityTier. Settings Time (s) the time at which a point is to be added. Intensity (dB) the intensity value of the requested new point. Behaviour The tier is modified so that it contains the new point. If a point at the specified time was already present in the tier, nothing happens. Links to this page Create IntensityTier... 
IntensityTier__Down_to_PointProcess	IntensityTier: Down to PointProcess A command to degrade every selected IntensityTier to a PointProcess. Behaviour The times of all the points are trivially copied, and so is the time domain. The intensity information is lost. 
IntensityTierEditor	IntensityTierEditor One of the editors in the Praat program, for viewing and editing an IntensityTier object. To create a IntensityTierEditor window, select an IntensityTier and click View & Edit. 
Intro	Intro This is an introductory tutorial to Praat, a computer program with which you can analyse, synthesize, and manipulate speech, and create high-quality pictures for your articles and thesis. You are advised to work through all of this tutorial. You can read this tutorial sequentially with the help of the 1 > and < 1 buttons, or go to the desired information by clicking on the blue links. Intro 1. How to get a sound: record, read, formula. Intro 2. What to do with a sound: write, view. Intro 3. Spectral analysis spectrograms: view, configure, query, print, the Spectrogram object. spectral slices: view, configure, the Spectrum object. Intro 4. Pitch analysis pitch contours: view, configure, query, print, the Pitch object. Intro 5. Formant analysis formant contours: view, configure, query, the Formant object. Intro 6. Intensity analysis intensity contours: view, configure, query, the Intensity object. Intro 7. Annotation Intro 8. Manipulation: of pitch, duration, intensity, formants. There are also more specialized tutorials: Phonetics: • Voice analysis (jitter, shimmer, noise): Voice • Listening experiments: ExperimentMFC • Sound files • Filtering • Source-filter synthesis • Articulatory synthesis Learning: • Feedforward neural networks • OT learning Statistics: • Principal component analysis • Multidimensional scaling • Discriminant analysis General: • Printing • Scripting • Demo window The authors The Praat program was created by Paul Boersma and David Weenink of the Institute of Phonetics Sciences of the University of Amsterdam. Home page: http://www.praat.org or http://www.fon.hum.uva.nl/praat/. For questions and suggestions, mail to the Praat discussion list, which is reachable from the Praat home page, or directly to paul.boersma@uva.nl. Links to this page Acknowledgments Formulas 1.8. Formulas for modification Formulas 7. Attributes of objects pitch floor Sound SoundEditor Statistics time domain Types of objects waveform What was new in 3.9? 
Intro_1_1__Recording_a_sound	Intro 1.1. Recording a sound To record a speech sound into Praat, you need a computer with a microphone. To record from the microphone, perform the following steps: 1. Choose Record mono Sound... from the New menu in the Object window. A SoundRecorder window will appear on your screen. 2. In the SoundRecorder window, choose the appropriate input device, e.g. choose Internal microphone. 3. Use the Record and Stop buttons to record a few seconds of your speech. 4. Use the Play button to hear what you have recorded. 5. Repeat steps 3 and 4 until you are satisfied with your recording. 6. Click the Save to list button. Your recording will now appear in the Object window, where it will be called Sound sound. 7. You can now close the SoundRecorder window. 8. When you saved your sound to the Object window, some buttons appeared in that window. These buttons show you what you can do with the sound. Try the Play and View & Edit buttons. For more information on recording, see the SoundRecorder manual page. Links to this page Intro Intro 1. How to get a sound 
Intro_1_2__Reading_a_sound_from_disk	Intro 1.2. Reading a sound from disk Apart from recording a new sound from a microphone, you could read an existing sound file from your disk. With Read from file... from the Open menu, Praat will be able to read most standard types of sound files, e.g. WAV files. They will appear as Sound objects in the Object window. For instance, if you open the file hello.wav, an object called Sound hello will appear in the list. If you do not have a sound file on your disk, you can download a WAV file (or so) from the Internet, then read that file into Praat with Read from file.... Links to this page Intro Intro 1. How to get a sound 
Intro_1_3__Creating_a_sound_from_a_formula	Intro 1.3. Creating a sound from a formula If you have no microphone, no sound files on disk, and no access to the Internet, you could still create a sound with Create Sound from formula... from the New menu. Links to this page Intro Intro 1. How to get a sound 
Intro_1__How_to_get_a_sound	Intro 1. How to get a sound Most of the things most people do with Praat start with a sound. There are at least three ways to get a sound: Intro 1.1. Recording a sound Intro 1.2. Reading a sound from disk Intro 1.3. Creating a sound from a formula Links to this page Intro 
Intro_2_1__Saving_a_sound_to_disk	Intro 2.1. Saving a sound to disk There are several ways to write a sound to disk. First, the File menu of the SoundRecorder window contains commands to save the left channel, the right channel, or both channels of the recorded sound to any of four standard types of sound files (WAV, AIFC, NeXT/Sun, NIST). These four file types are all equally good for Praat: Praat will handle them equally well on every computer. The first three of these types will also be recognized by nearly all other sound-playing programs. Then, once you have a Sound object in the List of Objects, you can save it in several formats with the commands in the Save menu. Again, the WAV, AIFF, AIFC, NeXT/Sun, and NIST formats are equally fine. For more information, see the Sound files tutorial. Links to this page Intro Intro 2. What to do with a sound 
Intro_2_2__Viewing_and_editing_a_sound	Intro 2.2. Viewing and editing a sound To see the wave form of a Sound that is in the list of objects, select that Sound and click View & Edit. A SoundEditor window will appear on your screen. You see a waveform (or two waveforms, if you have a stereo sound) and probably some analyses below it. You can zoom in and scroll to see the various parts of the sound in detail. You can select a part of the sound by dragging with the mouse. To play a part of the sound, click on any of the rectangles below it. To move a selected part of the sound to another location, use Cut and Paste from the Edit menu. You can open sound windows for more than one sound, and then cut, copy, and paste between the sounds, just as you are used to do with text and pictures in word processing programs. If your sound file is longer than a couple of minutes, or if you want to see and listen to both channels of a stereo sound, you may prefer to open it with Open long sound file.... This puts a LongSound object into the list. In this way, most of the sound will stay in the file on disk, and at most 60 seconds will be read into memory each time you play or view a part of it. To change these 60 seconds to something else, e.g. 500 seconds, choose LongSound prefs... from the Preferences submenu. Links to this page Intro Intro 2. What to do with a sound 
Intro_2__What_to_do_with_a_sound	Intro 2. What to do with a sound As soon as you have a Sound in the List of Objects, the buttons in the Dynamic menu (the right-hand part of the Object window) will show you what you can do with it. Intro 2.1. Saving a sound to disk Intro 2.2. Viewing and editing a sound Links to this page Intro 
Intro_3_1__Viewing_a_spectrogram	Intro 3.1. Viewing a spectrogram To see the spectral content of a sound as a function of time, select a Sound or LongSound object and choose View & Edit. A SoundEditor or LongSoundEditor window will appear on your screen. In the entire bottom half of this window you will see a greyish image, which is called a spectrogram. If you do not see it, choose Show spectrogram from the Spectrogram menu. The spectrogram is a spectro-temporal representation of the sound. The horizontal direction of the spectrogram represents time, the vertical direction represents frequency. The time scale of the spectrogram is the same as that of the waveform, so the spectrogram reacts to your zooming and scrolling. To the left of the spectrogram, you see the frequency scale. The frequency at the bottom of the spectrogram is usually 0 Hz (hertz, cps, cycles per second), and a common value for the frequency at the top is 5000 Hz. Darker parts of the spectrogram mean higher energy densities, lighter parts mean lower energy densities. If the spectrogram has a dark area around a time of 1.2 seconds and a frequency of 4000 Hz, this means that the sound has lots of energy for those high frequencies at that time. For many examples of spectrograms of speech sounds, see the textbook by Ladefoged (2001) and the reference work by Ladefoged & Maddieson (1996). To see what time and frequency a certain part of the spectrogram is associated with, just click on the spectrogram and you will see the vertical time cursor showing the time above the waveform and the horizontal frequency cursor showing the frequency to the left of the spectrogram. This is one of the ways to find the formant frequencies for vowels, or the main spectral peaks for fricatives. Hey, there are white vertical stripes at the edges! This is normal. Spectral analysis requires an analysis window of a certain duration. For instance, if Praat wants to know the spectrum at 1.342 seconds, it needs to include information about the signal in a 10-milliseconds window around this time point, i.e., Praat will use signal information about all times between 1.337 and 1.347 seconds. At the very edges of the sound, this information is not available: if the sound runs from 0 to 1.8 seconds, no spectrum can be computed between 0 and 0.005 seconds or between 1.795 and 1.800 seconds. Hence the white stripes. If you do not see them immediately when you open the sound, zoom in on the beginning or end of the sound. When you zoom in on the middle of the sound (or anywhere not near the edges), the white stripes vanish. Suddenly you see only the time stretch between 0.45 and 1.35 seconds, for instance. But Praat did not forget what the signal looks like just outside the edges of this time window. To display a spectrogram from 0.45 to 1.35 seconds, Praat will use information from the wave form between 0.445 and 1.355 seconds, and if this is available, you will see no white stripes at the edges of the window. Hey, it changes when I scroll! This is normal as well, especially for long windows. If your visible time window is 20 seconds long, and the window takes up 1000 screen pixels horizontally, then you might think that every one-pixel-wide vertical line should represent the spectrum of 20 milliseconds of sound. But for reasons of computation speed, Praat will only show the spectrum of the part of the sound that lies around the centre of those 20 milliseconds, not the average or sum of all the spectra in those 20 milliseconds. This undersampling of the underlying spectrogram is different from what happens in the drawing of the wave form, where a vertical black line connects the minimum and maximum amplitude of all the samples that fall inside a screen pixel. We cannot do something similar for spectrograms. And since scrolling goes by fixed time steps (namely, 5 percent of the duration of the visible window), rather than by a whole number of screen pixels, the centres of the pixels will fall in different parts of the spectrogram with each scroll. Hence the apparent changes. If your visible window is shorter than a couple of seconds, the scrolling spectrogram will appear much smoother. The darkness of the spectrogram will also change when you scroll, because the visible part with the most energy is defined as black. When a very energetic part of the signal scrolls out of view, the spectrogram will turn darker. The next section will describe a way to switch this off. Links to this page Intro Intro 3. Spectral analysis 
Intro_3_2__Configuring_the_spectrogram	Intro 3.2. Configuring the spectrogram With Spectrogram settings... from the Spectrogram menu, you can determine how the spectrogram is computed and how it is displayed. These settings will be remembered across Praat sessions. All these settings have standard values (factory settings), which appear when you click Standards. View range (Hz) the range of frequencies to display. The standard is 0 Hz at the bottom and 5000 Hz at the top. If this maximum frequency is higher than the Nyquist frequency of the Sound (which is half its sampling frequency), some values in the spectrogram will be zero, and the higher frequencies will be drawn in white. You can see this if you record a Sound at 44100 Hz and set the view range from 0 Hz to 25000 Hz. Window length the duration of the analysis window. If this is 0.005 seconds (the standard), Praat uses for each frame the part of the sound that lies between 0.0025 seconds before and 0.0025 seconds after the centre of that frame (for Gaussian windows, Praat actually uses a bit more than that). The window length determines the bandwidth of the spectral analysis, i.e. the width of the horizontal line in the spectrogram of a pure sine wave (see below). For a Gaussian window, the -3 dB bandwidth is 2*sqrt(6*ln(2))/(π*Window length), or 1.2982804 / Window length. To get a `broad-band' spectrogram (bandwidth 260 Hz), keep the standard window length of 5 ms; to get a `narrow-band' spectrogram (bandwidth 43 Hz), set it to 30 ms (0.03 seconds). The other window shapes give slightly different values. Dynamic range (dB) All values that are more than Dynamic range dB below the maximum (perhaps after dynamic compression, see Advanced spectrogram settings...) will be drawn in white. Values in-between have appropriate shades of grey. Thus, if the highest peak in the spectrogram has a height of 30 dB/Hz, and the dynamic range is 50 dB (which is the standard value), then values below -20 dB/Hz will be drawn in white, and values between -20 dB/Hz and 30 dB/Hz will be drawn in various shades of grey. The bandwidth To see how the window length influences the bandwidth, first create a 1000-Hz sine wave with Create Sound from formula... by typing 1/2 * sin (2*pi*1000*x) as the formula, then click View & Edit. The spectrogram will show a horizontal black line. You can now vary the window length in the spectrogram settings and see how the thickness of the lines varies. The line gets thinner if you raise the window length. Apparently, if the analysis window comprises more periods of the wave, the spectrogram can tell us the frequency of the wave with greater precision. To see this more precisely, create a sum of two sine waves, with frequencies of 1000 and 1200 Hz. the formula is 1/4 * sin (2*pi*1000*x) + 1/4 * sin (2*pi*1200*x). In the editor, you will see a single thick band if the analysis window is short (5 ms), and two separate bands if the analysis window is long (30 ms). Apparently, the frequency resolution gets better with longer analysis windows. So why don't we always use long analysis windows? The answer is that their time resolution is poor. To see this, create a sound that consists of two sine waves and two short clicks. The formula is 0.02*(sin(2*pi*1000*x)+sin(2*pi*1200*x)) + (col=10000)+(col=10200). If you view this sound, you can see that the two clicks will overlap in time if the analysis window is long, and that the sine waves overlap in frequency if the analysis window is short. Apparently, there is a trade-off between time resolution and frequency resolution. One cannot know both the time and the frequency with great precision. Advanced settings The Spectrum menu also contains Advanced spectrogram settings.... Links to this page Intro Intro 3. Spectral analysis Intro 3.7. Configuring the spectral slice 
Intro_3_3__Querying_the_spectrogram	Intro 3.3. Querying the spectrogram If you click anywhere inside the spectrogram, a cursor cross will appear, and you will see the time and frequency in red at the top and to the left of the window. To see the time in the Info window, choose Get cursor from the Query menu or press the F6 key. To see the frequency in the Info window, choose Get frequency from the Spectrum menu. To query the power of the spectrogram at the cursor cross, choose Get spectral power at cursor cross from the Spectrum menu or press the F9 key. The Info window will show you the power density, expressed in Pascal2/Hz. Links to this page Intro Intro 3. Spectral analysis 
Intro_3_4__Printing_the_spectrogram	Intro 3.4. Printing the spectrogram To print a spectrogram, or to put it in an EPS file or on the clipboard for inclusion in your word processor, you first have to paint it into the Picture window. You do this by choosing Paint visible spectrogram... from the Spectrum menu in the Sound or TextGrid window. From the File menu in the Picture window, you can then print it, save it to an EPS file, or copy it to the clipboard (to do Paste in your word processor, for instance). Links to this page Intro Intro 3. Spectral analysis 
Intro_3_5__The_Spectrogram_object	Intro 3.5. The Spectrogram object To do more with spectrograms, you can create a Spectrogram object in the List of Objects. You do this either by choosing Extract visible spectrogram from the Spectrum menu in the Sound or TextGrid window, or by selecting a Sound object in the list and choosing Sound: To Spectrogram... from the Spectrum menu. In either case, a new Spectrogram object will appear in the list. To draw this Spectrogram object to the Picture window, select it and choose the Spectrogram: Paint... command. From the Picture window, you can print it, save it to an EPS file, or copy it to the clipboard. Many other commands are available in the dynamic menu. Links to this page Intro Intro 3. Spectral analysis 
Intro_3_6__Viewing_a_spectral_slice	Intro 3.6. Viewing a spectral slice With View spectral slice from the Spectrum menu in the SoundEditor and the TextGridEditor, you can see the frequency spectrum at the time cursor or the average frequency spectrum in the time selection. Spectral slice at the cursor If you click anywhere in the wave form of the SoundEditor or TextGridEditor windows, a cursor will appear at that time. If you then choose View spectral slice, Praat will create a Spectrum object named slice in the Objects window and show it in a SpectrumEditor window. In this way, you can inspect the frequency contents of the signal around the cursor position. Spectral slice from a selection If you drag the mouse through the wave form of the SoundEditor or TextGridEditor windows, a time selection will appear. If you then choose View spectral slice, Praat will again create a Spectrum object named slice in the Objects window and show it in a SpectrumEditor window. In this way, you can inspect the frequency contents of the signal in the selection. Links to this page Intro Intro 3. Spectral analysis Keyboard shortcuts What was new in 4.1? 
Intro_3_7__Configuring_the_spectral_slice	Intro 3.7. Configuring the spectral slice Spectral slice at the cursor What Praat does precisely, depends on your Spectrogram settings. Suppose that the window length setting is 0.005 seconds (5 milliseconds). If the window shape is not Gaussian, Praat will extract the part of the sound that runs from 2.5 milliseconds before the cursor to 2.5 ms after the cursor. Praat then multiplies this 5 ms long signal by the window shape, then computes a spectrum with the method of Sound: To Spectrum..., which is put into the Objects window and opened in an editor window. If the window shape is Gaussian, Praat will extract a part of the sound that runs from 5 milliseconds before the cursor to 5 ms after the cursor. The spectrum will then be based on a `physical' window length of 10 ms, although the `effective' window length is still 5 ms (see Intro 3.2. Configuring the spectrogram for details). Spectral slice from a selection What Praat does precisely, again depends on the window shape of your Spectrogram settings. Suppose that your selection is 50 ms long. Praat will extract the entire selection, then multiply this 50 ms long signal by the window shape, then compute a spectrum, put it into the Objects window and open it an editor window. This procedure is equivalent to choosing Extract windowed selection... (with a relative duration of 1.0), followed by To Spectrum... (with fast switched on), followed by Edit. If the window is Gaussian, Praat will still only use the selection, without doubling its duration. This means that the spectrum that you see in this case will mainly be based on the centre half of the selection, and the signal near the edges will be largely ignored. Links to this page Intro Intro 3. Spectral analysis 
Intro_3_8__The_Spectrum_object	Intro 3.8. The Spectrum object To compute a Fourier frequency spectrum of an entire sound, select a Sound object and choose To Spectrum... from the Spectrum menu. A new Spectrum object will appear in the List of Objects. To view or modify it (or listen to its parts), click View & Edit. To print it, choose one of the Draw commands to draw the Spectrum object to the Picture window first. Links to this page Intro Intro 3. Spectral analysis 
Intro_3__Spectral_analysis	Intro 3. Spectral analysis This section describes how you can analyse the spectral content of an existing sound. You will learn how to use spectrograms and spectral slices. Intro 3.1. Viewing a spectrogram Intro 3.2. Configuring the spectrogram Intro 3.3. Querying the spectrogram Intro 3.4. Printing the spectrogram Intro 3.5. The Spectrogram object Intro 3.6. Viewing a spectral slice Intro 3.7. Configuring the spectral slice Intro 3.8. The Spectrum object Links to this page Acknowledgments Extract visible spectrogram Intro Show spectrogram Sound: To Spectrogram... Spectrogram Types of objects 
Intro_4_1__Viewing_a_pitch_contour	Intro 4.1. Viewing a pitch contour To see the pitch contour of an existing sound as a function of time, select a Sound or LongSound object and choose View & Edit. A SoundEditor window will appear on your screen. The bottom half of this window will contain a pitch contour, drawn as a blue line or as a sequence of blue dots. If you do not see the pitch contour, choose Show pitch from the Pitch menu. To the right of the window, you may see three pitch values, written with blue digits: at the bottom, you see the floor of the viewable pitch range, perhaps 75 Hz; at the top, you see the ceiling of the pitch range, perhaps 600 Hz; and somewhere in between, you see the pitch value at the cursor, or the average pitch in the selection. Links to this page Intro Intro 4. Pitch analysis 
Intro_4_2__Configuring_the_pitch_contour	Intro 4.2. Configuring the pitch contour With Pitch settings... from the Pitch menu, you can determine how the pitch contour is displayed and how it is computed. These settings will be remembered across Praat sessions. All these settings have standard values (factory settings), which appear when you click Standards. The pitch range setting This is the most important setting for pitch analysis. The standard range is from 75 to 500 hertz, which means that the pitch analysis method will only find values between 75 and 500 Hz. The range that you set here will be shown to the right of the analysis window. For a male voice, you may want to set the floor to 75 Hz, and the ceiling to 300 Hz; for a female voice, set the range to 100-500 Hz instead. For creaky voice you will want to set it much lower than 75 Hz. Here is why you have to supply these settings. If the pitch floor is 75 Hz, the pitch analysis method requires a 40-millisecond analysis window, i.e., in order to measure the F0 at a time of, say, 0.850 seconds, Praat needs to consider a part of the sound that runs from 0.830 to 0.870 seconds. These 40 milliseconds correspond to 3 maximum pitch periods (3/75 = 0.040). If you set the pitch floor down to 25 Hz, the analysis window will grow to 120 milliseconds (which is again 3 maximum pitch periods), i.e., all times between 0.790 and 0.910 seconds will be considered. This makes it less easy to see fast F0 changes. So setting the floor of the pitch range is a technical requirement for the pitch analysis. If you set it too low, you will miss very fast F0 changes, and if you set it too high, you will miss very low F0 values. For children's voices you can often use 200 Hz, although 75 Hz will still give you the same time resolution as you get for the males. The units setting This setting determines the units of the vertical pitch scale. Most people like to see the pitch range in hertz, but there are several other possibilities. Advanced settings The Pitch menu also contains Advanced pitch settings.... Links to this page Intro Intro 4. Pitch analysis Intro 6.2. Configuring the intensity contour 
Intro_4_3__Querying_the_pitch_contour	Intro 4.3. Querying the pitch contour With Get pitch from the Pitch menu in the SoundEditor or TextGridEditor, you get information about the pitch at the cursor or in the selection. If a cursor is visible in the window, Get pitch writes to the Info window the linearly interpolated pitch at that time; if a time selection is visible inside the window, Get pitch writes to the Info window the mean (average) pitch in the visible part of that selection; otherwise, Get pitch writes the average pitch in the visible part of the sound. Links to this page Intro Intro 4. Pitch analysis 
Intro_4_4__Printing_the_pitch_contour	Intro 4.4. Printing the pitch contour To print a pitch contour, or to put it in an EPS file or on the clipboard for inclusion in your word processor, you first have to draw it into the Picture window. You do this by choosing Draw visible pitch contour... from the Pitch menu in the Sound or TextGrid window. From the File menu in the Picture window, you can then print it, save it to an EPS file, or copy it to the clipboard (to do Paste in your word processor, for instance). Links to this page Intro Intro 4. Pitch analysis 
Intro_4_5__The_Pitch_object	Intro 4.5. The Pitch object The pitch contour that is visible in the SoundEditor or TextGridEditor window, can be copied as a separate Pitch object to the List of Objects. To do this, choose Extract visible pitch contour from the Pitch menu. Another way to get a separate Pitch object is to select a Sound object in the list choose Sound: To Pitch... (preferred) or any of the other methods from the Periodicity menu. To view and modify the contents of a Pitch object, select it and choose View & Edit. This creates a PitchEditor window on your screen. To save a pitch contour to disk, select the Pitch object in the list and choose one of the commands in the Save menu. Later on, you can read the saved file again with Read from file... from the Open menu. To draw a Pitch object to the Picture window, select it and choose any of the commands in the Draw menu. From the Picture window, you can print it, save it to an EPS file, or copy it to the clipboard for inclusion in your word processor. Links to this page Intro Intro 4. Pitch analysis 
Intro_4__Pitch_analysis	Intro 4. Pitch analysis This section describes how you can analyse the pitch contour of an existing sound. Intro 4.1. Viewing a pitch contour Intro 4.2. Configuring the pitch contour Intro 4.3. Querying the pitch contour Intro 4.4. Printing the pitch contour Intro 4.5. The Pitch object Links to this page Acknowledgments Extract visible pitch contour Intro Pitch Show pitch Types of objects 
Intro_5_1__Viewing_formant_contours	Intro 5.1. Viewing formant contours To see the formant contours of a sound as functions of time, select a Sound or LongSound object and choose View & Edit. A SoundEditor window will appear on your screen. The analysis part of this window will contain formant contours, drawn as red speckles. If you do not see the formant contours, choose Show formant from the Formant menu. Links to this page Intro Intro 5. Formant analysis 
Intro_5_2__Configuring_the_formant_contours	Intro 5.2. Configuring the formant contours The formant analysis parameters, with you can set with the Formant menu, are important. For a female voice, you may want to set the maximum frequency to 5500 Hz; for a male voice, set it to 5000 Hz instead. For more information about analysis parameters, see Sound: To Formant (burg).... Links to this page Intro Intro 5. Formant analysis 
Intro_5_3__Querying_the_formant_contours	Intro 5.3. Querying the formant contours With Get first formant from the Formant menu in the SoundEditor or TextGridEditor, you get information about the first formant at the cursor or in the selection. If there is a cursor, Get first formant writes to the Info window the linearly interpolated first formant at that time. If there is a true selection, Get first formant writes to the Info window the mean first formant in the visble part of that selection. The same goes for Get second formant and so on. Links to this page Intro Intro 5. Formant analysis 
Intro_5_4__The_Formant_object	Intro 5.4. The Formant object The formant contours that are visible in the SoundEditor or TextGridEditor window, can be copied as a separate Formant object to the List of Objects. To do this, choose Extract visible formant contour from the Formant menu. Another way to get a separate Formant object is to select a Sound object in the list choose Sound: To Formant (burg)... (preferred) or any of the other methods from the Formants & LPC menu. Saving formant contours to disk To save formant contours to disk, select the Formant object in the list and choose one of the commands in the Save menu. Later on, you can read the saved file again with Read from file... from the Open menu. Drawing formant contours To draw a Formant object to the Picture window, select it and choose any of the commands in the Draw menu. From the Picture window, you can print it, save it to an EPS file, or copy it to the clipboard for inclusion in your word processor. Links to this page Intro Intro 5. Formant analysis 
Intro_5__Formant_analysis	Intro 5. Formant analysis This section describes how you can analyse the formant contours of an existing sound. Intro 5.1. Viewing formant contours Intro 5.2. Configuring the formant contours Intro 5.3. Querying the formant contours Intro 5.4. The Formant object Links to this page Acknowledgments Extract visible formant contour Intro Show formant Types of objects 
Intro_6_1__Viewing_an_intensity_contour	Intro 6.1. Viewing an intensity contour To see the intensity contour of a sound as a function of time, select a Sound or LongSound object and choose View & Edit. A SoundEditor window will appear on your screen. The analysis part of this window will contain an intensity contour, drawn as a yellow or green line (choose Show intensity from the Intensity menu if it is not visible). This also works in the TextGridEditor. Links to this page Intro Intro 6. Intensity analysis 
Intro_6_2__Configuring_the_intensity_contour	Intro 6.2. Configuring the intensity contour With Intensity settings... from the Intensity menu, you can control how the intensity contour is computed and how it is shown. The view range By changing these two numbers you can set the vertical scale. The standard setting is from 50 to 100 dB, but if you are interested in the power of the background noise you may want to set it to the range from 0 to 100 dB. The averaging method Averaging is what occurs if you make a time selection (rather than setting the cursor at a single time). The green number in dB to the left or right side of the intensity contour will show the average intensity in the selection. The same value is what you get when choosing Get intensity from the Intensity menu. You can choose any of the three averaging methods available for Intensity: Get mean..., or choose for the median value in the selection. Pitch floor The intensity curve is smoothed, since you usually do not want the intensity curve to go up and down with the intensity variations within a pitch period. To avoid such pitch-synchronous variations, the intensity at every time point is a weighted average over many neighbouring time points. The weighting is performed by a Gaussian (`double Kaiser') window that has a duration that is determined by the Minimum pitch setting (see Intro 4.2. Configuring the pitch contour). To see more detail than usual, raise the minimum pitch; to get more smoothing than usual, lower it. For more information, see Sound: To Intensity.... Subtract mean pressure or not? Many microphones, microphone preamplifiers, or other components in the recording system can add a constant level to the air pressure (a DC offset). You can see this at quiet locations in the wave form, where the average pressure is not zero but the background noise hovers about some non-zero value. You will usually not want to take this constant pressure seriously, i.e. the intensity curve should normally not take into account the energy provided by this constant pressure level. If you switch on the Subtract mean pressure switch (whose standard setting is also on), the intensity value at a time point is computed by first subtracting the mean pressure around this point, and then applying the Gaussian window. Links to this page Intro Intro 6. Intensity analysis 
Intro_6_3__Querying_the_intensity_contour	Intro 6.3. Querying the intensity contour To ask for the intensity at the cursor, or the average intensity in the visible part of the selection, choose Get intensity from the Intensity menu or press the F11 key. You get the same value in dB that is visible to the left or right side of the intensity curve, but with more digits. Links to this page Intro Intro 6. Intensity analysis 
Intro_6_4__The_Intensity_object	Intro 6.4. The Intensity object To print an intensity contour, or to put it in an EPS file or on the clipboard for inclusion in your word processor, you first have to create an Intensity object in the List of Objects. You do this either by choosing Extract visible intensity contour from the Intensity menu in the SoundEditor or TextGridEditor window, or by selecting a Sound object in the list and choosing Sound: To Intensity.... In either case, a new Intensity object will appear in the list. To draw the Intensity object to the Picture window, select it and choose Draw.... From the Picture window, you can print it, save it to an EPS file, or copy it to the clipboard. Links to this page Intro Intro 6. Intensity analysis 
Intro_6__Intensity_analysis	Intro 6. Intensity analysis This section describes how you can analyse the intensity contour of an existing sound. Intro 6.1. Viewing an intensity contour Intro 6.2. Configuring the intensity contour Intro 6.3. Querying the intensity contour Intro 6.4. The Intensity object Links to this page Acknowledgments Extract visible intensity contour Intro Show intensity Types of objects 
Intro_7__Annotation	Intro 7. Annotation You can annotate existing Sound objects and sound files (LongSound objects). The labelling data will reside in a TextGrid object. This object is separate from the sound, which means that you will often see two objects in the list: a Sound or LongSound, and a TextGrid. Creating a TextGrid You create a new empty TextGrid from the Sound or LongSound with Sound: To TextGrid... or LongSound: To TextGrid... from the Annotate menu (which shows up in the Objects window if you select a Sound or LongSound). In this way, the time domain of the TextGrid will automatically equal that of the sound (if you choose Create TextGrid... from the New menu instead, you will have to supply the time domain by yourself). When you create a TextGrid, you specify the names of the tiers. For instance, if you want to segment the sound into words and into phonemes, you may want to create two tiers and call them words and phonemes (you can easily add, remove, and rename tiers later). Since both of these tiers are interval tiers (you label the intervals between the word and phoneme boundaries, not the boundaries themselves), you specify phonemes words for Tier names, and you leave the Point tiers empty. View and edit You can edit a TextGrid object all by itself, but you will normally want to see the sound in the editor window as well. To achieve this, you select both the Sound (or LongSound) and the TextGrid, and click View & Edit. A TextGridEditor will appear on your screen. Like the Sound editor, the TextGrid editor will show you a spectrogram, a pitch contour, a formant contour, and an intensity contour. This editor will allow you to add, remove, and edit labels, boundaries, and tiers. Under Help in the TextGridEditor, you will find the TextGridEditor manual page. You are strongly advised to read it, because it will show you how you can quickly zoom (drag the mouse), play (click a rectangle), or edit a label (just type). Save You will normally write the TextGrid to disk with Save as text file... or Save as short text file.... It is true that Save as binary file... will also work, but the others give you a file you can read with any text editor. However you saved it, you can read the TextGrid into Praat later with Read from file.... Links to this page Acknowledgments Intro Labelling Segmentation Types of objects 
Intro_8_1__Manipulation_of_pitch	Intro 8.1. Manipulation of pitch To modify the pitch contour of an existing Sound object, you select this Sound and click To Manipulation. A Manipulation object will then appear in the list. You can then click View & Edit to raise a ManipulationEditor, which will show the pitch contour (PitchTier) as a series of thick dots. To reduce the number of dots, choose Stylize pitch (2 st) from the Pitch menu; it will then be easy to drag the dots about the time-pitch area. If you click any of the rectangles (or choose any of the Play commands from the View menu), you will hear the modified sound. By shift-clicking, you will hear the original sound. To get the modified sound as a separate object, choose Publish resynthesis from the File menu. If you modify the duration curve as well (see Intro 8.2. Manipulation of duration), the modified sound will be based on the modified pitch and duration. Cloning a pitch contour To use the pitch contour of one Manipulation object as the pitch contour of another Manipulation object, you first choose Extract pitch tier for the first Manipulation object, then select the resulting PitchTier object together with the other Manipulation object (e.g. by a click on the PitchTier and a Command-click on the Manipulation), and choose Replace pitch tier. Precise manipulation of pitch If you know exactly what pitch contour you want, you can create an empty PitchTier with Create PitchTier... from the New menu, then add points with PitchTier: Add point.... For instance, suppose you want to have a pitch that falls from 350 to 150 Hz in one second. You create the PitchTier, then add a point at 0 seconds and a frequency of 350 Hz, and a point at 1 second with a frequency of 150 Hz. You can put this PitchTier into a Manipulation object in the way described above. Links to this page Intro Intro 8. Manipulation Intro 8.3. Manipulation of intensity Types of objects 
Intro_8_2__Manipulation_of_duration	Intro 8.2. Manipulation of duration You can use Praat to modify the relative durations in an existing sound. First, you select a Sound object and click To Manipulation. A Manipulation object will then appear in the list. You can then click View & Edit to raise a ManipulationEditor, which will show an empty DurationTier. You can add targets to this tier by choosing Add duration point at cursor from the Dur menu. The targets will show up as green dots, which you can easily drag about the duration area. If you click any of the rectangles (or choose any of the Play commands from the View menu), you will hear the modified sound. By shift-clicking, you will hear the original sound. To get the modified sound as a separate object, choose Publish resynthesis from the File menu. If you modify the pitch curve as well (see Intro 8.1. Manipulation of pitch), the modified sound will be based on the modified duration and pitch. Precise manipulation of duration If you know exactly the times and relative durations, it is advisable to write a script (see Scripting). Suppose, for instance, that you have a 355-ms piece of sound, and you want to shorten the first 85 ms to 70 ms, and the remaining 270 ms to 200 ms. In your first 85 ms, your relative duration should be 70/85, and during the last 270 ms, it should be 200/270. The DurationTier does linear interpolation, so it can only be approximate these precise times, but fortunately to any precision you like: Create DurationTier: shorten, 0, 0.085 + 0.270 Add point: 0.000 70/85 Add point: 0.084999, 70/85 Add point: 0.085001, 200/270 Add point: 0.355, 200/270 To put this DurationTier back into a Manipulation object, you select the two objects together (e.g. a click on the DurationTier and a Command-click on the Manipulation), and choose Replace duration tier. Links to this page Intro Intro 8. Manipulation Intro 8.3. Manipulation of intensity Types of objects 
Intro_8_3__Manipulation_of_intensity	Intro 8.3. Manipulation of intensity You can modify the intensity contour of an existing sound. While the pitch and duration of a sound can be modified with the ManipulationEditor (see Intro 8.1. Manipulation of pitch and Intro 8.2. Manipulation of duration), the modification of the intensity curve is done in a different way. You can create an IntensityTier with the command Create IntensityTier... from the New menu. With View & Edit, you can add points to this tier. You can then multiply this tier with a sound, by selecting the Sound and the IntensityTier together and clicking Multiply. The points in the IntensityTier represent relative intensities in dB; therefore, the sound pressure values in the Sound are multiplied by 10(dB/20). Instead of an IntensityTier, you can use an AmplitudeTier; when you click Multiply for a selected Sound and AmplitudeTier, the sound pressure values in the Sound are directly multiplied by the values in the AmplitudeTier. Links to this page Intro Intro 8. Manipulation Types of objects 
Intro_8_4__Manipulation_of_formants	Intro 8.4. Manipulation of formants The manipulation of formant contours cannot be as straightforward as the manipulation of pitch, duration, or intensity contours. See the Source-filter synthesis tutorial for an explanation of how formants can be modified in Praat. Links to this page Intro 
Intro_8__Manipulation	Intro 8. Manipulation Intro 8.1. Manipulation of pitch Intro 8.2. Manipulation of duration Intro 8.3. Manipulation of intensity Links to this page Acknowledgments Intro 
invFisherQ	invFisherQ invFisherQ (q, df1, df2) returns the value f for which fisherQ (f, df1, df2) = q. Links to this page SSCP: Get confidence ellipse area... 
Irino___Patterson__1997_	Irino & Patterson (1997) T. Irino & R.D. Patterson (1997): A time-domain, level-dependent auditory filter: The gammachirp. Journal of the Acoustical Society of America 101: 412–419. Links to this page Create Sound from gammatone... 
iris_data_set	iris data set A data set with 150 random samples of flowers from the iris species setosa, versicolor, and virginica collected by Anderson (1935). From each species there are 50 observations for sepal length, sepal width, petal length, and petal width in cm. This dataset was used by Fisher (1936) in his initiation of the linear-discriminant-function technique. Links to this page Create iris example... Feedforward neural networks 2. Quick start kNN classifiers 2. Quick start 
Ishizaka___Flanagan__1972_	Ishizaka & Flanagan (1972) Kenzo Ishizaka & James L. Flanagan (1972): Synthesis of voiced sounds from a two-mass model of the vocal cords. Bell System Technical Journal 51: 1233-1268. Reprinted in: James L. Flanagan & Lawrence R. Rabiner (eds.) (1973): Speech Synthesis, Dowden, Hutchinson & Ross, Stroudsburg. The authors show that if we model each vocal cord as two coupled mass-spring systems, the passive vibration that results from the interaction with a glottal airflow will show more realistic behaviour than with the one-mass model of Flanagan & Landgraf (1968), at least for a male speaker. 
ISpline	ISpline One of the types of objects in PRAAT. An object of type ISpline represents a linear combination of basis ispline functions. Each basis ispline is a monotonically increasing polynomial function of degree p. ISpline (x) = Σk=1..numberOfCoefficients ck isplinek(x) Links to this page Create ISpline... 
Jackknife	Jackknife A technique for estimating the bias and standard deviation of an estimate. Suppose we have a sample x = (x1, x2,...xn) and wish to estimate the bias and standard error of an estimator Θ. The jackknife focuses on the samples that leave out one observation at a time: the i-th jackknife sample consists of the data with the i-th observation removed. Links to this page Discriminant analysis 
Jäger__2003_	Jäger (2003) Gerhard Jäger (2003): Maximum Entropy Models and Stochastic Optimality Theory. To appear in Jane Grimshaw, Joan Maling, Chris Manning, Jane Simpson, and Annie Zaenen (eds.): Architectures, rules, and preferences: A Festschrift for Joan Bresnan, CSLI Publications, Stanford. Links to this page OT learning 1. Kinds of grammars OT learning 4. Learning an ordinal grammar What was new in 4.6? 
Jesteadt__Wier___Green__1977_	Jesteadt, Wier & Green (1977) W. Jesteadt, G.C. Wier, & D.M. Green (1977): Intensity discrimination as a function of frequency and sensation level. Journal of the Acoustical Society of America 61: 169–177. Links to this page phonToDifferenceLimens 
Johannesma__1972_	Johannesma (1972) P.I.M. Johannesma (1972): The pre-response stimulus ensemble of neurons in the cochlear nucleus. In Symposium on Hearing Theory (IPO, Eindhoven, Holland), 58–69. Links to this page gammatone 
Johnson__1998_	Johnson (1998) D.E. Johnson (1998): Applied Multivariate methods. Links to this page SSCP: Get confidence ellipse area... 
k-means_clustering	k-means clustering This tutorial describes the use of k-means clustering in Praat. 1. How does k-means clustering work? 2. Quick start Links to this page Acknowledgments Pattern & FeatureWeights: To Categories... Pattern: To Categories... What was new in 5.1? 
k-means_clustering_1__How_does_k-means_clustering_work_	k-means clustering 1. How does k-means clustering work? The k-means clustering algorithm attempts to split a given anonymous data set (a set containing no information as to class identity) into a fixed number (k) of clusters. Initially k number of so called centroids are chosen. A centroid is a data point (imaginary or real) at the center of a cluster. In Praat each centroid is an existing data point in the given input data set, picked at random, such that all centroids are unique (that is, for all centroids ci and cj, ci ≠ cj). These centroids are used to train a kNN classifier. The resulting classifier is used to classify (using k = 1) the data and thereby produce an initial randomized set of clusters. Each centroid is thereafter set to the arithmetic mean of the cluster it defines. The process of classification and centroid adjustment is repeated until the values of the centroids stabilize. The final centroids will be used to produce the final classification/clustering of the input data, effectively turning the set of initially anonymous data points into a set of data points, each with a class identity. Links to this page k-means clustering 
k-means_clustering_2__Quick_start	k-means clustering 2. Quick start Clustering using the k-means clustering algorithm in Praat is done by selecting a Pattern and choosing To Categories.... In the appearing requester the number of sought after clusters (unique categories) can be specified. The cluster size ratio constraint (z) imposes a constraint on the output such that cluster size(x) / cluster size(y) > z for all clusters x and y in the resulting set of clusters. Valid values of z are 0 < z <= 1 where values near 0 imposes practically no constraints on the cluster sizes and a value of 1 tells the algorithm to attempt to create clusters of equal size. The size ratio constraint is enforced in a very naive fashion, by random reseeding. Since this can be a rather time consuming process it is possible to set an upper bound on the number of reseeds done by the algorithm. This upper bound is defined by the parameter Maximum number of reseeds. It should be noted however that normally there's no need to use the size ratio constraint, selecting the desired number of clusters will, on average, result in clusters of roughly equal size, given well distributed data. Links to this page k-means clustering 
Kaiser__1958_	Kaiser (1958) H.F. Kaiser (1958): The varimax criterion for analytic rotation in factor analysis. Psychometrika 23: 187–200. Links to this page Configuration: To Configuration (varimax)... 
Ke-Ping_Zhao_et_al___2003_	Ke-Ping Zhao et al. (2003) Ke-Ping Zhao et al. (2003): C-Pruner: An improved instance pruning algorithm. In Proceedings of the Second International Conference on Machine Learning and Cybernetics, November 2003, 94–99. Links to this page kNN classifiers 1.2.1. Pruning 
Keating___Esposito__2006_	Keating & Esposito (2006) P.A. Keating & C. Esposito (2006): Linguistic voice quality. UCLA Working Papers in Phonetics 105: 85–91. Links to this page Table: Bar plot where... 
Keyboard_shortcuts	Keyboard shortcuts A way to accelerate the control of Editors in Praat. Purpose to choose a menu command with the keyboard. All of these commands can also be chosen from a menu. Command key When mentioning the Command key, this manual refers to the key that is marked with an apple on Apple keyboards or to the key that is marked Ctrl if you are on a Windows or Linux computer. Option key When mentioning the Option key, this manual refers to the key marked alt or option. In Praat, this key is sometimes used together with the Command key for destructive actions that are the reverse of the actions invoked by using the Command key only. For instance, if Command-T means add a target at the cursor position, Option-Command-T may mean remove the selected targets. Shortcuts Command-A: Zoom all Command-C: Copy (the selected text, or the selected sound, or the selected part of the Picture window) Command-D (in Manipulation window): Insert duration point at cursor Option-Command-D (in Manipulation window): Remove selected duration points Command-E (in Picture window): Erase all Shift-Command-H: Move cursor to maximum pitch Command-I: Zoom in Command-L (in Objects window): Open long sound file... Command-L (in sound windows): View spectral slice Shift-Command-L: Move cursor to minimum pitch Command-M: Search Praat manual... Command-N: Zoom to selection Command-O (in Objects window): Read from file... Command-O (in sound windows): Zoom out Command-P (in Picture window): Print Command-P (in Manipulation window): Add pulse at cursor Option-Command-P (in Manipulation window): Remove selected pulses Command-Q: Quit Command-R: Reverse selection Command-S: Save Command-T (in Manipulation window): Add pitch point at cursor Option-Command-T (in Manipulation window): Remove selected pitch points Command-U: Calculator... Command-V: Paste (insert the text or sound clipboard over the selected text or the selected sound) Command-W: Close window Command-X: Cut (the selected text or the selected sound) Command-Y: Redo Command-Z: Undo Command-0: Move cursor to nearest zero crossing Command-2 (in Manipulation window): Stylize pitch (2 semitones) Command-4 (in Manipulation window): Interpolate quadratically (4 points) Shift-Command-?: Local help Command-,: Move start of selection to nearest zero crossing Command-.: Move end of selection to nearest zero crossing F5: Get pitch Command-F5: Get minimum pitch Shift-F5: Get maximum pitch F1: Get first formant F2: Get second formant F3: Get third formant F4: Get fourth formant F5: Get pitch F6: Get cursor F7: Get spectral power at cursor cross F8: Get intensity F12: Log 1 Shift-F12: Log 2 Option-F12: Log script 3 Command-F12: Log script 4 Tab (in sound windows): Play selection Shift-Tab (in sound windows): Play window Arrow-up (in sound windows): Select earlier Arrow-down (in sound windows): Select later Shift-Arrow-up (in sound windows): Move start of selection left Shift-Arrow-down (in sound windows): Move start of selection right Command-Arrow-up (in sound windows): Move end of selection left Command-Arrow-down (in sound windows): Move end of selection right Page-up (in sound windows): Scroll page back Page-down (in sound windows): Scroll page forward Escape: Interrupt playing 
Khuri__1998_	Khuri (1998) A. Khuri (1998): Unweighted sums of squares in unbalanced analysis of variance., Journal of Statistical Planning and Inference 74: 135–147. Links to this page Table: Report two-way anova... 
Kiers___Groenen__1996_	Kiers & Groenen (1996) H.A.L. Kiers & P. Groenen (1996): A monotonically convergent algorithm for orthogonal congruence rotation. Psychometrika 61: 375–389. Links to this page Configurations: To AffineTransform (congruence)... 
Kim___Kim__2006_	Kim & Kim (2006) D.H. Kim & M.-J. Kim (2006): An extension of polygon clipping to resolve degenerate cases. Computer-Aided Design & Applications 3: 447–456. 
Kirshenbaum_phonetic_encoding	Kirshenbaum phonetic encoding The Kirshenbaum phonetic encoding represents International Phonetic Alphabet symbols using ascii characters. See: http://www.kirshenbaum.net/IPA/ascii-ipa.pdf. The espeak speech synthesizer on which our synthesizer is based accepts this encoding as text input. Links to this page SpeechSynthesizer: Play text... SpeechSynthesizer: To Sound... 
Klatt___Klatt__1990_	Klatt & Klatt (1990) D.H. Klatt & L.C. Klatt (1990): Analysis, synthesis and perception of voice quality variations among male and female talkers. Journal of the Acoustical Society of America 87: 820–856. Links to this page KlattGrid PointProcess: To Sound (phonation)... Source-filter synthesis 
KlattGrid	KlattGrid A KlattGrid represents the source-filter model as a function of time. It consists of a number of tiers that model aspects of the source and the filter, and the interaction between source and filter. The KlattGrid implements a superset of the speech synthesizer described in figure 14 in the Klatt & Klatt (1990) article. The following drawing represents a cascade synthesizer with six oral formants, one nasal formant, one nasal antiformant, one tracheal formant, one tracheal antiformant and six frication formants. In the next picture a parallel synthesizer branch is used instead of the cascade one. All parameters in the synthesizer are represented by separate tiers. The source The source is modelled by the following tiers: Pitch models fundamental frequency (in Hertz). Flutter models a kind of random variation of the pitch (with a number between zero and one). Voicing amplitude models the maximum amplitude of the glottal flow (in dB SPL). Open phase models the open phase of the glottis (with a number between zero and one). If the tier is empty a default of 0.7 will be used. Power1, Power2 model the form of the glottal flow function flow(t)=tpower1-tpower2 for 0≤ t ≤ 1. To make glottal closure possible, power2 has to be larger than power1. If the power1 tier is empty, a default value of 3 will be used. If the power2 tier is empty, a default of 4 will be used. Collision phase models the last part of the flow function with an exponential decay function instead of a polynomial one. More information about Power1, Power2, Open phase and Collision phase can be found in the PointProcess: To Sound (phonation)... manual. Spectral tilt models the extra number of dB the voicing spectrum should be down at 3000 Hertz. Aspiration amplitude models the (maximum) amplitude of the noise generated at the glottis (in dB SPL). Breathiness amplitude models the maximum breathiness noise amplitude during the open phase of the glottis (in dB SPL). The amplitude of the breathiness noise is modulated by the glottal flow. Double pulsing models diplophonia (by a fraction between zero and one). Whenever this parameter is greater than zero, alternate pulses are modified. A pulse is modified with this single parameter in two ways: it is delayed in time and its amplitude is attenuated. If the double pulsing value is a maximum and equals one, the time of closure of the first peak coincides with the opening time of the second one. The vocal tract filter The filter is modelled by a number of FormantGrid's. For parallel synthesis the formant grids that normally only contain formant frequency and formant bandwidth tiers, have been extended with amplitude tiers. Amplitudes values are in dB. The following formant grids can be used: Oral formants represent the standard oral resonances of the vocal tract. Nasal formants model resonances in the nasal tract. Because the form of the nasal tract does not vary much during the course of an utterance, nasal formants tend to be constant. Nasal antiformants model dips in the spectrum caused by leakage to the nasal tract. Interaction between source and filter The interaction between source and filter is modeled by two formant grids. Tracheal formants model one aspect of the coupling of the trachea with the vocal tract transfer function, namely, by the introduction of extra formants (and antiformants) that sometimes distort vowel spectra to a varying degrees. According to Klatt & Klatt (1990), the other effect being increased losses at glottal termination which primarily affect first-formant bandwidths. Tracheal antiformants model dips in the spectrum caused by the trachea. Delta formants The values in this grid model the number of hertz that the oral formants and/or bandwidths change during the open phase of the glottis. Klatt & Klatt (1990) distinguish four types of source-filter interactions: an F1 ripple in the source waveform, a non-linear interaction between the first formant and the fundamental frequency, a truncation of the first formant and tracheal formants and antiformants. The frication section The frication section is modeled with a frication formant grid, with formant frequencies, bandwidths and (separate) amplitudes (dB), a frication by-pass tier (dB) and an amplitude tier (dB SPL) that governs the frication noise source. A minimal synthesizer The following script produces a minimal voiced sound. The first line creates the standard KlattGrid.The next two lines define a pitch point, in Hz, and the voicing amplitude, in dB. The last line creates the sound. Create KlattGrid: kg, 0, 1, 6, 1, 1, 6, 1, 1, 1 Add pitch point: 0.5, 100 Add voicing amplitude point: 0.5, 90 To Sound The following script will produce raw frication noise. Because we do not specify formant amplitudes, we turn off the formants in the parallel section. Create KlattGrid: kg, 0, 1, 6, 1, 1, 6, 1, 1, 1 Add frication amplitude point: 0.5 ,80 Add frication bypass point: 0.5, 0 To Sound (special): 0, 0, 44100, yes, no, yes, yes, yes, yes, ... Powers in tiers, yes, yes, yes, ... Cascade, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, yes Changes In praat versions before 5.1.05 the values for the oral / nasal / tracheal formant amplitudes and frication bypass amplitude had to be given in dB SPL; now they are in real dB's, i.e. 0 dB means no change in amplitude. You can calculate new values from old values as: new_value = old_value + 20*log10(2e-5). This means that you have to subtract approximately 94 dB from the old values. Links to this page Create KlattGrid... KlattGrid: Play special... KlattGrid: To Sound (phonation)... KlattGrid: To Sound (special)... Sound & KlattGrid: Filter by vocal tract... Sound: To KlattGrid (simple)... What was new in 5.1? 
KlattGrid__Extract_oral_formant_grid__open_phases____	KlattGrid: Extract oral formant grid (open phases)... Extracts the oral formant grid as used in the synthesis, i.e. the resulting grid contains the informantion from the oral formant grid and the delta formant grid combined during the open phase of the glottis. 
KlattGrid__Play_special___	KlattGrid: Play special... A command to play part of a KlattGrid. Settings Time range (s) determines the part of the sound's domain that you want to hear. If both argument equal zero the complete sound is played. Sampling frequency (Hz) determines the sampling frequency of the resulting sound. Scale peak determines whether the peak value of the sound will be set to 0.99. In this way the sound will always play well. Sampling frequency (Hz) the sampling frequency of the resulting sound. Voicing switches voicing on or off. Flutter switches the flutter tier on or off. This will, of course, only have effect if at least one flutter point has been defined in the flutter tier. Double pulsing switches the double pulsing tier on or off. Collision phase switches the collision phase tier on or off. Spectral tilt switches the spectral tilt tier on or off. Flow function determines which flow function will be used. The flow function is determined by two parameters, power1 and power2 as flow(t)=xpower1-xpower2. If the option Powers in tier is chosen the power1 and power2 tiers will be used for the values of power1 and power2. The other choices switch the two tiers off and instead fixed values will be used for power1 and power2. Flow derivative determines whether the flow or the flow derivative is used for phonation. Aspiration determines whether aspiration is included in the synthesis. Breathiness determines whether breathiness is included in the synthesis. Model switches on either the cascade or the parallel section of the synthesizer. Oral formant range, Nasal formant range ... selects the formants to use in the synthesis. Choosing the end of a range smaller than the start of the range switches off the formants. Frication bypass switches the frication bypass of the frication section on or off. The complete frication section can be turned off by also switching off the frication formants. 
KlattGrid__To_Sound__phonation____	KlattGrid: To Sound (phonation)... A command to synthesize a Sound from the selected KlattGrid. Settings Sampling frequency (Hz) the sampling frequency of the resulting sound. Voicing switches voicing on or off. Flutter switches the flutter tier on or off. This will, of course, only have effect if at least one flutter point has been defined in the flutter tier. Double pulsing switches the double pulsing tier on or off. Collision phase switches the collision phase tier on or off. Spectral tilt switches the spectral tilt tier on or off. Flow function determines which flow function will be used. The flow function is determined by two parameters, power1 and power2 as flow(t)=xpower1-xpower2. If the option Powers in tier is chosen the power1 and power2 tiers will be used for the values of power1 and power2. The other choices switch the two tiers off and instead fixed values will be used for power1 and power2. Flow derivative determines whether the flow or the flow derivative is used for phonation. Aspiration determines whether aspiration is included in the synthesis. Breathiness determines whether breathiness is included in the synthesis. 
KlattGrid__To_Sound__special____	KlattGrid: To Sound (special)... A command to synthesize a Sound from the selected KlattGrid. Settings Time range (s) determines the part of the domain that you want to save as a sound. If both argument equal zero the complete sound is created. Sampling frequency (Hz) determines the sampling frequency of the resulting sound. Scale peak determines whether the peak value of the sound will be set to 0.99. In this way the sound will always play well and can be saved to a file with minimal loss of resolution. Sampling frequency (Hz) the sampling frequency of the resulting sound. Voicing switches voicing on or off. Flutter switches the flutter tier on or off. This will, of course, only have effect if at least one flutter point has been defined in the flutter tier. Double pulsing switches the double pulsing tier on or off. Collision phase switches the collision phase tier on or off. Spectral tilt switches the spectral tilt tier on or off. Flow function determines which flow function will be used. The flow function is determined by two parameters, power1 and power2 as flow(t)=xpower1-xpower2. If the option Powers in tier is chosen the power1 and power2 tiers will be used for the values of power1 and power2. The other choices switch the two tiers off and instead fixed values will be used for power1 and power2. Flow derivative determines whether the flow or the flow derivative is used for phonation. Aspiration determines whether aspiration is included in the synthesis. Breathiness determines whether breathiness is included in the synthesis. Model switches on either the cascade or the parallel section of the synthesizer. Oral formant range, Nasal formant range ... selects the formants to use in the synthesis. Choosing the end of a range smaller than the start of the range switches off the formants. Frication bypass switches the frication bypass of the frication section on or off. The complete frication section can be turned off by also switching off the frication formants. 
Klein__Plomp___Pols__1970_	Klein, Plomp & Pols (1970) W. Klein, R. Plomp, & L.C.W. Pols (1970): Vowel Spectra, Vowel Spaces, and Vowel Identification. Journal of the Acoustical Society of America 48: 999–1009. Links to this page Confusion: To Similarity... 
KNN	KNN One of the types of objects in Praat. A KNN classifier can learn associations between its input and its output. The kNN classifiers tutorial gives you an introduction to the usage of kNN learners in Praat. Links to this page Create KNN... FeatureWeights KNN & FeatureWeights: Get accuracy estimate... KNN & Pattern & Categories & FeatureWeights: Evaluate... KNN & Pattern & Categories: Evaluate... KNN & Pattern & Categories: Learn... KNN & Pattern & Categories: To FeatureWeights... KNN & Pattern & FeatureWeights: To Categories... KNN & Pattern & FeatureWeights: To TableOfReal... KNN & Pattern: To Categories... KNN & Pattern: To TabelOfReal... kNN classifiers 2. Quick start KNN: Extract input Pattern KNN: Extract output Categories KNN: Get accuracy estimate... KNN: Get optimized parameters... KNN: Get size of instance base KNN: To FeatureWeights... Pattern & Categories: To KNN classifier... 
KNN___FeatureWeights__Get_accuracy_estimate___	KNN & FeatureWeights: Get accuracy estimate... Estimate the classification accuracy of the KNN classifier using the chosen FeatureWeights. Settings Evaluation method The method to be used for estimating the classification accuracy. Supported methods are 10-fold cross-validation and leave-one-out. k neighbours The size of the neighbourhood. Vote weighting The type of vote weighting to be used. See also: KNN & Pattern & Categories: Evaluate... KNN & Pattern & Categories & FeatureWeights: Evaluate... kNN classifiers 1.1. Improving classification accuracy kNN classifiers 1.1.1. Feature weighting kNN classifiers 1.1.2. Model selection kNN classifiers Links to this page kNN classifiers 3. Command overview KNN: Get accuracy estimate... 
KNN___Pattern___Categories___FeatureWeights__Evaluate__	KNN & Pattern & Categories & FeatureWeights: Evaluate... Estimate the classification accuracy of the chosen KNN classifier using the selected Pattern and Categories objects as test set. The selected FeatureWeights object will be used in the classification process. Settings k neighbours The size of the neighbourhood. Vote weighting The type of vote weighting to be used. See also: KNN & Pattern & Categories: Evaluate... KNN: Get accuracy estimate... kNN classifiers 1.1. Improving classification accuracy kNN classifiers 1.1.1. Feature weighting kNN classifiers 1.1.2. Model selection kNN classifiers Links to this page KNN & FeatureWeights: Get accuracy estimate... KNN & Pattern & Categories: To FeatureWeights... kNN classifiers 3. Command overview KNN: To FeatureWeights... 
KNN___Pattern___Categories__Evaluate___	KNN & Pattern & Categories: Evaluate... Estimate the classification accuracy of the chosen KNN classifier using the selected Pattern and Categories objects as test set. Settings k neighbours The size of the neighbourhood. Vote weighting The type of vote weighting to be used. See also: KNN & Pattern & Categories & FeatureWeights: Evaluate... KNN: Get accuracy estimate... kNN classifiers 1.1. Improving classification accuracy kNN classifiers 1.1.1. Feature weighting kNN classifiers 1.1.2. Model selection kNN classifiers Links to this page KNN & FeatureWeights: Get accuracy estimate... kNN classifiers 3. Command overview 
KNN___Pattern___Categories__Learn___	KNN & Pattern & Categories: Learn... Train the selected KNN classifier using the chosen Pattern and Categories objects as training data. Settings Name The name of the classifier. Ordering The order in which the training instances are to be inserted into the instance base. See also: kNN classifiers kNN classifiers 1. What is a kNN classifier? Links to this page kNN classifiers 3. Command overview 
KNN___Pattern___Categories__To_FeatureWeights___	KNN & Pattern & Categories: To FeatureWeights... Wrap the selected KNN and use its classification accuracy on the test set constituted by the Pattern and Categories objects as feedback to guide the search for the optimal feature weights. A FeatureWeights object will be created. Settings Learning rate The rate at which the maximum distance between the pivot and a random seed is decremented. Number of seeds The size of the feature weight neighbourhood. Stop at A value specifying a stopping criterion. When feature weights yielding accuracy estimates higher than the specified value the search will stop. A value of 1 imposes no constraints whereas a value of 0.5 will result in the termination of the search algorithm once feature weights resulting in an classification accuracy of 50 percent or better are found. Optimization Specifies whether to search for all features simultaneously or one at a time. k neighbours The size of the neighbourhood used for feedback classification. Vote weighting The type of vote weighting to be used. See also: kNN classifiers 1.1.1.2. Wrapper-based feature weighting kNN classifiers 1.1.1. Feature weighting kNN classifiers 1.1. Improving classification accuracy KNN & Pattern & Categories & FeatureWeights: Evaluate... kNN classifiers 1. What is a kNN classifier? kNN classifiers Links to this page kNN classifiers 3. Command overview 
KNN___Pattern___FeatureWeights__To_Categories___	KNN & Pattern & FeatureWeights: To Categories... Use the selected KNN classifier and FeatureWeights object to classify the chosen Pattern. A Categories object containing the result will be created. Settings k neighbours The size of the neighbourhood. Vote weighting The type of vote weighting to be used. See also: kNN classifiers 1.1.1. Feature weighting kNN classifiers 1.1.1.1. Filter-based feature weighting kNN classifiers 1.1.1.2. Wrapper-based feature weighting kNN classifiers 1.1. Improving classification accuracy kNN classifiers 1. What is a kNN classifier? kNN classifiers Links to this page kNN classifiers 3. Command overview 
KNN___Pattern___FeatureWeights__To_TableOfReal___	KNN & Pattern & FeatureWeights: To TableOfReal... Use the selected KNN classifier and the feature weights, FeatureWeights, to classify the chosen Pattern. A TableOfReal object containing verbose information on the decision process will be created. Settings k neighbours The size of the neighbourhood. Vote weighting The type of vote weighting to be used. Output Specifies the degree of verbosity, where winners only generates a TableOfReal containing information on the instances of the winning category only whereas All candidates results in a TableOfReal with verbose information on all unique categories in the neighbourhood defined by the parameter k. See also: kNN classifiers 1.1.1. Feature weighting kNN classifiers 1.1.1.1. Filter-based feature weighting kNN classifiers 1.1.1.2. Wrapper-based feature weighting kNN classifiers 1.1. Improving classification accuracy kNN classifiers 1. What is a kNN classifier? kNN classifiers Links to this page kNN classifiers 3. Command overview 
KNN___Pattern__To_Categories___	KNN & Pattern: To Categories... Use the selected KNN classifier to classify the chosen Pattern. A Categories object containing the result will be created. Settings k neighbours The size of the neighbourhood. Vote weighting The type of vote weighting to be used. See also: kNN classifiers kNN classifiers 1. What is a kNN classifier? Links to this page kNN classifiers 3. Command overview 
KNN___Pattern__To_TabelOfReal___	KNN & Pattern: To TabelOfReal... Use the selected KNN classifier to classify the chosen Pattern. A TableOfReal object containing verbose information on the decision process will be created. Settings k neighbours The size of the neighbourhood. Vote weighting The type of vote weighting to be used. Output Specifies the degree of verbosity, where winners only generates a TableOfReal containing information on the instances of the winning category only whereas All candidates results in a TableOfReal with verbose information on all unique categories in the neighbourhood defined by the parameter k. See also: kNN classifiers kNN classifiers 1. What is a kNN classifier? Links to this page kNN classifiers 3. Command overview 
KNN__Extract_input_Pattern	KNN: Extract input Pattern Create a new Pattern object identical to the one in the instance base of the selected KNN classifier. See also: kNN classifiers Links to this page kNN classifiers 3. Command overview 
KNN__Extract_output_Categories	KNN: Extract output Categories Create a new Categories object identical to the one in the instance base of the selected KNN classifier. See also: kNN classifiers Links to this page kNN classifiers 3. Command overview 
KNN__Get_accuracy_estimate___	KNN: Get accuracy estimate... Estimate the classification accuracy of the selected KNN classifier. Settings Evaluation method The method to be used for estimating the classification accuracy. Supported methods are 10-fold cross-validation and leave-one-out. k neighbours The size of the neighbourhood. Vote weighting The type of vote weighting to be used. See also: KNN & FeatureWeights: Get accuracy estimate... KNN & Pattern & Categories: Evaluate... KNN & Pattern & Categories & FeatureWeights: Evaluate... kNN classifiers 1.1. Improving classification accuracy kNN classifiers 1.1.1. Feature weighting kNN classifiers 1.1.2. Model selection kNN classifiers Links to this page kNN classifiers 3. Command overview 
KNN__Get_optimized_parameters___	KNN: Get optimized parameters... Perform an automated search for the optimal KNN parameter settings. Settings Evaluation method The method to be used for estimating the classification accuracy, which in turn is used to guide the model search. Supported methods are 10-fold cross-validation and leave-one-out. k max The maximum value of the parameter k. Number of seeds The size of the parameter neighbourhood to be searched. Learning rate The rate at which the parameter neighbourhood is shrunk (per iteration). See also: kNN classifiers 1.1.2. Model selection kNN classifiers 1.1. Improving classification accuracy kNN classifiers 1. What is a kNN classifier? kNN classifiers Links to this page kNN classifiers 3. Command overview 
KNN__Get_size_of_instance_base	KNN: Get size of instance base Queries the selected KNN for the number of instances in the instance base. See also: kNN classifiers Links to this page kNN classifiers 3. Command overview 
KNN__Prune___	KNN: Prune... Prune the instance base of the selected classifier. Settings Noise pruning degree A value in the range [0 ... 1] specifying the probability that instances tagged as noisy by the C-Pruner algorithm will be pruned. Redundancy pruning degree The probability that instances tagged as redundant by the C-Pruner algorithm will be pruned. k neighbours The size of the neighbourhood. See also: kNN classifiers 1.2.1. Pruning kNN classifiers 1.2. Improving resource efficiency kNN classifiers Links to this page kNN classifiers 3. Command overview 
KNN__Reset___	KNN: Reset... Empty the instance base of the selected classifier. See also: kNN classifiers Links to this page kNN classifiers 3. Command overview 
KNN__Shuffle	KNN: Shuffle Shuffle the instance base of the selected classifier. See also: kNN classifiers Links to this page kNN classifiers 3. Command overview 
KNN__To_FeatureWeights___	KNN: To FeatureWeights... Wrap the selected KNN and use its feedback to guide the search for the optimal feature weights. A FeatureWeights object will be created. Settings Learning rate The rate at which the maximum distance between the pivot and a random seed is decremented. Number of seeds The size of the feature weight neighbourhood. Stop at A value specifying a stopping criterion. When feature weights yielding accuracy estimates higher than the specified value the search will stop. A value of 1 imposes no constraints whereas a value of 0.5 will result in the termination of the search algorithm once feature weights resulting in an classification accuracy of 50 percent or better are found. Optimization Specifies whether to search for all features simultaneously or one at a time. Evaluation method The method to be used for estimating the classification accuracy. Supported methods are 10-fold cross-validation and leave-one-out. k neighbours The size of the neighbourhood used for feedback classification. Vote weighting The type of vote weighting to be used. See also: kNN classifiers 1.1.1.2. Wrapper-based feature weighting kNN classifiers 1.1.1. Feature weighting kNN classifiers 1.1. Improving classification accuracy KNN & Pattern & Categories & FeatureWeights: Evaluate... kNN classifiers 1. What is a kNN classifier? kNN classifiers Links to this page kNN classifiers 3. Command overview 
kNN_classifiers	kNN classifiers This tutorial describes the use of kNN classifiers in Praat. 1. What is a kNN classifier? 1.1. Improving classification accuracy 1.1.1. Feature weighting 1.1.1.1. Filter-based feature weighting 1.1.1.2. Wrapper-based feature weighting 1.1.2. Model selection 1.2. Improving resource efficiency 1.2.1. Pruning 2. Quick start 3. Command overview Links to this page Acknowledgments Create KNN... KNN KNN & FeatureWeights: Get accuracy estimate... KNN & Pattern & Categories & FeatureWeights: Evaluate... KNN & Pattern & Categories: Evaluate... KNN & Pattern & Categories: Learn... KNN & Pattern & Categories: To FeatureWeights... KNN & Pattern & FeatureWeights: To Categories... KNN & Pattern & FeatureWeights: To TableOfReal... KNN & Pattern: To Categories... KNN & Pattern: To TabelOfReal... KNN: Extract input Pattern KNN: Extract output Categories KNN: Get accuracy estimate... KNN: Get optimized parameters... KNN: Get size of instance base KNN: Prune... KNN: Reset... KNN: Shuffle KNN: To FeatureWeights... Pattern & Categories: To FeatureWeights... Pattern & Categories: To KNN classifier... Pattern & FeatureWeights: To Categories... Pattern & FeatureWeights: To Dissimilarity... Pattern: To Categories... Pattern: To Dissimilarity... What was new in 5.1? 
kNN_classifiers_1_1_1_1__Filter-based_feature_weighting	kNN classifiers 1.1.1.1. Filter-based feature weighting The filter-based feature weighting algorithm implemented in Praat is an extended version of the well known RELIEF algorithm, RELIEF-F, such as it is presented (with one minor exception, see below) in Kononenko (1994). Unlike the original RELIEF algorithm, the RELIEF-F algorithm copes with multi class (as in more than 2 classes) data sets. The simple intuition behind the RELIEF-F algorithm is that a good feature is a feature with little within class variance and generous amounts of between-class variance. A bad feature is characterized by within-class and between-class variances of magnitudes roughly equal. The computation of the weight vector is done in an iterative fashion, with all weights initially set to 0. All features in the training set are normalized (all values are set within the range [0 ... 1]) and thereafter used to update the weight vector as follows: On each iteration a random instance is chosen. The nearest hit is located, where hit is an instance of the same class as that of the randomly chosen instance. The nearest misses of all the classes but that of the randomly chosen instance are located, where a miss is an instance of a class different from that of the randomly chosen instance. Each weight is updated by subtracting the difference between the given attribute of the randomly chosen instance and that of the nearest hit and adding the corresponding difference between the chosen instance and all the nearest misses weighted by the prior probabilities of their classes. If the distance between the attribute of the randomly chosen instance and the nearest hit equals the corresponding value for the nearest miss(es) then the weight value will not change, it will thus remain 0 given that the current iteration is the first one. If the difference between the attribute of the chosen instance and the nearest hit is lower than the corresponding value for the miss(es) then the weight value will be increased. On average highly significant attributes will result in absolute values distinct from 0, leading to an absolute increase of the weight, and insignificant attributes will on average result in values near 0, retaining the pessimistic view that all features are of no value as predictors. The implementation of RELIEF-F found in Praat differs slightly from the algorithm described. Instances are not randomly chosen, instead all instances are used to update the weight vector. This simplification is of no concern unless massive data sets are used, in which case the Praat approach would be no less precise, but needlessly slow. Links to this page KNN & Pattern & FeatureWeights: To Categories... KNN & Pattern & FeatureWeights: To TableOfReal... kNN classifiers kNN classifiers 1.1.1. Feature weighting Pattern & Categories: To FeatureWeights... 
kNN_classifiers_1_1_1_2__Wrapper-based_feature_weightin	kNN classifiers 1.1.1.2. Wrapper-based feature weighting The wrapper-based feature weighting algorithm implemented in Praat attempts to find the globally optimal feature weights by means of a greedy local search. The local neighbourhood is defined by a number of random seeds centered around a pivot seed. For each iteration of the algorithm the best performing seed is chosen to be the pivot of the next iteration. At the same time the maximum allowed distance between a seed and the pivot is decreased by a constant factor. Given a sufficient number of seeds and a small shrinkage factor the algorithm will on average home in on a good approximation of the global maximum. Given reasonable parameter settings, the search algorithm on average gives good results without huge memory and CPU requirements. The strong point of the method, the ability to efficiently do a rather thorough search of the weight space, can, as mentioned in section 1.1.1., lead to overfitting. One way of minimizing this problem is to constrain the algorithm by means of early stopping. In Praat this is done in a very naive fashion, by simply not allowing the algorithm to explore weights achieving an accuracy higher than a specified threshold value. Links to this page KNN & Pattern & Categories: To FeatureWeights... KNN & Pattern & FeatureWeights: To Categories... KNN & Pattern & FeatureWeights: To TableOfReal... kNN classifiers kNN classifiers 1.1.2. Model selection KNN: To FeatureWeights... Pattern & Categories: To FeatureWeights... 
kNN_classifiers_1_1_1__Feature_weighting	kNN classifiers 1.1.1. Feature weighting A kNN classifier in its most basic form operates under the implicit assumption that all features are of equal value as far as the classification problem at hand is concerned. When irrelevant and noisy features influence the neighbourhood search to the same degree as highly relevant features, the accuracy of the model is likely to deteriorate. Feature weighting is a technique used to approximate the optimal degree of influence of individual features using a training set. When successfully applied relevant features are attributed a high weight value, whereas irrelevant features are given a weight value close to zero. Feature weighting can be used not only to improve classification accuracy but also to discard features with weights below a certain threshold value and thereby increase the resource efficiency of the classifier. Two fundamentally different approaches to this optimization problem can be identified, the filter-based and the wrapper-based. The class of filter-based methods contains algorithms that use no input other than the training data itself to calculate the feature weights, whereas wrapper-based algorithms use feedback from a classifier to guide the search. Wrapper-based algorithms are inherently more powerful than their filter-based counterpart as they implicitly take the inductive bias of the classifier into account. This power comes at a price however; the usage of wrapper-based algorithms increases the risk of overfitting the training data. In section 1.1.1.1. the filter-based feature weighting algorithm implemented in Praat is presented. Section 1.1.1.2. contains an account of the implemented wrapper-based feature weighting algorithm. Links to this page KNN & FeatureWeights: Get accuracy estimate... KNN & Pattern & Categories & FeatureWeights: Evaluate... KNN & Pattern & Categories: Evaluate... KNN & Pattern & Categories: To FeatureWeights... KNN & Pattern & FeatureWeights: To Categories... KNN & Pattern & FeatureWeights: To TableOfReal... kNN classifiers kNN classifiers 1.1. Improving classification accuracy KNN: Get accuracy estimate... KNN: To FeatureWeights... Pattern & FeatureWeights: To Categories... Pattern & FeatureWeights: To Dissimilarity... 
kNN_classifiers_1_1_2__Model_selection	kNN classifiers 1.1.2. Model selection Model selection is the process of choosing classifier parameters suitable for the classification task at hand. In most cases this is done manually in an experimental fashion. The search for the optimal model can also be automated. In Praat this is done by means of the same greedy local search algorithm used to search the weight space for feature weights. The model selection search implementation in Praat lets the user limit the search space with respect to the parameter k. By setting a maximum allowed value of k the search space can be shrunk considerably. Due to its discrete (k) and nominal (vote weighting) nature, the size of the search space is normally of no concern, making an experimental/manual search tractable. The model selection feature of Praat becomes an essential tool only when applied to huge instance bases where the expected optimal value of k is high. In most cases however, manual experimenting will suffice. Links to this page KNN & FeatureWeights: Get accuracy estimate... KNN & Pattern & Categories & FeatureWeights: Evaluate... KNN & Pattern & Categories: Evaluate... kNN classifiers kNN classifiers 1.1. Improving classification accuracy KNN: Get accuracy estimate... KNN: Get optimized parameters... 
kNN_classifiers_1_1__Improving_classification_accuracy	kNN classifiers 1.1. Improving classification accuracy This tutorial describes possible ways of improving the classification accuracy of a kNN classifier. 1.1.1. Feature weighting 1.1.2. Model selection Links to this page KNN & FeatureWeights: Get accuracy estimate... KNN & Pattern & Categories & FeatureWeights: Evaluate... KNN & Pattern & Categories: Evaluate... KNN & Pattern & Categories: To FeatureWeights... KNN & Pattern & FeatureWeights: To Categories... KNN & Pattern & FeatureWeights: To TableOfReal... kNN classifiers KNN: Get accuracy estimate... KNN: Get optimized parameters... KNN: To FeatureWeights... 
kNN_classifiers_1_2_1__Pruning	kNN classifiers 1.2.1. Pruning Pruning is the process of discarding instances that do not improve upon the classification accuracy of the classifier. This group of instances includes noisy instances that, at best, make no difference as far as model accuracy is concerned, at worst, induces classification errors. It also includes instances that are redundant; instances that are implied by the defined neighbourhood. The C-Pruner algorithm The C-Pruner algorithm such as it is presented in Zhao et al. (2003) identifies pruning candidates and computes the order in which these candidates shall be removed. The ordering is of vital importance since the removal of one candidate might disqualify other candidates, making them non-prunable. In order to understand how the C-Pruner algorithm operates a few definitions are necessary: The k-reachability set of an instance p consists of the k nearest neighbours of p The k-coverage set of an instance p consists of those instances of the same class as that of p having p as one of their k nearest neighbours. An instance p is superfluous if it is implied by k-reachability, that is, if it can be correctly classified using k-reachability as instance base. An instance p is critical if at least one instance in the k-coverage set of p is not implied by the k-reachability set of p or, after p is deleted, atleast one instance in the k-coverage set of p is not implied by the k-reachability set of p. An instance p is noisy if p isn't superfluous and the k-reachability set of p is bigger than the k-coverage set of p. Given these definitions, an instance is tagged for pruning if one of the following conditions hold: It is noisy, or it is superfluous but not critical. This translates to the discarding of instances that are bad class predictors (noise) and of instances that are highly typical of their class and thus are located close to the center of the cluster defining the given class. Instances located close to the class center are very likely implied by the surrounding border instances and thus redundant. In order to avoid destructive domino effects it is important that the pruning starts close to the center of the cluster and works its way out and not the other way around. To impose this ordering the C-Pruner algorithm uses the following heuristics to determine the order of removal of two superfluous instances pi and pj: If the k-reachability set of pi contains more instances of the same class as that of pi than the corresponding value for pj then pi should be removed before pj. If the k-reachability set of pi contains the same number of instances of the same class as that of pi as the corresponding value for pj and the distance between pi and the closest instance of a class different from the class of pi is greater than the corresponding value for pj then pi should be removed before pj. If the k-reachability set of pi contains the same number of instances of the same class as that of pi as the corresponding value for pj and the distance between pi and the closest instance of a class different from the class of pi equals the corresponding value for pj then the order of removal is decided randomly. In order to gain control of the degree of pruning the Praat implementation of the C-Pruner algorithm decides whether to prune or not prune a given instance tagged for pruning on a probabilistic basis. This makes it possible for the user to specify the hardness of the pruning process (e.g. 100 percent (exp.) noise, 50 percent (exp.) redundancy) to be able to find a good compromise between model accuracy and resource requirements. Links to this page kNN classifiers KNN: Prune... 
kNN_classifiers_1_2__Improving_resource_efficiency	kNN classifiers 1.2. Improving resource efficiency Instance-based learners such as the kNN classifier implemented in Praat are fairly inefficient as far as CPU and memory usage is concerned. The performance can be improved upon by making sure that only those instances that are vital for the accuracy of the classifier are stored and that non-vital instances are disposed of. Praat does give the user the possibility to prune non-vital or harmful instances, making the resulting classifier less memory and CPU hungry and in some cases more accurate even though that is not the primary objective of the pruning algorithm. Links to this page kNN classifiers KNN: Prune... 
kNN_classifiers_1__What_is_a_kNN_classifier_	kNN classifiers 1. What is a kNN classifier? Instance-based classifiers such as the kNN classifier operate on the premises that classification of unknown instances can be done by relating the unknown to the known according to some distance/similarity function. The intuition is that two instances far apart in the instance space defined by the appropriate distance function are less likely than two closely situated instances to belong to the same class. The learning process Unlike many artificial learners, instance-based learners do not abstract any information from the training data during the learning phase. Learning is merely a question of encapsulating the training data. The process of generalization is postponed until it is absolutely unavoidable, that is, at the time of classification. This property has lead to the referring to instance-based learners as lazy learners, whereas classifiers such as feedforward neural networks, where proper abstraction is done during the learning phase, often are entitled eager learners. Classification Classification (generalization) using an instance-based classifier can be a simple matter of locating the nearest neighbour in instance space and labelling the unknown instance with the same class label as that of the located (known) neighbour. This approach is often referred to as a nearest neighbour classifier. The downside of this simple approach is the lack of robustness that characterize the resulting classifiers. The high degree of local sensitivity makes nearest neighbour classifiers highly susceptible to noise in the training data. More robust models can be achieved by locating k, where k > 1, neighbours and letting the majority vote decide the outcome of the class labelling. A higher value of k results in a smoother, less locally sensitive, function. The nearest neighbour classifier can be regarded as a special case of the more general k-nearest neighbours classifier, hereafter referred to as a kNN classifier. The drawback of increasing the value of k is of course that as k approaches n, where n is the size of the instance base, the performance of the classifier will approach that of the most straightforward statistical baseline, the assumption that all unknown instances belong to the class most most frequently represented in the training data. This problem can be avoided by limiting the influence of distant instances. One way of doing so is to assign a weight to each vote, where the weight is a function of the distance between the unknown and the known instance. By letting each weight be defined by the inversed squared distance between the known and unknown instances votes cast by distant instances will have very little influence on the decision process compared to instances in the near neighbourhood. Distance weighted voting usually serves as a good middle ground as far as local sensitivity is concerned. Links to this page k-means clustering 1. How does k-means clustering work? KNN & Pattern & Categories: Learn... KNN & Pattern & Categories: To FeatureWeights... KNN & Pattern & FeatureWeights: To Categories... KNN & Pattern & FeatureWeights: To TableOfReal... KNN & Pattern: To Categories... KNN & Pattern: To TabelOfReal... kNN classifiers KNN: Get optimized parameters... KNN: To FeatureWeights... Pattern & Categories: To KNN classifier... 
kNN_classifiers_2__Quick_start	kNN classifiers 2. Quick start An example: Learning the Iris data set In the the feedforward neural networks tutorial a description of how the FFNet classifier in Praat can be applied to the Iris data set can be found. The same data can be used to test the kNN feature of Praat. To do so create an example data set using the Create iris example... command found in the Neural nets submenu. The form prompting for network topology settings can be ignored by selecting OK. Select the newly created Pattern and Categories objects and click To KNN Classifier.... A form prompting for a name of the classifier to be created will be shown. The ordering in which instances are to be inserted into the instance base can also be specified, make sure that Random is selected and thereafter close the form by selecting OK. The newly created and trained classifier will be shown in the list of objects. To estimate how well the classifier can be expected to classify new samples of Irises select Query - ⇒ Get accuracy estimate.... A form prompting for kNN parameter settings and evaluation method will be shown. Experiment with the parameter settings until satisfactory results are achieved. If everything worked out the estimate will likely end up somewhere in the range of 94-98 percent. An alternative to manually experimenting with model parameters is to let the computer do the job. This is done be choosing the KNN object and thereafter selecting Query - ⇒ Get optimized parameters.... The form shown prompts for a selection of parameters controlling the search. The default values will in most cases, including this, be appropriate. Another way of improving classification accuracy is to transform the instance space in which the individual instances, in this case Irises, are stored as to maximize the distance between instances of different classes and minimize the distance between instances of the same class. This can be done by means of feature weighting. To do so select the KNN object and choose To FeatureWeights.... Adjust the kNN settings according to the ones found by the model search algorithm and let the remaining options retain the default values. Click OK. A FeatureWeights object will be added to the objects list. The feature weights contained within the newly created object can be used by selecting named object in conjunction with the KNN classifier and thereafter choosing the desired action. Links to this page kNN classifiers 
kNN_classifiers_3__Command_overview	kNN classifiers 3. Command overview KNN commands Creation: Pattern & Categories: To KNN classifier... Create KNN... Learning: KNN & Pattern & Categories: Learn... Classification: KNN & Pattern: To Categories... KNN & Pattern: To TabelOfReal... KNN & Pattern & FeatureWeights: To Categories... KNN & Pattern & FeatureWeights: To TableOfReal... Evaluation: KNN & Pattern & Categories: Evaluate... KNN & Pattern & Categories & FeatureWeights: Evaluate... Queries KNN: Get optimized parameters... KNN: Get accuracy estimate... KNN & FeatureWeights: Get accuracy estimate... KNN: Get size of instance base Extractions KNN: Extract input Pattern KNN: Extract output Categories Modification: KNN: Shuffle KNN: Prune... KNN: Reset... Miscellaneous: KNN: To FeatureWeights... KNN & Pattern & Categories: To FeatureWeights... Pattern & Categories: To FeatureWeights... Pre/post processing: Pattern: To Categories... Pattern & FeatureWeights: To Categories... Pattern: To Dissimilarity... Pattern & FeatureWeights: To Dissimilarity... Links to this page kNN classifiers 
Krishnamoorthy___Yu__2004_	Krishnamoorthy & Yu (2004) K. Krishnamoortht & J. Yu (2004): Modified Nel and Van der Merwe test for multivariate Behrens-Fisher problem. Statistics & Probability Letters 66: 161–169. Links to this page Covariances: Report multivariate mean difference... 
Kruskal__1964_	Kruskal (1964) J.B. Kruskal (1964): Nonmetric multidimensional scaling: a numerical method. Psychometrika 29: 115–129. Links to this page Dissimilarity: To Configuration (kruskal)... stress 
Kruskal_analysis	Kruskal analysis One of the MDS models in PRAAT. You can perform a Kruskal-type multidimensional scaling only on objects of type Dissimilarity. Objects of other types first have to be converted to objects of Dissimilarity type. Example Convert a Dissimilarity object into a Configuration object. Dissimilarity: To Configuration (monotone mds)... choose appropriate parameters Dissimilarity & Configuration: Get stress (monotone mds)... choose stress-1 to obtain the value for the stress according to Kruskal. How to get started You can create an example Dissimilarity object with the Create letter R example... button which you can find under the Multidimensional scaling option in the New menu. Links to this page Multidimensional scaling Types of objects 
Labelling	Labelling See Intro 7. Annotation. 
Ladefoged__2001_	Ladefoged (2001) Peter Ladefoged (2001). Vowels and consonants: an introduction to the sounds of languages. Oxford: Blackwell. [second edition: 2005; third edition with Sandra Disner: 2012] A very readable introduction to phonetics, mainly acoustic and articulatory. Has lots of spectrograms of the sounds of the world's languages. Comes with a CD that has all those sounds and includes training material for transcription (from another book). For a more encyclopaedic treatment of the sounds of the world's languages, see Ladefoged & Maddieson (1996) instead. Links to this page Intro 3.1. Viewing a spectrogram 
Ladefoged___Maddieson__1996_	Ladefoged & Maddieson (1996) Peter Ladefoged & Ian Maddieson (1996). The sounds of the world's languages. Oxford: Blackwell. An extensive reference source for the articulation and acoustics of `all' vowels and consonants that occur in the world's languages. If you don't find the answer in this book, you will find the answer in the articles referred to in this book. The book uses lots of spectrograms, palatograms, and other techniques. The book is not an introductory text. For that, see Ladefoged (2001) instead. Links to this page Intro 3.1. Viewing a spectrogram 
Lamel_et_al___1986_	Lamel et al. (1986) L.F. Lamel, R.H. Kassel & S. Sennef (1986): Speech Database Development: Design and Analysis of the Acoustic-Phonetic Corpus. Proc. DARPA Speech Recognition Workshop, Report No. SAIC-86/1546, 100–119. Links to this page TIMIT acoustic-phonetic speech corpus 
Lee__1988_	Lee (1988) C.-H. Lee (1988): On Robust Linear Prediction of Speech., IEEE Trans. on ASSP 36: 642–649. Links to this page Sound: To Formant (robust)... 
Legendre_polynomials	Legendre polynomials The Legendre polynomials Pn(x) of degree n are special orthogonal polynomial functions defined on the domain [-1, 1]. Orthogonality: -1∫1 W(x) Pi(x) Pj(x) dx = δij W(x) = 1 (-1 < x < 1) They obey certain recurrence relations: n Pn(x) = (2n – 1) x Pn-1(x) – (n – 1) Pn-2(x) P0(x) = 1 P1(x) = x We may change the domain of these polynomials to [xmin, xmax] by using the following transformation: x′ = (2x – (xmax + xmin)) / (xmax - xmin). We subsequently use Pk(x′) instead of Pk(x). Links to this page Create LegendreSeries... LegendreSeries LegendreSeries: To Polynomial 
LegendreSeries	LegendreSeries One of the types of objects in PRAAT. An object of type LegendreSeries represents a linear combination of Legendre polynomials Pk(x). LegendreSeries (x) = Σk=1..numberOfCoefficients ck Pk(x) Links to this page Create LegendreSeries... LegendreSeries: To Polynomial 
LegendreSeries__To_Polynomial	LegendreSeries: To Polynomial A command to transform the selected LegendreSeries object into a Polynomial object. We find polynomial coefficients ck such that Σk=1..numberOfCoefficients ck xk = Σk=1..numberOfCoefficients lk Pk(x) We use the recurrence relation for Legendre polynomials to calculate these coefficients. 
lexicographic_permutation_order	lexicographic permutation order We can order the n numbers 1, 2, 3,..., n in n! different ways. Each of these n! orderings represents a different permutation of the numbers 1, 2, 3,..., n. For example, if n equals 3 we have 6 (=3·2·1) possible orderings: (1,2,3), (1,3,2), (2,1,3), (2,3,1), (3,1,2) and (3,2,1). The lexicographic permutation order starts from the identity permutation (1,2,..., n). By successively swapping only two numbers one obtains all possible permutations. The last permutation in lexicographic order will be the permutation with all numbers in reversed order, i.e. (n,n-1,...,2,1). The example given above has all 6 permutations in lexicographic permutation order. Links to this page Permutation: Next Permutation: Previous 
LFCC	LFCC One of the types of objects in PRAAT. An object of type LFCC represents cepstral coefficients on a linear frequency scale as a function of time. The coefficients are represented in frames with constant sampling period. LFCC commands Creation: LPC: To LFCC... Links to this page CC: To DTW... LFCC: To LPC... What was new in 4.0? 
LFCC__To_LPC___	LFCC: To LPC... You can choose this command after selecting 1 or more LFCC's. Settings Number of coefficients the desired number of linear predictive coefficients. Behaviour The transformation from cepstral coefficients to a-coefficients as described in Markel & Gray (1976). 
linear_interpolation	linear interpolation - the interpretation of values in tiers between the first point and the last point. Example The following is a PitchTier with three points: Between 0.10 and 0.20 seconds, the pitch rises linearly from 170 to 180 Hz, and between 0.20 and 0.45 seconds it falls linearly from 180 to 110 Hz. This is linear interpolation: at all times between two adjacent points, the pitch values follow the straight line that connects the two points. (Before 0.10 seconds and after 0.45 seconds there is constant extrapolation. Linear interpolation in Praat Praat uses linear interpolation in all tiers and grids with values at time points (PitchTier, IntensityTier, DurationTier, AmplitudeTier, FormantGrid). 
List_of_Objects	List of Objects A list in the left-hand part of the Object window. Purpose If you select one or more objects in this list, the possible actions that you can perform with the selected objects will appear in the Dynamic menu. How to select objects To select one object (and deselect all the others), click on the object. To extend the selection, drag the mouse (Unix, Windows) or use Shift-click (all platforms). To change the selection of one object (without changing the others), use Control-click (Unix, Windows) or Command-click (Macintosh). Links to this page ButtonEditor Editors Feedforward neural networks 2. Quick start Formulas 7. Attributes of objects Intro 2. What to do with a sound Intro 2.1. Saving a sound to disk Intro 3.5. The Spectrogram object Intro 3.8. The Spectrum object Intro 4.5. The Pitch object Intro 5.4. The Formant object Intro 6.4. The Intensity object Open menu TextGridEditor 
lnBeta	lnBeta lnBeta (a, b) Computes the logarithm of the beta function, subject to a and b and a+b not being negative integers. 
Log_files	Log files With some commands in the Query menu of the SoundEditor and TextGridEditor, you can write combined information about times, pitch values, formants, and intensities to the Info window and to a log file. A log file is a text file on disk. It consists of a number of similar lines, whose format you determine with the log settings in the Query menu. Every time you press F12 (or choose Log 1 from the Query menu, Praat writes a line to log file 1. If you press Shift-F12, Praat writes a line to log file 2. With the log settings command window, you determine the following: Log 1 to Info window this determines whether your log line will be written to the Info window or not. Log 1 to log file this determines whether your log line will be written to the log file or not. Log file 1 the name of the log file. On Windows, this has to be a complete path name, such as C:\WINDOWS\DESKTOP\Pitch Log.txt. On Unix and MacOS X, it can either be a complete path name, e.g. /home/mary/pitch_log, or a home-relative name such as ~/Desktop/Pitch log. Log 1 format the format of the line that Praat will write. See below. The same goes for log file 2. Usage The logging facility has been implemented in Praat especially for former users of Kay CSL, who have been used to doing it for years and like to continue doing it in Praat. Otherwise, you may prefer to use the TextGridEditor to mark time points and run an automatic analysis afterwards. If you do want to use the logging facility, you typically start by deleting any old log file (by choosing Delete log file 1 or Delete log file 2), if you want to re-use the file name. Otherwise, you can change the log file name (with Log settings...). After this, you will move the cursor to various time locations and press F12 (or Shift-F12) each time, so that information about the current time will be written to the log file. Example 1: pitch logging Suppose you want to log the time of the cursor and the pitch value at the cursor. You could use the following log format: Time 'time:6' seconds, pitch 'f0:2' hertz If you now click at 3.456789876 seconds, and the pitch happens to be 355.266 hertz at that time, the following line will be appended to the log file and/or to the Info window: Time 3.456790 seconds, pitch 355.27 hertz. The parts :6 and :2 denote the number of digits after the decimal point. If you leave them out, the values will be written with a precision of 17 digits. The words 'time' and 'f0' mean exactly the same as the result of the commands Get cursor and Get pitch. Therefore, if instead of setting a cursor line you selected a larger piece of the sound, 'time' will give the centre of the selection and 'f0' will give the mean pitch in the selection. Beware of the following pitfall: if your pitch units are not hertz, but semitones, then 'f0' will give the result in semitones. A format as in this example will then be misleading. Example 2: formant logging Suppose you want to log the start and finish of the selection, its duration, and the mean values of the first three formants, all separated by tab stops for easy importation into Microsoft® Excel™. You could use the following log format: 't1:4''tab$''t2:4''tab$''f1:0''tab$''f2:0''tab$''f3:0' You see that 't1' and 't2' are the start and finish of the selection, respectively, and that they are written with 4 digits after the decimal point. By using :0, the three formant values are rounded to whole numbers in hertz. The word 'tab$' is the tab stop. Loggable values The following values can be logged: 'time': the time of the cursor, or the centre of the selection. 't1': the start of the selection (B). 't2': the end of the selection (E). 'dur': the duration of the selection. 'freq': the frequency at the frequency cursor. 'f0': the pitch at the cursor time, or the mean pitch in the selection. 'f1', 'f2', 'f3', 'f4', 'f5': the first/second/third/fourth/fifth formant at the cursor time, or the mean first/second/third/fourth/fifth formant in the selection. 'b1', 'b2', 'b3', 'b4', 'b5': the bandwidth of the first/second/third/fourth/fifth formant at the cursor time or at the centre of the selection. 'intensity': the intensity at the cursor time, or the mean intensity in the selection, in dB. 'power': the spectral power at the cursor cross, in Pa2/Hz. 'tab$': the tab stop. 'editor$': the title of the editor window (i.e. the name of the visible Sound or TextGrid). More flexibility in logging You may sometimes require information in your log file that cannot be generated directly by the loggable values above. Suppose, for instance, that you want to log the values for F1 and F2-F1 at the points where you click. You could write the following script: f1 = Get first formant f2 = Get second formant f21 = f2 - f1 appendInfoLine: fixed$ (f1, 0), , fixed$ (f21, 0) appendFileLine: D:\Praat logs\Formant log.txt, fixed$ (f1, 0), tab$, fixed$ (f21, 0) With this script, the information would be appended both to the Info window and to the file Formant log.txt on your desktop. You can make this script accessible with Option-F12 (or Command-F12) by saving the script and specifying the name of the script file in the Log script 3 (or 4) field in the Log settings... window. These scripts may take arguments. Suppose, for instance, that you want to specify a vowel symbol as you press Option-F12. The following script will take care of that: form Save vowel and formants word Vowel a endform f1 = Get first formant f2 = Get second formant f21 = f2 - f1 appendInfoLine: vowel$, , fixed$ (f1, 0), , fixed$ (f21, 0) appendFileLine: ~/Praat logs/Vowels and formants log, vowel$, tab$, fixed$ (f1, 0), tab$, fixed$ (f21, 0) Beware of the following pitfall: because of the nature of scripts, you should not try to do this when you have two editor windows with the same name. I cannot predict which of the two windows will answer the Get queries... Links to this page What was new in 4.0? 
Logarithmic_marks_left_right_top_bottom___	Logarithmic marks left/right/top/bottom... Four of the commands in the Margins menu of the Picture window. Purpose To draw a specified number of marks per decade into the margins around the drawing area, along a logarithmic axis. Settings Marks per decade the number of marks that will be drawn for every decade. Write numbers if on, real numbers will be written in the margin, expressed in the domain or range of your latest drawing in the horizontal or vertical direction. Draw ticks if on, short line pieces will be drawn in the margin. Draw dotted lines if on, dotted lines will be drawn through your drawing. Behaviour If your vertical logarithmic axis runs from 10 to 100, and Marks per decade is 1, marks will only be drawn at 10 and 100; if Marks per decade is 2, marks will be drawn at 10, 30, and 100; if it is 3, marks will be drawn at 10, 20, 50, and 100; if it is 4, marks will be drawn at 10, 20, 30, 50, and 100; if it is 5, marks will be drawn at 10, 20, 30, 50, 70, and 100; if it is 6, marks will be drawn at 10, 15, 20, 30, 50, 70, and 100; if it is 7 (the maximum), marks will be drawn at 10, 15, 20, 30, 40, 50, 70, and 100. 
Logistic_regression	Logistic regression This page explains how you do logistic regression with Praat. You start by saving a table in a text file (if it contains non-ASCII symbols such as æ or ɛ, use the UTF-8 or UTF-16 format). The following example contains natural stimuli (female speaker) with measured F1 and duration values, and the responses of a certain listener who is presented each stimulus 10 times. F1 Dur /æ/ /ɛ/ 764 87 2 8 674 104 3 7 574 126 0 10 566 93 1 9 618 118 1 9 1025 147 10 0 722 117 7 3 696 169 9 1 1024 124 10 0 752 92 6 4 In this table we see 10 different stimuli, each characterized by a certain combination of the factors (independent variables) F1 (first formant in Hertz) and Dur (duration in milliseconds). The first row of the table means that there was a stimulus with an F1 of 764 Hz and a duration of 87 ms, and that the listener responded to this stimulus 2 times with the response category /æ/, and the remaining 8 times with the category /ɛ/. A table as above can be typed into a text file. The columns can be separated with spaces and/or tab stops. The file can be read into Praat with Read Table from table file.... The command To logistic regression... will become available in the Statistics menu. What does it do? The logistic regression method will find values α, βF1 and βdur that optimize α + βF1 F1k + βdur Durk = ln (pk(/ɛ/)/pk(/æ/)) where k runs from 1 to 10, and pk(/æ/) + pk(/ɛ/) = 1. The optimization criterion is maximum likelihood, i.e. those α, βF1 and βdur will be chosen that lead to values for pk(/æ/) and pk(/ɛ/) that make the observations in the table most likely. Praat will create an object of type LogisticRegression in the list. When you then click the Info button, Praat will write the values of α (the intercept), βF1 and βdur into the Info window (as well as much other information). The number of factors does not have to be 2; it can be 1 or more. The number of dependent categories is always 2. Links to this page Statistics What was new in 5.0? 
LongSound	LongSound One of the types of objects in Praat. See the Sound files tutorial. A LongSound object gives you the ability to view and label a sound file that resides on disk. You will want to use it for sounds that are too long to read into memory as a Sound object (typically, a few minutes). How to create a LongSound object You create a LongSound object with Open long sound file... from the Open menu. What you can do with a LongSound object You can save a LongSound object to a new sound file, perhaps in a different format (AIFF, AIFC, WAV, NeXT/Sun, NIST, FLAC) with the commands in the Save menu. You can also concatenate several LongSound objects in this way. See How to concatenate sound files. How to view and edit a LongSound object You can view a LongSound object in a LongSoundEditor by choosing LongSound: View. This also allows you to extract parts of the LongSound as Sound objects, or save these parts as a sound file. There are currently no ways to actually change the data in the file. How to annotate a LongSound object You can label and segment a LongSound object after the following steps: 1. Select the LongSound object. 2. Choose LongSound: To TextGrid... and specify your tiers. 3. Select the resulting TextGrid object together with the LongSound object, and click View & Edit. A TextGridEditor will appear on the screen, with a copy of the LongSound object in it. Limitations The length of the sound file is limited to 2 gigabytes, which is 3 hours of CD-quality stereo, or 12 hours 16-bit mono sampled at 22050 Hz. Links to this page Get number of samples Get sample number from time... Get time from sample number... Intro 2.2. Viewing and editing a sound Intro 3.1. Viewing a spectrogram Intro 4.1. Viewing a pitch contour Intro 5.1. Viewing formant contours Intro 6.1. Viewing an intensity contour Intro 7. Annotation Save as AIFC file... Save as AIFF file... Save as FLAC file... Save as NeXT/Sun file... Save as NIST file... Save as WAV file... Sound files 3. Files that Praat can read SpellingChecker What was new in 3.8? 
LongSound__To_TextGrid___	LongSound: To TextGrid... A command to create a TextGrid without any labels, copying the time domain from the selected LongSound. See Sound: To TextGrid... for the settings. Links to this page Intro 7. Annotation 
LongSound__View	LongSound: View A command to view the selected LongSound object in a LongSoundEditor. 
LongSoundEditor	LongSoundEditor One of the Editors in Praat, for viewing a LongSound object. This viewer allows you: • to view and hear parts of the sound as it is on disk; • to copy a selected part as a Sound object to the list of objects, so that you can perform analyses on it or save it to a smaller sound file; • to copy a selected part as a Sound object to the Sound clipboard, so that you can paste it into another Sound object that you are viewing in a SoundEditor. To label and segment the LongSound object, use the TextGridEditor instead (see LongSound). The display and playback of the samples is restricted to 60 seconds at a time, for reasons of speed (although you can change this number with LongSound prefs from the main Preferences menu; the sound file itself can contain several hours of sound. Links to this page Intro 3.1. Viewing a spectrogram LongSound: View Types of objects 
LPC	LPC One of the types of objects in PRAAT. An object of type LPC represents filter coefficients as a function of time. The coefficients are represented in frames with constant sampling period. LPC commands Creation: Sound: To LPC (autocorrelation)... Sound: To LPC (covariance)... Sound: To LPC (burg)... Sound: To LPC (marple)... Conversion To LFCC... To Spectrogram... To Spectrum (slice)... To Polynomial (slice)... Links to this page Acknowledgments LPC & Sound: Filter (inverse) LPC & Sound: Filter (inverse) with filter at time... LPC & Sound: Filter with filter at time... LPC & Sound: Filter... LPC: Draw gain... LPC: Draw poles... LPC: To Formant LPC: To Matrix LPC: To VocalTract (slice)... Sound: LPC analysis Source-filter synthesis 4. Using existing sounds 
LPC___Sound__Filter___	LPC & Sound: Filter... A command that creates a new Sound object from one Sound and one LPC object which have been selected together. Settings Use LPC gain Determines whether the gain from the LPC is used in the synthesis. Behaviour Filters the selected Sound by the selected LPC-filter. When the LPC-gain is used the samples in the new Sound will be multiplied with the square root of the corresponding LPC-gain value. In Z-domain notation: O(z) = H(z) · E(z), where E(z) is the selected filter input Sound, H(z) the selected LPC filter, and, O(z) the filter output (the new Sound that will appear in the List of objects). Links to this page Filtering Source-filter synthesis 4. Using existing sounds 
LPC___Sound__Filter__inverse_	LPC & Sound: Filter (inverse) A command that creates a new Sound object from one Sound and one LPC object which have been selected together. Behaviour Given a filter (the selected LPC) and its output (the selected Sound), its input is reconstructed (the new Sound that will appear in the List of objects). In Z-domain notation: E(z) = O(z) / H(z), where O(z) is the filter output Sound, H(z) the LPC filter, and, E(z) the filter input Sound. (Selecting this newly generated Sound and the LPC, choosing the option `Filter...' generates a Sound that is identical to the Sound that originated the LPC.) Links to this page Filtering 
LPC___Sound__Filter__inverse__with_filter_at_time___	LPC & Sound: Filter (inverse) with filter at time... Inverse filters the selected Sound with a static inverse filter that is formed by the filter coefficients from only one LPC frame. Settings Channel determines the sound channel to be filtered. Use filter at time (s) determines which LPC frame will be chosen to inverse filter the sound. 
LPC___Sound__Filter_with_filter_at_time___	LPC & Sound: Filter with filter at time... Filters the selected Sound with a static filter that is formed by the filter coefficients from only one LPC frame. Settings Channel determines the sound channel to be filtered. Use filter at time (s) determines which LPC frame will be chosen to filter the sound. 
LPC__Draw_gain___	LPC: Draw gain... You can choose this command after selecting 1 or more LPC objects. Settings From time (s), To time (seconds) the time domain along the x-axis. Minimum gain, Maximum gain the range for the y-axis. Garnish determines whether to draw a bounding box and axis labels. Behaviour Gain will be drawn as a function of time (gain also equals the prediction error energy). 
LPC__Draw_poles___	LPC: Draw poles... You can choose this command after selecting 1 or more LPC objects. Settings Time (s) the time of the nearest frame. Behaviour The roots of the linear prediction polynomial, constructed from the coefficients of the analysis frame, will be drawn in the complex plane. 
LPC__To_Formant	LPC: To Formant You can choose this command after selecting 1 or more LPC objects. Behaviour For each LPC_Frame, the zeros of the linear prediction polynomial are extracted. Zeros that are outside the unit circle are reflected into it. Next, formant frequencies and bandwidths are calculated from all the roots that have the imaginary part positive, i.e., that lie in the upper half of the unit circle. Formant frequencies smaller than 50 Hz or larger than (Nyquist_frequency - 50) are discarded. The remaining frequencies and bandwidths are sorted and copied to the Formant_Frame. Finally, the gain field of the LPC is copied to the intensity field of the Formant_Frame. Algorithm The root finder is Laguerre's method followed by root polishing, see Press et al. (1992). Warning The formant values can be very inaccurate if you did not resample the Sound before the LPC-analysis (consult the Source-filter synthesis tutorial). The results of the root finder may not always be accurate when more than 30 roots have to be found. Links to this page Source-filter synthesis 4. Using existing sounds 
LPC__To_LFCC___	LPC: To LFCC... You can choose this command after selecting 1 or more LPC objects. Behaviour The transformation from a-coefficients to cepstral coefficients as described in Markel & Gray (1976). Settings Number of coefficients the desired number of cepstral coefficients. Links to this page LFCC 
LPC__To_Matrix	LPC: To Matrix Copies the linear prediction coefficients of the selected LPC object to a newly created Matrix object. Behaviour zji = aij, with 1 ≤ i ≤ nx and 1 ≤ j ≤ nCoefficientsi, where zji is the matrix element in row j and column i and aij is the j-th linear prediction coefficient in frame i. 
LPC__To_Polynomial__slice____	LPC: To Polynomial (slice)... A command that creates a Polynomial object from each selected LPC object. Settings Time (s) defines the LPC frame whose coefficents will be selected. Behaviour The linear prediction coefficients a1..n of the selected LPC frame will be copied to polynomial coefficients c1..n+1 as follows: ci = an–i+1, cn+1 = 1 Links to this page LPC: Draw poles... Polynomial 
LPC__To_Spectrogram___	LPC: To Spectrogram... You can choose this command after selecting 1 or more LPC objects. Settings Minimum frequency resolution (Hz) successive frequencies in the Spectrum will be maximally this distance apart Bandwidth reduction (Hz) formants with small bandwidths show up very well as darker regions in the spectrogram because the poles lie close to the contour along which a spectrum is computed (the unit circle in the z-plane). Peak enhancement can be realized by computing a spectrum in the z-plane along a contour of radius r = exp (– π · bandwidthReduction / samplingFrequency). De-emphasis frequency (Hz) Performs de-emphasis when value is in the interval (0, Nyquist frequency) Algorithm For each LPC_Frame the corresponding Spectrum will be calculated according to the algorithm explained in LPC: To Spectrum (slice).... For each frequency the power, i.e., the square of the complex values, will be stored in the corresponding area in the Spectrogram. Links to this page Source-filter synthesis 4. Using existing sounds 
LPC__To_Spectrum__slice____	LPC: To Spectrum (slice)... You can choose this command after selecting 1 or more LPC objects. Settings Time (s) the time at which the Spectrum must be calculated. Minimum frequency resolution (Hz) successive frequencies in the Spectrum will be maximally this distance apart. Bandwidth reduction (Hz) formants with small bandwidths show up very well as peaks in the spectrum because the poles lie close to the contour along which the spectrum is computed (the unit circle in the z-plane). Peak enhancement can be realized by computing the spectrum in the z-plane along a contour of radius r = exp (– π · bandwidthReduction / samplingFrequency). This technique is also called off-axis spectrum computation. Negative values evaluate the spectrum on a contour outside the unit circle and therefore result in a flattened spectrum. De-emphasis frequency (Hz) Performs de-emphasis when frequency is in the interval (0, Nyquist frequency) Algorithm The Spectrum at time t will be calculated from the nearest LPC_Frame according to: Spectrum (f) = √(gain·T/df) / (1 + ∑k=1..numberOfCoefficients akz–k), where T is the sampling period and z = exp (–2 π i f T) and df is the distance in Hz between two successive components in the Spectrum. 1. Allocate a large enough buffer[1..nfft] to perform an FFT analysis. 2. Make the first value of the buffer 1 and copy the prediction coefficients a into the buffer. This results in buffer values: (1, a1, ..., anumberOfCoefficients, 0, ..., 0). 3. If De-emphasis frequency is in the interval (0, nyquistFrequency) then multiply the buffer with (1 - b z–1), where b = exp (– π deEmphasisFrequency T). This results in buffer values: (1, a1–b, a2–b·a1, ..., anumberOfCoefficients–b·anumberOfCoefficients–1, –b·anumberOfCoefficients, 0, ..., 0). Note that the number of values in the buffer that differ from 0 has increased by one. 4. If Bandwidth reduction is greater than 0 then multiply corresponding values in the buffer by gi–1 where g = exp (2π bandwidthReduction T / nfft), and i is the position index in the buffer. i runs from 1 to numberOfCoefficients+1+t, where t equals 1 when de-emphasis was performed, else 0. 5. Calculate the FFT spectrum of the buffer with the coefficients. This results in complex amplitudes (aj,bj), j=1..nfft/2+1. 6. Calculate the LPC Spectrum by taking the inverse of the FFT spectrum, i.e., each complex amplitude becomes (aj,bj)–1 = (aj,–bj) / (aj2 + bj2) 7. Multiply all values with the scale factor √(gain·T/df). Links to this page LPC: To Spectrogram... 
LPC__To_VocalTract__slice____	LPC: To VocalTract (slice)... You can choose this command after selecting 1 or more LPC objects. Settings Time (s) the time of the nearest frame, in seconds. Length (m) the length of the vocal tract, in metres. 
Ltas	Ltas One of the types of objects in Praat. Ltas is short for Long-Term Average Spectrum. An object of class Ltas represents the logarithmic power spectral density as a function of frequency, expressed in dB/Hz relative to 2·10-5 Pa. Inside an Ltas object With Inspect, you will see the following attributes: xmin the bottom of the frequency domain, in hertz. Usually 0. xmax the top of the frequency domain, in hertz. nx the number of frequency bins (≥ 1). dx the frequency step, or bin width, in hertz. x1 the frequency associated with the first bin, in hertz. Usually equals dx / 2, because the first bin tends to start at 0 hertz. z1i, i = 1 ... nx the power spectral density, expressed in dB. Links to this page Ltas: Get bin number from frequency... Ltas: Get bin width Ltas: Get frequency from bin number... Ltas: Get frequency of maximum... Ltas: Get frequency of minimum... Ltas: Get highest frequency Ltas: Get lowest frequency Ltas: Get maximum... Ltas: Get mean... Ltas: Get minimum... Ltas: Get number of bins Ltas: Get standard deviation... Ltas: Get value at frequency... Ltas: Get value in bin... Sound: To Ltas (pitch-corrected)... Spectrum: To Ltas (1-to-1) What was new in 3.7? 
Ltas__Get_bin_number_from_frequency___	Ltas: Get bin number from frequency... A query to the selected Ltas object. Return bin the band number belonging to the specified frequency, expressed as a real number. Example If the Ltas has a bin width of 1000 Hz, and the lowest frequency is 0 Hz, the bin number associated with a frequency of 1800 Hz is 2.3. Scripting You can use this command to put the nearest bin centre into a script variable: selectObject: Ltas hallo bin = Get bin number from frequency: 1800 nearestBin = round (bin) In this case, the value will not be written into the Info window. To round down or up, use leftBin = floor (bin) rightBin = ceiling (bin) 
Ltas__Get_bin_width	Ltas: Get bin width A query to the selected Ltas object. Return value the with of a bin, expressed in hertz. 
Ltas__Get_frequency_from_bin_number___	Ltas: Get frequency from bin number... A query to the selected Ltas object. Return value the frequency (in hertz) associated with a specified bin number. Setting Bin number the bin number whose frequency is sought. Algorithm the result is f1 + (binNumber - 1) · Δf where f1 is the frequency associated with the centre of the first bin, and Δf is the bin width. 
Ltas__Get_frequency_of_maximum___	Ltas: Get frequency of maximum... A query to the selected Ltas object. Return value the frequency (in hertz) associated with the maximum energy density. Settings From frequency (Hz) To frequency (Hz) the selected frequency domain. Values outside this domain are ignored. If To frequency is not greater than From frequency, the entire frequency domain of the Ltas object is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is None because of the usual large binning. If the Ltas was computed with Spectrum: To Ltas (1-to-1), a Parabolic or Cubic interpolation would be more appropriate. 
Ltas__Get_frequency_of_minimum___	Ltas: Get frequency of minimum... A query to the selected Ltas object. Return value the frequency (in hertz) associated with the minimum energy density. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored. If t1 is not less than t2, the entire frequency domain of the Ltas is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is None because of the usual large binning. If the Ltas was computed with Spectrum: To Ltas (1-to-1), a Parabolic or Cubic interpolation would be more appropriate. 
Ltas__Get_highest_frequency	Ltas: Get highest frequency A query to the selected Ltas object. Return value the highest frequency, expressed in hertz. 
Ltas__Get_lowest_frequency	Ltas: Get lowest frequency A query to the selected Ltas object for its lowest frequency. Return value the lowest frequency, expressed in Hertz. It is usually 0 Hz. 
Ltas__Get_maximum___	Ltas: Get maximum... A query to the selected Ltas object. Return value the maximum value (in dB) within a specified frequency range. Settings From frequency (Hz)) To frequency (Hz) the selected frequency domain. Values outside this domain are ignored. If To frequency is not greater than From frequency, the entire frequency domain of the Ltas object is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is None because of the usual large binning. If the Ltas was computed with Spectrum: To Ltas (1-to-1), a Parabolic or Cubic interpolation would be more appropriate. 
Ltas__Get_mean___	Ltas: Get mean... A query to the selected Ltas object. Return value the mean value (in dB) within a specified frequency range. Settings From frequency (Hz)) To frequency (Hz) the frequency range. Values outside this range are ignored. If To frequency is not greater than From frequency, the entire frequency domain of the Ltas is considered. Algorithm The mean value between the frequencies f1 and f2 is defined as 1/(f2 - f1) ∫f1f2 df x(f) where x(f) is the LTAS as a function of frequency, expressed in dB. For our discrete Ltas object, this mean is approximated by 1/n ∑i=m..m+n-1 xi where n is the number of band centres between f1 and f2. 
Ltas__Get_minimum___	Ltas: Get minimum... A query to the selected Ltas object. Return value the minimum value (in dB) within a specified frequency range. Settings From frequency (Hz)) To frequency (Hz) the selected frequency domain. Values outside this domain are ignored. If To frequency is not greater than From frequency, the entire frequency domain of the Ltas object is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is None because of the usual large binning. If the Ltas was computed with Spectrum: To Ltas (1-to-1), a Parabolic or Cubic interpolation would be more appropriate. 
Ltas__Get_number_of_bins	Ltas: Get number of bins A query to the selected Ltas object. Return value the total number of frequency bins. 
Ltas__Get_standard_deviation___	Ltas: Get standard deviation... A query to the selected Ltas object. Return value the standard deviation (in dB) of the LTAS within a specified frequency domain. Settings From frequency (Hz)) To frequency (Hz) the frequency window. Values outside this domain are ignored. If To frequency is not greater than From frequency, the entire frequency domain of the Ltas is considered. Algorithm The standard deviation between the frequencies f1 and f2 is defined as 1/(f2 – f1) ∫f1f2 df (x(f) – μ)2 where x(f) is the LTAS as a function of frequency, and μ its mean. For our discrete Ltas object, the standard deviation is approximated by 1/(n–1) ∑i=m..m+n-1 (xi – μ)2 where n is the number of band centres between f1 and f2. Note the minus 1. 
Ltas__Get_value_at_frequency___	Ltas: Get value at frequency... A query to the selected Ltas object. Return value the value (in dB) at a specified frequency. If frequency is outside the bands of the Ltas, the result is 0. Settings Frequency (Hz) the frequency at which the value is to be evaluated. Interpolation the interpolation method, see vector value interpolation. The standard is None because binning is usually large. 
Ltas__Get_value_in_bin___	Ltas: Get value in bin... A query to the selected Ltas object. Return value the LTAS value (in dB) in a specified bin. If the bin number is less than 1 or greater than the number of bin, the result is 0; otherwise, it is z [1] [bin number]. Setting Bin number the bin whose value is to be looked up. 
Macintosh_sound_files	Macintosh sound files A way for storing a Sound object on disk. File format The double-clickable sound file of the Macintosh (8 bits per sample). Cannot be ported to other machines, because the sound is in the resource fork. Reading With Read from file.... To read a Sound from a Macintosh sound file on disk, use Read from file... (Macintosh only). The 8-bit sample values are divided by 128 so that the amplitude of the resulting Sound is between –1.0 and +1.0. The resulting Sound will appear in the list of objects; its name will be equal to the file name, without extension. Saving With Save as Mac sound file.... Praat asks you for a file name. After you click OK, 0.5 is added to the samples of the Sound, they are multiplied by 128 and quantized between 0 and 255; the result is written to the file in 8-bit linear Macintosh sound-file format. To avoid clipping, keep the absolute amplitude below 1.000. If the maximum sound pressure level is 91 dB (top = 127), the quantization threshold for a sine wave is (top = 1/2) 43 dB. 
Manipulation	Manipulation One of the types of objects in Praat, for changing the pitch and duration contours of a sound. Inside a manipulation object With Inspect, you will see the following attributes: timeStep the time step (or frame length) used in the pitch analysis. A common value is 0.010 seconds. minimumPitch the minimum pitch frequency considered in the pitch analysis. A common value is 75 hertz. maximumPitch the maximum pitch frequency considered in the pitch analysis. A common value is 600 hertz. A Manipulation object also contains the following smaller objects: 1. The original Sound. 2. A PointProcess representing glottal pulses. 3. A PitchTier. 4. A DurationTier. Analysis When a Manipulation object is created from a sound, the following steps are performed: 1. A pitch analysis is performed on the original sound, with the method of Sound: To Pitch.... This uses the time step, minimum pitch, and maximum pitch parameters. 2. The information of the resulting pitch contour (frequency and voiced/unvoiced decisions) is used to posit glottal pulses where the original sound contains much energy. The method is the same as in Sound & Pitch: To PointProcess (cc). 3. The pitch contour is converted to a pitch tier with many points (targets), with the method of Pitch: To PitchTier. 4. An empty DurationTier is created. Resynthesis A Manipulation object can produce Sound input. This Sound can be computed in several ways: • overlap-add: from original sound + pulses + pitch tier + duration tier; • LPC: from LPC (from original sound) + pulses + pitch tier; • from the pulses only, as a pulse train or hummed; • from the pitch tier only, as a pulse train or hummed. Links to this page Intro 8.1. Manipulation of pitch Intro 8.2. Manipulation of duration Manipulation: Extract duration tier Manipulation: Extract original sound Manipulation: Extract pitch tier Manipulation: Extract pulses Manipulation: Get resynthesis (overlap-add) Manipulation: Play (overlap-add) Manipulation: Replace duration tier Manipulation: Replace original sound Manipulation: Replace pitch tier Manipulation: Replace pulses ManipulationEditor What was new in 4.0? 
Manipulation__Extract_duration_tier	Manipulation: Extract duration tier A command to extract a copy of the duration information in each selected Manipulation object into a new DurationTier object. 
Manipulation__Extract_original_sound	Manipulation: Extract original sound A command to copy the original sound in each selected Manipulation object to a new Sound object. 
Manipulation__Extract_pitch_tier	Manipulation: Extract pitch tier A command to extract a copy of the pitch information in each selected Manipulation object into a new PitchTier object. 
Manipulation__Extract_pulses	Manipulation: Extract pulses A command to extract a copy of the vocal-pulse information in each selected Manipulation object into a new PointProcess object. 
Manipulation__Get_resynthesis__overlap-add_	Manipulation: Get resynthesis (overlap-add) A command to extract the sound from each selected Manipulation object, resynthesized with the overlap-add method. 
Manipulation__Play__overlap-add_	Manipulation: Play (overlap-add) A command to play each selected Manipulation object, resynthesized with the overlap-add method. 
Manipulation__Replace_duration_tier	Manipulation: Replace duration tier You can replace the duration tier that you see in your Manipulation object with a separate DurationTier object, for instance one that you extracted from another Manipulation or one that you created with Create DurationTier.... To do this, select your Manipulation object together with the DurationTier object and click Replace duration tier. 
Manipulation__Replace_original_sound	Manipulation: Replace original sound A command to replace the original sound in the selected Manipulation object with the selected Sound object. 
Manipulation__Replace_pitch_tier	Manipulation: Replace pitch tier You can replace the pitch tier that you see in your Manipulation object with a separate PitchTier object, for instance one that you extracted from another Manipulation or one that you created with Create PitchTier.... To do this, select your Manipulation object together with the PitchTier object and click Replace pitch tier. 
Manipulation__Replace_pulses	Manipulation: Replace pulses A command to replace the vocal-pulse information in the selected Manipulation object with the selected PointProcess object. 
ManipulationEditor	ManipulationEditor One of the Editors in Praat, for viewing and manipulating a Manipulation object. Objects The editor shows: • The original Sound. • The PointProcess that represents the glottal pulses. You can edit it for improving the pitch analysis. • A pitch contour based on the locations of the pulses, for comparison (drawn as grey dots). Changes shape if you edit the pulses. • The PitchTier that determines the pitch contour of the resynthesized Sound (drawn as blue circles). At the creation of the Manipulation object, it is computed from the original pitch contour. You can manipulate it by simplifying it (i.e., removing targets), or by moving parts of it up and down, and back and forth. • A DurationTier for manipulating the relative durations of the voiced parts of the sound. Playing To play (a part of) the resynthesized sound (by any of the methods shown in the Synth menu, like overlap-add and LPC), click on any of the 1 to 8 buttons below and above the drawing area or use the Play commands from the View menu. To play the original sound instead, use Shift-click. Pulses To add: click at the desired time location, and choose Add pulse at cursor or type Command-p. To remove: make a time selection, and choose Remove pulse(s) or type Option-Command-p. If there is no selection, the pulse nearest to the cursor is removed. Pitch points To add one at a specified time and frequency: click at the desired time-frequency location, and choose Add pitch point at cursor or type Command-t. To add one at a specified time only: click at the desired time, and choose Add pitch point at time slice. ManipulationEditor tries to compute the frequency from the intervals between the pulses, basically by a median-of-three method. To remove: make a time selection, and choose Remove pitch point(s) or type Option-Command-t. If there is no selection, the pitch point nearest to the cursor is removed. To move some: make a time selection (the points become red) and Shift-drag the points across the window. You cannot drag them across adjacent points, or below 50 Hz, or above the maximum frequency. You can only drag them horizontally if the dragging strategy is All or Only horizontal, and you can drag them vertically if the dragging strategy is not Only horizontal. You can change the dragging strategy with Set pitch dragging strategy... from the Pitch menu. To move one: drag that point across the window. You can only drag it horizontally if the dragging strategy is not Only vertical, and you can drag it vertically if the dragging strategy is not Only horizontal. Duration points Work pretty much the same as pitch points. Stylization Before editing the Pitch points, you may want to reduce their number by choosing any of the Stylize commands from the Pitch menu. Links to this page Intro 8.1. Manipulation of pitch Intro 8.2. Manipulation of duration Intro 8.3. Manipulation of intensity PitchTier: Stylize... Source-filter synthesis 4. Using existing sounds Types of objects What was new in 3.6? What was new in 4.0? 
ManPages	ManPages You can create a documentation or education system with files that you and others can read into Praat (with the Read from file... command). Your files will become a hypertext system very similar to the usual Manual. Example 1: a single document If you create a single ManPages text file, it will look like a manual with a single page. Here is an example: ManPagesTextFile Welkom miep 19970820 0 <intro> Hallo allemaal! <entry> Belangrijk... <normal> Hoogge\eerd publiek! <normal> Einde. A ManPages text file should start with the following information: 1. The word ManPagesTextFile on the first line. 2. The title of the manual page, between double quotes. This will be drawn at the top of the page. The name of the ManPages text file should be derived from this title (see below). 3. The author of the manual page, between double quotes. This will be drawn at the bottom of the page. 4. The date you created or modified the page, in the format year – month (two digits) – day (two digits), without spaces. 5. The recording time. If this is not zero, three sound buttons (see below) will appear at the top of the page. 6. A sequence of paragraph types and texts. You put the types between < and >, and the texts between double quotes (if your text contains a double quote, you should write two double quotes). The format of a ManPages text file is rather free, as long as the first line is correct, the four required pieces of information are there in the correct order, and there is a correct alternation between paragraph texts and types. If you put multiple elements on a line, there should be at least one space between them. You may distribute texts across multiple lines, as long as you do not add any spaces: <normal> Hoogge\eerd publiek! This will have exactly the same effect as above. Example 2: multiple documents The above example with a single document is not very useful. You will usually want to refer to other documents: ManPagesTextFile Welcome Paul Boersma 19970820 1.0 <intro> Welcome to Paul's transcription course. <entry> Groups of speech sounds <normal> You can listen to the following sounds from the languages of the world, pronounced by a single speaker (me):” <list_item> @Vowels, quite problematic for Dutch students! <list_item> @@Dorsal fricatives@, equally problematic! With the symbol `@', you create a link to another ManPages text file. A link will be drawn in blue on your screen. In this example, you have created links to the files Vowels.man and Dorsal_fricatives.man in the same directory as the current file (all .man files have to be in the same directory; this makes it likely that their names are unique). If the link contains spaces or other non-alphanumeric symbols, you have to use three `@' symbols, as shown; with a single word, you may use a single `@'. In resolving the file name, the ManPages system replaces spaces and other special symbols with underscores, and converts any initial lower-case character by its upper-case variant. For instance, if your link is @@back vowels@, the file name will be Back_vowels.man. The title in the second line of Back_vowels.man must be equal to the link name, though capitalization of the first letter is allowed. Thus, the title of Back_vowels.man will probably be Back vowels. Likewise, the starting file with the title Welcome should have the name Welcome.man if any other files refer to it. Paragraph types A normal paragraph will have type <normal>. The hypertext system will leave a blank space between paragraphs with this type. The first paragraph of a manual page will normally have the type <intro>. Though this may look the same as <normal>, the search system of the Manual may take account of the distinction. Headings (like the title Paragraph types of this subsection) have type <entry>. This will be drawn in a larger character size. For lists, you use the type <list_item>. You will often combine this with button symbols, like in the following: <normal> Choose a colour: <list_item> \bu @Red. <list_item> \bu @Green. <list_item> \bu @Blue. For text that should appear with a fixed character width, you use the type <code>. For a paragraph that should be connected with the following paragraph without leaving a blank space (probably a list item or a definition), you use the type <tag>. For a paragraph with a blank left margin, you use the type <definition>. For a paragraph with an embedded script (a picture), you use the type <script> (see below). Special symbols and styles You can use all of Praat's special symbols and text styles, except that some single text-style symbols have different meanings: A single percent sign introduces a word in italic: %pot gives pot. A single number sign introduces a word in bold: #pot gives pot. A single dollar sign introduces a word in monospace: $pot gives pot. A single underscore is rendered as an underscore: a_b gives a_b. To create a single italic, bold, or subscripted letter, you revert to the usual technique for stretches of italic, bold, or subscripted text. So, to get F1, you type %F__1_. Sound links Your text may contain links to sound files. They are drawn in blue. The format is: <normal> You should know that @@\FIct.aifc|\ct@ is more open than @@\FIo.aifc|o@. On your screen, you will see an ɔ and an o symbol, both drawn in blue. If you click on one of these sound links, one of the sound files ct.aifc or o.aifc will be played. The format of the sound link @@\FIo.aifc|o@ is to be understood as follows. The pipe symbol separates the link information (\FIo.aifc) from the viewable link text (o). The link information is introduced with a symbol (\FI) that tells the manual system that a sound file name follows. The manual system reads this file, sees that it contains a sound, and plays that sound. You can use relative path names, e.g., \FIsounds/o.aifc refers to the file o.aifc in the subdirectory sounds, which must be contained in the same directory as the .man files. To make sure that your manual pages run on all platforms (Windows, Macintosh, Unix), you will want to use the forward slash (/) to separate the directory name(s) from the file name, as in this example (i.e. you avoid the backslash (\) that is usual on Windows computers). Pictures as embedded scripts Your text may contain Praat scripts. They typically draw a picture in your manual page, with the font and font size of the manual until you specify otherwise in the script. The format is: <script> 4.5 4 Draw inner box Axes: 0, 100, 0, 100 Text: 50, Centre, 50, Half, Hello!! ” The two numbers after <script> are the width and the height of the picture (the outer viewport) in inches, if the font size of the manual is 12. If the font size is larger, the viewport will be scaled up accordingly. Please note that the script is enclosed within double quotes. Therefore, you will have to double any double quotes that occur in the script. If needed, a script like this can create objects in the object list of the manual. However, you have to make sure that you remove them after use: <script> 6 3 Create Sound from formula: sineWithNoise, 1, 0.0, 1.0, 44100, 1/2*sin(2*pi*377*x)+randomGauss(0,0.1) To Spectrogram: 0.005, 5000, 0.002, 20, Gaussian Paint: 0, 0, 0, 0, 100.0, yes, 50.0, 6.0, 0.0, yes plusObject: Sound sineWithNoise Remove ” Note that unlike the previous script, this script does not set the font and font size. This means that the drawing will use the font and font size of the manual page, which is usually what you want. For obvious safety reasons, embedded scripts cannot contain commands that change the contents of any disk or send messages. Thus, commands like Save as WAV file..., filedelete out.txt, string$ >> out.txt, system, or sendpraat are forbidden. Several other commands, such as pause and editor, are irrelevant inside pictures and are therefore forbidden as well. Note that commands like echo, Read from file..., and execute are still available (with the last two, you can use relative paths; with execute, you can only run scripts that do not contain any of the forbidden commands). The commands Set outer viewport... and Set inner viewport... are available; they count in inches (if the font size of the manual is 12). The (0, 0) point is in the upper left corner, as in the Picture window, so that you can test your picture with a normal Praat script; for instance, the following script draws a cross in the upper half of the picture and a rectangle in the lower half: <script> 4.5 4 Axes: 0, 100, 0, 100 Select inner viewport: 0, 4.5, 0, 2 Draw line: 0, 0, 100, 100 Draw line: 0, 100, 100, 0 Select inner viewport: 0, 4.5, 2, 4 Draw rectangle: 0, 100, 0, 100 ” Script links Your text may contain links to Praat scripts. They are drawn in blue. The format is: <normal> Here is a script that @@\SCdraw.praat|draws@ what you have selected. On your screen, you will see the word draws, drawn in blue. If you click on it, the script draw.praat will be executed. The string \SC indicates that a script file name follows. As with sounds, you can use relative file paths. The script can take arguments: <normal> This script @@\SCload2files.praat hello.wav hello.TextGrid|loads@ some files. If the script file name or any arguments except the last contain spaces, they have to be enclosed within double quotes, which have to be doubled again in the ManPage code: <normal> Here is a script that @@\SCmy scripts/draw.praat|draws@ what you have selected. <normal> This script @@\SCmy scripts/load2files.praat my sounds/hello.wav my textgrids/hello.TextGrid|loads@ some files. For safety reasons, the user will see a warning about trusting the author of the manual pages if you include script links in your manual. How to separate link information and link text The separation between link information and viewable link text, as seen in the above description of sound and script links, is actually a general mechanism in the hypertext system. For instance, if you want to see the text x in blue on your screen, and create a link from it to the page Dorsal fricatives, you specify the link as @@Dorsal fricatives|x@. Sound buttons If the recording time in the second line is not 0, three buttons will appear near the top of the page: 1. The Record button allows you to record a sound from the microphone. 2. The Play button allows you to play this recorded sound. In this way, you can compare your own utterances with the sounds behind the sound links, for example. 3. The Copy last played to list button copies the latest sound to the list of objects, allowing you to perform analyses on it, save it to disk, et cetera. The latest sound may be a sound that you recorded with the Record button, a sound that you played with the Play button, or a sound that you played by clicking on a sound link, whichever occurred most recently. And beyond If you need even more flexibility than ManPages offer you, consider using the Demo window instead. Links to this page What was new in 3.6? What was new in 3.9? What was new in 4.5? What was new in 4.6? 
Manual	Manual The documentation system for the Praat program. You will get a manual window every time you choose anything from a Help menu or press a Help button. How to find what you are looking for You can navigate the manual in several ways: To go to the Intro, use the Home button. To go to the information behind a link (a piece of blue text), just click on it. To go forward and backward through a tutorial with numbered pages, use 1 > and < 1. To revisit previous pages, use the < and > buttons. To browse alphabetically, use the horizontal scroll bar and the buttons named < 1 and 1 >, or the Search for page (list)... command in the Go to menu. To find a page with a known title, use the Search for page... command. The fastest way to find what you want is usually the Search button. Search In the text field after the Search button, you can type strings, separated by spaces. When you press the Return (or Enter) key, or click the Search button, all manual pages are searched for the combination of strings that you typed. The titles of the 20 best matching pages are displayed as links. Example: to know how to create a pitch contour from a sound, type sou pit and press Return. The best matches should appear on top. These should include Sound: To Pitch (ac)... and Sound: To Pitch (cc).... The search is case-insensitive. For instance, the search string script will give you all the pages that contain the words script, Script, description, PostScript, or SCRIPT, and so on. Background. The search algorithm uses the following heuristics: A match in the page title is better than one in the rest of the text. Pages with many matches are better than those with few. Your own manual pages To create your own manual pages, create ManPages text files. Links to this page File menu View 
Margins	Margins The space around most of your drawings in the Picture window. World coordinates With the commands in the Margins menu, you draw text, ticks, numbers, or a rectangle, in the margins around the latest drawing that you made, or you draw dotted lines through or text inside this last drawing. You specify the positions of these things in world coordinates, i.e., in coordinates that refer to the natural coordinate system of your last drawing. The numbers that you can mark around your drawing also refer to these coordinates. For instance, after drawing a spectrum with Spectrum: Draw..., you can draw a dotted line at 2000 Hz or at 60 dB by choosing One mark bottom... or One mark left... and typing 2000 or 60, respectively. Usage The margin commands work with all the drawings that leave margins around themselves, such as Sound: Draw..., Spectrogram: Paint..., Polygon: Paint..., and more. They do not work properly, however, with the commands that draw vocal tract shapes, like Art & Speaker: Draw... and Artword & Speaker: Draw..., because these can only be drawn correctly into a square viewport. Limited validity The margin commands work only on the latest drawing that you made (unless you Undo that drawing). Margin size The size of the margins depends on the font size, so be sure that you have the font size of your choice before you make your drawing. You can set the font size with the Font menu. Links to this page Draw inner box Formant: Draw tracks... Formant: Speckle... Logarithmic marks left/right/top/bottom... Marks left/right/top/bottom every... Marks left/right/top/bottom... Matrix: Draw as squares... One logarithmic mark left/right/top/bottom... One mark left/right/top/bottom... Pen menu Text left/right/top/bottom... Text... 
Markel___Gray__1976_	Markel & Gray (1976) J.D. Markel & A.H. Gray, Jr. (1976): Linear Prediction of Speech. Springer Verlag, Berlin. Links to this page LFCC: To LPC... LPC: To LFCC... Sound: To LPC (autocorrelation)... Sound: To LPC (covariance)... 
Marks_left_right_top_bottom___	Marks left/right/top/bottom... Four of the commands in the Margins menu of the Picture window. Purpose To draw any number of equally spaced marks into the margins around the drawing area. Settings Number of marks the number of equally spaced marks (2 or more) that will be drawn; there will always be marks at the beginning and end of the domain or range. Write numbers if on, real numbers will be written in the margin, expressed in the domain or range of your latest drawing in the horizontal or vertical direction. Draw ticks if on, short line pieces will be drawn in the margin. Draw dotted lines if on, dotted lines will be drawn through your drawing. Example If you draw a Sound with a domain between 0 and 1 seconds to an amplitude range between -1 and 1, choosing Marks left... with a number of 3 and Draw dotted lines on, will give you horizontal marks and horizontal dotted lines at -1, 0, and 1; choosing Marks bottom... with a number of 6 and Draw dotted lines off, will give you vertical marks at 0, 0.2, 0.4, 0.6, 0.8, and 1. 
Marks_left_right_top_bottom_every___	Marks left/right/top/bottom every... Four of the commands in the Margins menu of the Picture window. Purpose To draw a number of equally spaced marks into the margins around the drawing area. Settings Units the units, relative to the standard units, for writing the numbers; for example, if you want time in milliseconds instead of seconds (which is always the standard), Units should be 0.001. Distance the distance between the equally spaced marks that will be drawn, expressed in Units; for example, if you want marks every 20 milliseconds, and Units is 0.001, this argument should be 20. Write numbers if on, real numbers will be written in the margin, expressed in the domain or range of your latest drawing in the horizontal or vertical direction. Draw ticks if on, short line pieces will be drawn in the margin. Draw dotted lines if on, dotted lines will be drawn through your drawing. 
Marple__1980_	Marple (1980) L. Marple (1980): A new autoregressive spectrum analysis algorithm. IEEE Trans. on ASSP 28, 441–454. Links to this page Sound: To LPC (marple)... 
Matrix	Matrix One of the types of objects in Praat. A Matrix object represents a function z (x, y) on the domain [xmin, xmax] × [ymin, ymax]. The domain has been sampled in the x and y directions with constant sampling intervals (dx and dy) along each direction. The samples are thus z [iy] [ix], ix = 1 ... nx, iy = 1 ... ny. The samples represent the function values z (x1 + (ix - 1) dx, y1 + (iy - 1) dy). Matrix commands Creation: • Create Matrix... • Create simple Matrix... • Read from file... • Read Matrix from raw text file... • Read Matrix from LVS AP file... Drawing: • Matrix: Draw rows... • Matrix: Draw contours... • Matrix: Paint contours... • Matrix: Paint cells... • Matrix: Scatter plot... • Matrix: Draw as squares... • Matrix: Draw value distribution... • Matrix: Paint surface... Modification: • Matrix: Formula... • Matrix: Scale... Inside a Matrix object With Inspect, you will see the following attributes. xmin, xmax ≥ xmin x domain. nx ≥ 1 number of columns. dx > 0.0 distance between columns. x1 x value associated with first column. ymin, ymax ≥ ymin y domain. ny ≥ 1 number of rows. dy > 0.0 distance between rows. y1 y value associated with first row. z [1..ny] [1..nx] The sample values. After creation of the Matrix, xmin, xmax, ymin, ymax, nx, ny, dx, dy, x1, and y1 do not usually change. The contents of z do. Normally, you will want xmin ≤ x1 and xmax ≥ x1 + (nx - 1) dx. Example: simple matrix If a simple matrix has x equal to column number and y equal to row number, it has the following attributes: xmin = 1; xmax = nx; dx = 1; x1 = 1; ymin = 1; ymax = ny; dy = 1; y1 = 1; Example: sampled signal If the matrix represents a sampled signal of 1 second duration with a sampling frequency of 10 kHz, it has the following attributes: xmin = 0.0; xmax = 1.0; nx = 10000 ; dx = 1.0·10-4; x1 = 0.5·10-4; ymin = 1; ymax = 1; ny = 1; dy = 1; y1 = 1; Example: complex signal If the matrix represents a complex spectrum derived with an FFT from the sound of example 2, it has the following attributes: xmin = 0.0; xmax = 5000.0; nx = 8193 ; dx = 5000.0 / 8192; x1 = 0.0; ny = 2 (real and imaginary part); ymin = 1 (first row, real part); ymax = 2 (second row, imaginary part); dy = 1; y1 = 1; (so that y is equal to row number) Links to this page Activation BarkFilter CC: To Matrix Eigen & Matrix: Project... FFNet: Pattern FormantFilter Formulas 1.7. Formulas for creation Formulas 7. Attributes of objects GaussianMixture & PCA: To Matrix (density)... LPC: To Matrix Matrix: Draw distribution... Matrix: Paint cells... Matrix: Set value... Matrix: Solve equation... Matrix: To TableOfReal MelFilter Pattern 
Matrix__Draw_as_squares___	Matrix: Draw as squares... A command to draw a Matrix object into the Picture window. Settings Xmin Xmax the windowing domain in the x direction. Elements outside will not be drawn. Autowindowing: if (Xmin ≥ Xmax), the entire x domain [xmin, xmax] of the Matrix is used. Ymin Ymax the windowing domain in the y direction. Elements outside will not be drawn. Autowindowing: if (Ymin ≥ Ymax), the entire y domain [ymin, ymax] of the Matrix is used. Garnish determines whether axes are drawn around the picture. Turn this button off if you prefer to garnish your picture by yourself with the Margins menu. Behaviour For every element of the Matrix inside the specified windowing domain, an opaque white or black rectangle is painted (white if the value of the element is positive, black if it is negative), surrounded by a thin black box. The area of the rectangle is proportional to the value of the element. Trick If you prefer the sides of the rectangle (instead of the area) to be proportional to the value of the element, you can use the formula self^2 before drawing (see Matrix: Formula...). 
Matrix__Draw_distribution___	Matrix: Draw distribution... A command to draw the distribution histogram of the values in the selected part of a Matrix. Settings Horizontal range, Vertical range determine the part of the matrix whose distribution will be drawn. Minimum value, Maximum value determine the range of values that will be considered in the distribution. To treat all bin widths equally, the range will include the Minimum value and exclude the Maximum value (see below). Number of bins determines the number of bars in the distribution histogram. Minimum frequency, Maximum frequency determine the limits of the vertical axis. Algorithm For a particular matrix element z, the histogram bin number i that will be incremented obeys the following relation: lowerBinBorderi ≤ z < lowerBinBorderi+ binWidth, where binWidth = (maximumValue - minimumValue)/numberOfBins, and lowerBinBorderi = minimumValue + (i - 1)·binWidth. In this way all bins will be based on exactly the same width, as each binning interval includes its lower border and excludes its upper border (i.e., each interval is closed to the left and open to the right). 
Matrix__Formula___	Matrix: Formula... A command for changing the data in all selected Matrix objects. See the Formulas tutorial for examples and explanations. Links to this page Create Matrix... Create simple Matrix... Formant: Formula (bandwidths)... Formant: Formula (frequencies)... Formula... Matrix: Draw as squares... Sound Sound: Filter (formula)... TableOfReal: Select columns where row... 
Matrix__Paint_cells___	Matrix: Paint cells... A command to draw the contents of a Matrix to the Picture window. Every cell of the matrix is drawn as a rectangle filled with a grey value between white (if the content of the cell is small) and black (if the content is large). Links to this page Formulas 1.7. Formulas for creation 
Matrix__Set_value___	Matrix: Set value... A command to change the value of one cell in each selected Matrix object. Settings Row number the number of the row of the cell whose value you want to change. Column number the number of the column of the cell whose value you want to change. New value the value that you want the specified cell to have. 
Matrix__Solve_equation___	Matrix: Solve equation... Solve the general matrix equation A x = b for x. The matrix A can be any general m × n matrix, b is a m-dimensional and x a n-dimensional vector. The Matrix contains A as its first n columns and b as its last column. The n-dimensional solution is returned as a Matrix with n columns. When the number of equations (m) is greater than the number of unknowns (n) the algorithm gives the best least-squares solution. If on the contrary you have fewer equations than unknowns the solution will not be unique. Method Singular value decomposition with backsubstitution. Zero will be substituted for eigenvalues smaller than tolerance · maximum_eigenvalue (when the user-supplied tolerance equals 0.0 a value of 2.2 · 10-16 · number_of_unknowns will be used as tolerance). See for more details: Golub & van Loan (1996) chapters 2 and 3. 
Matrix__To_TableOfReal	Matrix: To TableOfReal A command to convert every selected Matrix to a TableOfReal. This command is available from the Cast menu. The resulting TableOfReal has the same number of rows and columns as the original Matrix, and the same data in the cells. However, it does not yet have any row or column labels; you can add those with some commands from the TableOfReal Modify menu. Links to this page What was new in 3.9? 
McCarthy___Prince__1995_	McCarthy & Prince (1995) John J. McCarthy & Alan Prince (1995): Faithfulness and reduplicative identity. In Jill Beckman, Laura Walsh Dickey & Suzanne Urbanczyk (eds.), Papers in Optimality Theory. University of Massachusetts Occasional Papers 18. Amherst, Mass.: Graduate Linguistic Student Association. pp. 249–384. [Rutgers Optimality Archive 60, http://roa.rutgers.edu] Links to this page OT learning 7. Learning from overt forms 
MDS_models	MDS models Multidimensional scaling (MDS) models are defined by specifying how given Dissimilarity data, δij, are mapped into distances of an m-dimensional MDS Configuration X. The mapping is specified by a representation function, f : δij → dij(X), which specifies how dissimilarities should be related to the distances. The MDS analysis tries to find the configuration (in a given dimensionality) whose distances satisfy f as closely as possible. This closeness is quantified by a badness-of-fit measure which is often called stress. Representation functions In the application of MDS we try to find a configuration X such that the following relations are satisfied as well as possible: f(δij) ≈ dij(X) The numbers that result from applying f on δij are sometimes called disparities d′ij. In most applications of MDS, besides the configuration X, also the function f is not completely specified, i.e., the exact parameters of f are unknown and must also be estimated during the analysis. If no particular f can be derived from a theoretical model, one often restricts f to a particular class of functions on the basis of the scale level of the dissimilarity data. If the disparities are related to the proximities by a specific parametric function we speak of metric MDS otherwise we speak of ordinal or non-metric MDS. absolute mds: d′ij = δij No parameters need to be estimated. ratio mds: d′ij = b · δij, where the value of b can be estimated by a linear regression of dij on δij. interval mds: d′ij = a + b · δij, where the values of a and b can be estimated by a linear regression of dij on δij. i-spline mds: d′ij = i-spline(δij), where i-spline(·) is a smooth monotonically increasing spline curve. The conceptual idea is that it is not possible to map all dissimilarities into disparities by one simple function. monotone mds: d′ij = monotone(δij), where monotone(·) is restricted to be a monotonic function that preserves the order of the dissimilarities: if δij < δkl, then dij(X) < dkl(X) If δij = δkl and no particular constraint is involved for dij(X) and dkl(X) this is referred to as the primary approach to ties. The secondary approach to ties requires that if δij = δkl, then also dij(X) = dkl(X). More information on all aspects of multidimensional scaling can be found in: Borg & Groenen (1997) and Ramsay (1988). The most important object types used in Praat for MDS and the conversions between these types are shown in the following figure. Kruskal analysis Multidimensional scaling 
Measurement_levels	Measurement levels According to the measurement theory of Stevens (1951), there are four measurement levels, namely Nominal, Ordinal, Interval and Ratio. In the light of multidimensional scaling, the first two levels, Nominal and Ordinal, are often called non-metric. The last two are metric. 
MelFilter	MelFilter One of the types of objects in PRAAT. An object of type MelFilter represents an acoustic time-frequency representation of a sound: the power spectral density P(f, t), expressed in dB's. It is sampled into a number of points around equally spaced times ti and frequencies fj (on a Mel frequency scale). The frequency in mels is: mels = 2595 * log10 (1 + hertz / 700), and its inverse is: hertz = 700 * (10.0mel / 2595.0 - 1). Inside a MelFilter With Inspect you will see that this type contains the same attributes a Matrix. Links to this page MelFilter: To MFCC... MFCC: To MelFilter... Sound: To MelFilter... What was new in 4.0? 
MelFilter__To_MFCC___	MelFilter: To MFCC... A command to create a MFCC object from each selected MelFilter object. Mel frequency cepstral coefficients result from the Discrete Cosine Transform of the filterbank spectrum (in dB). The following formula shows the relation: ck-1 = Σj=1N Pj cos (π(k-1)(j-0.5)/N)), where N represents the number of filters and Pj the power in dB in the jth filter (k runs from 1 to N). This transformation was first used by Davis & Mermelstein (1980). Links to this page Sound: To MFCC... 
MFCC	MFCC One of the types of objects in PRAAT. An object of type MFCC represents mel frequency cepstral coefficients as a function of time. The coefficients are represented in frames with constant sampling period. MFCC commands Creation: Sound: To MFCC... MelFilter: To MFCC... Links to this page CC: Get c0 value in frame... CC: To DTW... MFCC: To MelFilter... MFCC: To TableOfReal... What was new in 4.0? 
MFCC__To_MelFilter___	MFCC: To MelFilter... A command to reconstruct MelFilter objects from the selected MFCC objects . Settings From coefficient, To coefficient the range of coefficients that will be used in the reconstruction. Details The output of the triangular filters in a mel filter bank will be reconstructed by applying the inverse cosine transform: Pj = 2/N (c0/2 + Σk=1N-1 ck cos (πk(j-0.5)/N))), where N represents the number of filters, j runs from 1 to N, and coefficients ck with k less than fromCoefficient and k larger than toCoefficient take zero values in the evaluation. 
MFCC__To_TableOfReal___	MFCC: To TableOfReal... Convert the selected MFCC object to a TableOfReal object. Each MFCC frame results in one row in the TableOfReal. If the Include energy option is chosen, the zeroth MFCC coefficient will be saved in the first column. 
Modify	Modify The title of a submenu of the dynamic menu for many object types. This submenu usually collects all the commands that can change the selected object. Links to this page Formulas Formulas 1.8. Formulas for modification Formulas 8. Data in objects 
Morrison__1990_	Morrison (1990) D.F. Morrison (1990): Multivariate Statistical Methods. New York: McGraw-Hill. Links to this page Covariance: Difference Covariances: Report multivariate mean difference... PCA: Get equality of eigenvalues... 
Moulines___Charpentier__1990_	Moulines & Charpentier (1990) Eric Moulines & Francis Charpentier (1990): Pitch-synchronous waveform processing techniques for text-to-speech synthesis using diphones. Speech Communication 9: 453–467. Links to this page overlap-add 
MSpline	MSpline One of the types of objects in PRAAT. An object of type MSpline represents a linear combination of basis mspline functions. Each basis mspline is a positive polynomial function of degree p. MSpline (x) = Σk=1..numberOfCoefficients ck msplinek(x) Links to this page Create MSpline... 
Multidimensional_scaling	Multidimensional scaling This tutorial describes how you can use PRAAT to perform MultiDimensional Scaling (MDS) analysis. MDS helps us to represent dissimilarities between objects as distances in a Euclidean space. In effect, the more dissimilar two objects are, the larger the distance between the objects in the Euclidean space should be. The data types in PRAAT that incorporate these notions are Dissimilarity, Distance and Configuration. In essence, an MDS-analysis is performed when you select a Dissimilarity object and choose one of the To Configuration (xxx)... commands to obtain a Configuration object. In the above, method (xxx) represents on of the possible multidimensional scaling models. MDS-analysis Let us first create a Dissimilarity object. You can for example create a Dissimilarity object from a file. Here we will the use the Dissimilarity object from the letter R example. We have chosen the default value (32.5) for the (uniform) noise range. Note that this may result in substantial distortions between the dissimilarities and the distances. Now you can do the following, for example: Select the Dissimilarity and choose To Configuration (monotone mds)..., and you perform a kruskal-like multidimensional scaling which results in a new Configuration object. (This Configuration could subsequently be used as the starting Configuration for a new MDS-analysis!). Select the Configuration and choose Draw... and the following picture will result The following script summarizes: dissimilarity = Create letter R example: 32.5 configuration = To Configuration (monotone mds): 2, Primary approach, 0.00001, 50, 1 Draw: 1, 2, -0.8, 1.2, -0.8, 0.7, yes Obtaining the stress value Select the Dissimilarity and the Configuration together and query for the stress value with: Get stress (monotone mds).... The following script summarizes: selectObject (dissimilarity, configuration) Get stress (monotone mds): Primary approach, Kruskals's stress-1 The Shepard diagram Select the Dissimilarity and the Configuration together to draw the Shepard diagram. The following script summarizes: selectObject (dissimilarity, configuration) Draw Shepard diagram: 0, 200, 0, 2.2, 1, +, yes The (monotone) regression Select the Dissimilarity and the Configuration together to draw the monotone regression of distances on dissimilarities. The following script summarizes: selectObject (dissimilarity, configuration) Draw monotone regresion: Primary approach, 0, 200, 0, 2.2, 1, +, yes When you enter noiseRange = 0 in the form for the letter R, perfect reconstruction is possible. The Shepard diagram then will show a perfectly smooth monotonically increasing function. Weighing the dissimilarities When you can't have equal confidence in all the number in the Dissimilarity object, you can give different weights to these numbers by associating a Weight object with the Dissimilarity object. An easy way to do this is to select the Dissimilarity object and first choose To Weight. Then you might change the individual weights in the Weight object with the Set value... command (remember: make wij = wji). The following script summarizes: selectObject (dissimilarity) weight = To Weight ! Change [i][j] and [j][i] cells in the Weight object Set value: i, j, val Set value: j, i, val ... ! now we can do a weighed analysis. selectObject (dissimilarity, weight) To Configuration (monotone mds): 2, Primary approach, 0.00001, 50, 1) You can also query the stress values with three objects selected. The following script summarizes: selectObject (dissimilarity, weight, configuration) Get stress (monotone mds): Primary approach, Kruskals's stress-1 Using a start Configuration You could also use a Configuration object as a starting configuration in the minimization process. Lets assume that you are not satisfied with the stress value from the Configuration object that you obtained in the previous analysis. You can than use this Configuration object as a starting point for further analysis: The following script summarizes: selectObject (dissimilarity, configuration, weight) To Configuration (monotone mds): 2, Primary approach, 0.00001, 50, 1 Multiple Dissimilarity's (INDSCAL) When you have multiple Dissimilarity objects you can also perform individual difference scaling (often called INDSCAL analysis). As an example we can use an example taken from Carrol & Wish. Because INDSCAL only works on metrical data, we cannot use Dissimilarity objects directly. We have to transform them first to Distance objects. This type of analysis on multiple objects results in two new objects: a Configuration and a Salience. Links to this page Acknowledgments FeatureWeights Intro Pattern & FeatureWeights: To Dissimilarity... Pattern to Dissimilarity Pattern: To Dissimilarity... Statistics Types of objects What was new in 4.0? 
Nagarajan__Wang__Merzenich__Schreiner__Johnston__Jenkin	Nagarajan, Wang, Merzenich, Schreiner, Johnston, Jenkins, Miller & Tallal (1998) Srikantan S. Nagarajan, Xiaoqin Wang, Michael M. Merzenich, Christoph E. Schreiner, Paul Johnston, William M. Jenkins, Steven Miller & Paula Tallal (1998): Speech modifications algorithms used for training language learning-impaired children. IEEE Transactions on Rehabilitation Engineering 6(3): 257–268. Links to this page Sound: Deepen band modulation... 
New_menu	New menu The New menu is one of the menus in the Object window. You use this menu to create new objects from scratch. It contains the following commands: • Record mono Sound... • Record stereo Sound... • Create Sound from formula... • Create Sound from tone complex... • Create Sound from gammatone... • Create Sound from Shepard tone... • Create Matrix... (from a formula) • Create simple Matrix... (from a formula) • Create empty PointProcess... • Create Poisson process... • Create PitchTier... • Create DurationTier... • Create IntensityTier... • Create FormantGrid... • Create Strings as file list... • Create TextGrid... • OT learning tutorial • Create tongue-root grammar... To create new objects from files on disk, use the Open menu instead. Objects can also often be create from other objects, with commands that start with To. Links to this page Add to fixed menu... Articulatory synthesis Create Strings as directory list... Formulas Formulas 1.6. Formulas in settings windows Formulas 1.7. Formulas for creation Intro 1.1. Recording a sound Intro 1.3. Creating a sound from a formula Intro 7. Annotation Intro 8.3. Manipulation of intensity objects OT learning 2.1. Viewing a grammar OT learning 2.3. Defining your own grammar OT learning 2.6. Variable output OT learning 3.1. Data from a pair distribution OT learning 3.2. Data from another grammar OT learning 7. Learning from overt forms OTGrammar plug-ins ScriptEditor SoundRecorder 
New_Praat_script	New Praat script A command in the Praat menu for creating a new Praat script. It creates a ScriptEditor with an empty script that you can edit, run, and save. Links to this page Formulas 1.9. Formulas in scripts History mechanism Object window Open Praat script... Scripting 1. Your first scripts 
NIST_files	NIST files A way for storing a Sound object on disk. File format The compressed sound files of the Timit database, and the Groningen speech corpus. Reading With Read from file.... Saving With Save as NIST audio file.... 
Nocedal___Wright__1999_	Nocedal & Wright (1999) J. Nocedal & S.J. Wright (1999): Numerical optimization. Springer. Links to this page FFNet & Pattern & Categories: Learn... 
Nyquist_frequency	Nyquist frequency The Nyquist frequency is the bandwidth of a sampled signal, and is equal to half the sampling frequency of that signal. If the sampled signal should represent a continuous spectral range starting at 0 Hz (which is the most common case for speech recordings), the Nyquist frequency is the highest frequency that the sampled signal can unambiguously represent. Example If a speech signal is sampled at 22050 Hz, the highest frequency that we can expect to be present in the sampled signal is 11025 Hz. This means that to heed this expectation, we should run the continuous signal through a low-pass filter with a cut-off frequency below 11025 Hz; otherwise, we would experience the phenomenon of aliasing. Of course, with a sampling frequency of 22050 Hz we could also represent a signal band-limited between, say, 40000 Hz and 51025 Hz, but this seems less useful in speech research. Links to this page Create Sound from gammatone... Create Sound from tone complex... Formulas 7. Attributes of objects LPC: To Spectrogram... LPC: To Spectrum (slice)... Polynomial: To Spectrum... Sound: To LPC (autocorrelation)... Sound: To LPC (burg)... Sound: To LPC (covariance)... Sound: To LPC (marple)... Sound: To Spectrum... Source-filter synthesis 4. Using existing sounds Spectrum: Get centre of gravity... Spectrum: Get standard deviation... vector peak interpolation vector value interpolation 
Object_window	Object window One of the two main windows in the Praat program. Subdivision To the left: the List of Objects. To the right: the Dynamic menu. Fixed buttons The following buttons appear below the List of Objects: • Rename... • Info • Copy... • Remove • Inspect Menus The Object window contains several fixed menus: the Praat, New, Open, and Help menus. It also contains the Save menu, whose contents vary with the kinds of selected objects, and must, therefore, be considered part of the dynamic menu. The Praat menu • New Praat script: creates an empty ScriptEditor • Open Praat script...: creates a ScriptEditor with a script from disk • The Goodies submenu: for doing things (like using the Calculator) that do not create new objects and do not depend on the kinds of selected objects. • The Preferences submenu: for program-wide preferences, like audio input and output settings. • Buttons...: raises a ButtonEditor • (Add menu command...) • (Add action command...) • Quit Other menus • The New menu: for creating objects from scratch. • The Open menu: for reading objects from file into memory. • The Save menu: for writing objects from memory to file. • The Help menu: for viewing the manual. Links to this page Action commands Add to dynamic menu... Add to fixed menu... Calculator... Fixed menu commands Hidden commands Intro 1.1. Recording a sound Intro 2. What to do with a sound objects Praat menu Scripting 1. Your first scripts TextGridEditor 
objects	objects The things that contain the data in the Praat program. The objects are visible in the List of Objects in the Object window. Most objects are contained in memory: they are not files! Therefore, you may want to save them with one of the commands from the Save menu before you Quit. Exceptions are the LongSound objects in the Praat program and the file-based dictionaries in the ALS program. You can create an object by choosing a command from the New menu or from the Open menu. When you select one or more objects, you can perform on them the actions that are shown in the dynamic menu, on the fixed buttons below the list of objects, or in the Save menu. You can choose hidden actions with the help of the ButtonEditor. Links to this page Query Read from file... Remove Save as binary file... Save as short text file... Save as text file... View & Edit 
One_logarithmic_mark_left_right_top_bottom___	One logarithmic mark left/right/top/bottom... Four of the commands in the Margins menu of the Picture window. Purpose To draw one mark into one of the four margins around the drawing area, along a logarithmic axis. Settings Position the x (for top or bottom) or y (for left or right) position of the mark, expressed in the logarithmic domain or range of your latest drawing in the horizontal or vertical direction. Write number if on, a real number equal to Position will be written in the margin, at an x (for top or bottom) or y (for left or right) position equal to Position. Draw tick if on, a short line piece will be drawn in the margin, at an x (for top or bottom) or y (for left or right) position equal to Position. Draw dotted line if on, a dotted line will be drawn through your drawing, at an x (for top or bottom) or y (for left or right) position equal to Position. Draw text if not empty, this text will be drawn in the margin, at an x (for top or bottom) or y (for left or right) position equal to Position. Example After you draw a Pitch logarithmically in a range between 100 and 400 Hz, choosing One logarithmic mark left... with a position of 200 and Draw dotted line on, will give you a horizontal mark 200 and a horizontal dotted line at a y position of 200, which is exactly halfway between 100 and 400 Hz. 
One_mark_left_right_top_bottom___	One mark left/right/top/bottom... Four of the commands in the Margins menu of the Picture window. Purpose To draw one mark into one of the four margins around the drawing area. Settings Position the x (for top or bottom) or y (for left or right) position of the mark, expressed in the domain or range of your latest drawing in the horizontal or vertical direction. Write number if on, a real number equal to `Position' will be written in the margin, at an x (for top or bottom) or y (for left or right) position equal to Position. Draw tick if on, a short line piece will be drawn in the margin, at an x (for top or bottom) or y (for left or right) position equal to Position. Draw dotted line if on, a dotted line will be drawn through your drawing, at an x (for top or bottom) or y (for left or right) position equal to Position. Draw text if not empty, this text will be drawn in the margin, at an x (for top or bottom) or y (for left or right) position equal to Position. Example If you draw a Sound to an amplitude range between -1 and 1, choosing One mark left... with a position of 0.0 and Draw dotted line on, will give you a horizontal mark 0 and a horizontal dotted line at a y position of 0. 
Open_long_sound_file___	Open long sound file... A command in the Open menu that creates a LongSound object. The file will be opened for reading only. The file stays open until you remove the LongSound object. Links to this page How to concatenate sound files Intro 2.2. Viewing and editing a sound Keyboard shortcuts Sound files 3. Files that Praat can read SoundRecorder 
Open_menu	Open menu One of the menus in the Object window. With the Open menu, you read one or more objects from a file on disk into memory. The resulting object(s) will appear in the List of Objects. The Open menu contains the command Read from file..., which recognizes most file types, and perhaps several other commands for reading unrecognizable file types (e.g., raw sound data), or for interpreting known file types in a different way (e.g., reading two mono sounds from one stereo sound file): How to concatenate sound files Intro 1.2. Reading a sound from disk Intro 4.5. The Pitch object Intro 5.4. The Formant object LongSound New menu Open long sound file... Read separate channels from sound file... Save menu Sound files 3. Files that Praat can read 
Open_Praat_script___	Open Praat script... A command in the Praat menu for editing an existing Praat script. It creates a ScriptEditor and asks you to select a file. If you click OK, the file is read into the ScriptEditor window, and you can run and edit it; if you click Cancel, you get an empty script, as with New Praat script. Links to this page History mechanism Object window Scripting 1. Your first scripts 
Optimality_Theory	Optimality Theory A framework for transferring one linguistic representation into another, e.g. transferring an underlying form into a surface form. Before Prince & Smolensky (1993), phonologists tended to this with a sequentially ordered set of rules, each of which transferred a representation into another. With OT (that's the abbreviation), there are no intermediate steps in the derivation, but a set of ranked constraints chooses the optimal output form from a set of candidates. In Praat, you can draw Optimality-Theoretic tableaus and simulate Optimality-Theoretic learning. See the OT learning tutorial. Links to this page OT learning 1. Kinds of grammars 
OT	OT An abbreviation for Optimality Theory. Links to this page OT learning 1. Kinds of grammars 
OT_learning	OT learning This tutorial describes how you can draw Optimality-Theoretic and Harmonic-Grammar tableaus and simulate Optimality-Theoretic and Harmonic-Grammar learning with Praat. You can read this tutorial sequentially with the help of the < 1 and 1 > buttons. 1. Kinds of grammars (ordinal and stochastic, OTGrammar) 2. The grammar 2.1. Viewing a grammar (NOCODA example, OTGrammarEditor) 2.2. Inside the grammar (saving, inspecting) 2.3. Defining your own grammar 2.4. Evaluation (noise) 2.5. Editing a grammar 2.6. Variable output (place assimilation example) 2.7. Tableau pictures (printing, EPS) 2.8. Asking for one output 2.9. Output distributions 3. Generating language data 3.1. Data from a pair distribution 3.2. Data from another grammar (tongue-root-harmony example) 4. Learning an ordinal grammar 5. Learning a stochastic grammar 6. Shortcut to grammar learning 7. Learning from overt forms Links to this page Acknowledgments constraints Create tongue-root grammar... Intro New menu Optimality Theory Types of objects What was new in 3.6? 
OT_learning_1__Kinds_of_grammars	OT learning 1. Kinds of grammars This is chapter 1 of the OT learning tutorial. According to Prince & Smolensky (1993), an Optimality-Theoretic (OT) grammar consists of a number of ranked constraints. For every possible input (usually an underlying form), GEN (the generator) generates a (possibly very large) number of output candidates, and the ranking order of the constraints determines the winning candidate, which becomes the single optimal output. According to Prince & Smolensky (1993) and Smolensky & Legendre (2006), a Harmonic Grammar (HG) consists of a number of weighted constraints. The winning candidate, which becomes the single optimal output, is the one with the greatest harmony, which is a measure of goodness determined by the weights of the constraints violated by each candidate. In OT, ranking is strict, i.e., if a constraint A is ranked higher than the constraints B, C, and D, a candidate that violates only constraint A will always be beaten by any candidate that respects A (and any higher constraints), even if it violates B, C, and D. In HG, weighting is additive, i.e., a candidate that only violates a constraint A with a weight of 100 has a harmony of -100 and will therefore beat a candidate that violates both a constraint B with a weight of 70 and a constraint C with a weight of 40 and therefore has a harmony of only -110. Also, two violations of constraint B (harmony 2 * -70 = -140) are worse than one violation of constraint A (harmony -100). 1. Ordinal OT grammars Because only the ranking order of the constraints plays a role in evaluating the output candidates, Prince & Smolensky took an OT grammar to contain no absolute ranking values, i.e., they accepted only an ordinal relation between the constraint rankings. For such a grammar, Tesar & Smolensky (1998) devised an on-line learning algorithm (Error-Driven Constraint Demotion, EDCD) that changes the ranking order whenever the form produced by the learner is different from the adult form (a corrected version of the algorithm can be found in Boersma (2009b)). Such a learning step can sometimes lead to a large change in the behaviour of the grammar. 2. Stochastic OT grammars The EDCD algorithm is fast and convergent. As a model of language acquisition, however, its drawbacks are that it is extremely sensitive to errors in the learning data and that it does not show realistic gradual learning curves. For these reasons, Boersma (1997) proposed stochastic OT grammars in which every constraint has a ranking value along a continuous ranking scale, and a small amount of noise is added to this ranking value at evaluation time. The associated error-driven on-line learning algorithm (Gradual Learning Algorithm, GLA) effects small changes in the ranking values of the constraints with every learning step. An added virtue of the GLA is that it can learn languages with optionality and variation, which was something that EDCD could not do. For how this algorithm works on some traditional phonological problems, see Boersma & Hayes (2001). Ordinal OT grammars can be seen as a special case of the more general stochastic OT grammars: they have integer ranking values (strata) and zero evaluation noise. In Praat, therefore, every constraint is taken to have a ranking value, so that you can do stochastic as well as ordinal OT. 3. Categorical Harmonic Grammars Jäger (2003) and Soderstrom, Mathis & Smolensky (2006) devised an on-line learning algorithm for Harmonic Grammars (stochastic gradient ascent). As proven by Fischer (2005), this algorithm is guaranteed to converge upon a correct grammar, if there exists one that handles the data. 4. Stochastic Harmonic Grammars There are two kinds of stochastic models of HG, namely MaxEnt (= Maximum Entropy) grammars (Smolensky (1986), Jäger (2003)), in which the probablity of a candidate winning depends on its harmony, and Noisy HG (Boersma & Escudero (2008), Boersma & Pater (2008)), in which noise is added to constraint weights at evaluation time, as in Stochastic OT. The algorithm by Jäger (2003) and Soderstrom, Mathis & Smolensky (2006) can learn languages with optionality and variation (Boersma & Pater (2008)). The OTGrammar object An OT grammar is implemented as an OTGrammar object. In an OTGrammar object, you specify all the constraints, all the possible inputs and all their possible outputs. 
OT_learning_2_1__Viewing_a_grammar	OT learning 2.1. Viewing a grammar Consider a language where the underlying form /pat/ leads to the surface form [pa], presumably because the structural constraint NOCODA outranks the faithfulness constraint PARSE. To create such a grammar in Praat, choose Create NoCoda grammar from the Optimality Theory submenu of the New menu. An OTGrammar object will then appear in the list of objects. If you click View & Edit, an OTGrammarEditor will show up, containing: 1. the constraint list, sorted by disharmony (= ranking value + noise): ranking value disharmony plasticity NOCODA 100.000 100.000 1.000 PARSE 90.000 90.000 1.000 2. the tableaus for the two possible inputs /pat/ and /pa/: From the first tableau, we see that the underlying form /pat/ will surface as [pa], because the alternative [pat] violates a constraint (namely, NOCODA) with a higher disharmony than does [pa], which only violates PARSE, which has a lower disharmony. Note the standard OT tableau layout: asterisks (*) showing violations, exclamation marks (!) showing crucial violations, greying of cells that do not contribute to determining the winning candidate, and a finger (☞) pointing to the winner (this may look like a plus sign (+) if you don't have the Zapf Dingbats font installed on your computer or printer). An HG tableau contains asterisks and a pointing finger, but no exclamation marks or grey cells. The second tableau shows that /pa/ always surfaces as [pa], which is no wonder since this is the only candidate. All cells are grey because none of them contributes to the determination of the winner. Links to this page OT learning OT learning 2. The grammar 
OT_learning_2_2__Inside_the_grammar	OT learning 2.2. Inside the grammar You can save an OTGrammar grammar as a text file by choosing Save as text file... from the Save menu of the Objects window. For the NOCODA example, the contents of the file will look like: File type = ooTextFile Object class = OTGrammar 2 decisionStrategy = <OptimalityTheory> leak = 0 2 constraints constraint [1]: N\s{O}C\s{ODA} 100 100 1 ! NOCODA constraint [2]: P\s{ARSE} 90 90 1 ! PARSE 0 fixed rankings 2 tableaus input [1]: pat 2 candidate [1]: pa 0 1 candidate [2]: pat 1 0 input [2]: pa 1 candidate [1]: pa 0 0 To understand more about this data structure, consult the OTGrammar class description or click Inspect after selecting the OTGrammar object. The \s{...} braces ensure that the constraint names show up with their traditional small capitals (see Text styles). You can read this text file into Praat again with Read from file... from the Open menu in the Objects window. Links to this page OT learning OT learning 2. The grammar 
OT_learning_2_3__Defining_your_own_grammar	OT learning 2.3. Defining your own grammar By editing a text file created from an example in the New menu, you can define your own OT grammars. As explained at Save as text file..., Praat is quite resilient about its text file formats. As long as the strings and numbers appear in the correct order, you can redistribute the data across the lines, add all kinds of comments, or leave the comments out. For the NOCODA example, the text file could also have looked like: ooTextFile OTGrammar 2 <OptimalityTheory> 0.0 ! leak 2 ! number of constraints N\s{O}C\s{ODA} 100 100 1 P\s{ARSE} 90 90 1 0 ! number of fixed rankings 2 ! number of accepted inputs pat 2 ! input form with number of output candidates pa 0 1 ! first candidate with violations pat 1 0 ! second candidate with violations pa 1 ! input form with number of candidates pa 0 0 To define your own grammar, you just provide a number of constraints and their rankings, and all the possible input forms with all their output candidates, and all the constraint violations for each candidate. The order in which you specify the constraints is free (you don't have to specify the highest-ranked first), as long as the violations are in the same order; you could also have reversed the order of the two input forms, as long as the corresponding candidates follow them; and, you could also have reversed the order of the candidates within the /pat/ tableau, as long as the violations follow the output forms. Thus, you could just as well have written: ooTextFile OTGrammar 2 <OptimalityTheory> 0.0 2 P\s{ARSE} 90 90 1.0 N\s{O}C\s{ODA} 100 100 1.0 0 2 pa 1 pa 0 0 pat 2 pat 0 1 pa 1 0 The <OptimalityTheory> thing in the above refers to the decision strategy. In this tutorial I mostly assume OT's strict ranking, but you can experiment with Smolensky's <HarmonicGrammar> (where the constraint disharmonies represent addable, possibly negative weights), or with Frank Keller's <LinearOT> (like Harmonic Grammar, but with the restriction that negative disharmonies do not count), or with <PositiveHG> (like Harmonic Grammar, but with the restriction that disharmonies below 1.0 have weight 1.0), or with <ExponentialHG> (where the weights are exp(disharmony), somewhere between Harmonic Grammar and Linear OT), or with a <MaximumEntropy> grammar (where the probability that a candidate is chosen is proportional to exp(-disharmony)). The leak thing in the above refers to the amount to which constraint weights (especially in Harmonic Grammar) can leak while learning. Links to this page OT learning OT learning 2. The grammar 
OT_learning_2_4__Evaluation	OT learning 2.4. Evaluation In an Optimality-Theoretic model of grammar, evaluation refers to the determination of the winning candidate on the basis of the constraint ranking. In an ordinal OT model of grammar, repeated evaluations will yield the same winner again and again. We can simulate this behaviour with our NOCODA example. In the editor, you can choose Evaluate (zero noise) or use its keyboard shortcut Command-0 (= Command-zero). Repeated evaluations (keep Command-0 pressed) will always yield the following grammar: ranking value disharmony plasticity NOCODA 100.000 100.000 1.000 PARSE 90.000 90.000 1.000 In a stochastic OT model of grammar, repeated evaluations will yield different disharmonies each time. To see this, choose Evaluate (noise 2.0) or use its keyboard shortcut Command-2. Repeated evaluations will yield grammars like the following: ranking value disharmony plasticity NOCODA 100.000 100.427 1.000 PARSE 90.000 87.502 1.000 and ranking value disharmony plasticity NOCODA 100.000 101.041 1.000 PARSE 90.000 90.930 1.000 and ranking value disharmony plasticity NOCODA 100.000 96.398 1.000 PARSE 90.000 89.482 1.000 The disharmonies vary around the ranking values, according to a Gaussian distribution with a standard deviation of 2.0. The winner will still be [pa] in almost all cases, because the probability of bridging the gap between the two ranking values is very low, namely 0.02 per cent according to Boersma (1998), page 332. With a noise much higher than 2.0, the chances of PARSE outranking NOCODA will rise. To see this, choose Evaluate... and supply 5.0 for the noise. Typical outcomes are: ranking value disharmony plasticity NOCODA 100.000 92.634 1.000 PARSE 90.000 86.931 1.000 and ranking value disharmony plasticity NOCODA 100.000 101.162 1.000 PARSE 90.000 85.311 1.000 and ranking value disharmony plasticity PARSE 90.000 99.778 1.000 NOCODA 100.000 98.711 1.000 In the last case, the order of the constraints has been reversed. You will see that [pat] has become the winning candidate: However, in the remaining part of this tutorial, we will stick with a noise with a standard deviation of 2.0. This specific number ensures that we can model fairly rigid rankings by giving the constraints a ranking difference of 10, a nice round number. Also, the learning algorithm will separate many constraints in such a way that the differences between their ranking values are in the vicinity of 10. Links to this page OT learning OT learning 2. The grammar OTGrammar: Input to output... OTGrammar: Input to outputs... 
OT_learning_2_5__Editing_a_grammar	OT learning 2.5. Editing a grammar In the NOCODA example, the winning candidate for the input /pat/ was always [pa]. To make [pat] the winner instead, NOCODA should be ranked lower than PARSE. To achieve this even with zero noise, go to the editor and select the NOCODA constraint by clicking on it (a spade symbol ♠︎ will mark the selected constraint), and choose Edit ranking... from the Edit menu, or use the keyboard shortcut Command-E. In the resulting command window, we lower the ranking of the constraint from 100 to 80, and click OK. This is what you will see in the editor: ranking value disharmony plasticity ♠︎ NOCODA 80.000 103.429 1.000 PARSE 90.000 88.083 1.000 Nothing has happened to the tableau, because the disharmonies still have their old values. So choose Evaluate (noise 2.0) (Command-2) or Evaluate (zero noise) (Command-0). The new disharmonies will centre around the new ranking values, and we see that [pat] becomes the new winner: ranking value disharmony plasticity PARSE 90.000 90.743 1.000 NOCODA 80.000 81.581 1.000 OT learning OT learning 2. The grammar 
OT_learning_2_6__Variable_output	OT learning 2.6. Variable output Each time you press Command-2, which invokes the command Evaluate (noise 2.0) from the Edit menu, you will see the disharmonies changing. If the distance between the constraint rankings is 10, however, the winning candidates will very probably stay the same. So starting from the NOCODA example, we edit the rankings of the constraints again, setting the ranking value of PARSE to 88 and that of NOCODA to 85. If we now press Command-2 repeatedly, we will get [pat] in most of the cases, but we will see the finger pointing at [pa] in 14 percent of the cases: ranking value disharmony plasticity PARSE 88.000 87.421 1.000 NOCODA 85.000 85.585 1.000 but ranking value disharmony plasticity NOCODA 85.000 87.128 1.000 PARSE 88.000 85.076 1.000 As a more functionally oriented example, we consider nasal place assimilation. Suppose that the underlying sequence /an+pa/ surfaces as the assimilated [ampa] in 80 percent of the cases, and as the faithful [anpa] in the remaining 20 percent, while the non-nasal stop /t/ never assimilates. This can be achieved by having the articulatory constraint *GESTURE ranked at a short distance above *REPLACE (n, m): ooTextFile OTGrammar 2 decisionStrategy = <OptimalityTheory> leak = 0.0 3 constraints *G\s{ESTURE} 102.7 0 1 *R\s{EPLACE} (n, m) 100.0 0 1 *R\s{EPLACE} (t, p) 112.0 0 1 0 fixed rankings 2 tableaus an+pa 2 anpa 1 0 0 ampa 0 1 0 at+ma 2 atma 1 0 0 apma 0 0 1 You can create this grammar with Create place assimilation grammar from the New menu. In the editor, it will often look like follows: ranking value disharmony plasticity *REPLACE (t, p) 112.000 109.806 1.000 *GESTURE 102.700 102.742 1.000 *REPLACE (n, m) 100.000 101.044 1.000 If you keep the Command-2 keys pressed, however, you will see that the tableaus change into something like the following in approximately 20 percent of the cases: ranking value disharmony plasticity *REPLACE (t, p) 112.000 113.395 1.000 *REPLACE (n, m) 100.000 103.324 1.000 *GESTURE 102.700 101.722 1.000 We see that /at+ma/ always surfaces at [atma], because *REPLACE (t, p) is ranked much higher than the other two, and that the output of /an+pa/ is variable because of the close rankings of *GESTURE and *REPLACE (n, m). If you try this with a Harmonic Grammar or in Linear OT, you will see the same kind of variation. Although in HG, e.g. in Smolensky & Legendre (2006), the variation is usually obtained at the candidate level, namely by giving each candidate a probability proportional to exp(harmony/temperature), in our version of HG the variation comes about at the constraint level, namely by the noise that is temporarily added to the ranking of each constraint at evaluation time. Links to this page OT learning OT learning 2. The grammar OT learning 2.9. Output distributions OT learning 5. Learning a stochastic grammar 
OT_learning_2_7__Tableau_pictures	OT learning 2.7. Tableau pictures To show a tableau in the Picture window instead of in the editor, you select an OTGrammar object and click Draw tableau.... After you specify the input form, a tableau is drawn with the current font and size at the location of the current selection (viewport) in the Picture window. The top left corner of the tableau is aligned with the top left corner of the selection. You can draw more than one object into the Picture window, whose menus also allow you to add a lot of graphics of your own design. Besides printing the entire picture (with Print...), you can save a part of it to an EPS file for inclusion into your favourite word processor (with Save as EPS file...). For the latter to succeed, make sure that the selection includes at least your tableau; otherwise, some part of your tableau may end up truncated. Links to this page OT learning OT learning 2. The grammar 
OT_learning_2_8__Asking_for_one_output	OT learning 2.8. Asking for one output To ask the grammar to produce a single output for a specified input form, you can choose OTGrammar: Input to output.... The command window will ask you to provide an input form and the strength of the noise (the standard value is 2.0 again). This will perform an evaluation and write the result into the Info window. If you are viewing the grammar in the OTGrammarEditor, you will see the disharmonies change, and if the grammar allows variation, you will see that the winner in the tableau in the editor varies with the winner shown in the Info window. Since the editor shows more information than the Info window, this command is not very useful except for purposes of scripting. See the following page for some related but more useful commands. Links to this page OT learning OT learning 2. The grammar 
OT_learning_2_9__Output_distributions	OT learning 2.9. Output distributions To ask the grammar to produce many outputs for a specified input form, and collect them in a Strings object, you select an OTGrammar and choose Input to outputs.... For example, select the object OTGrammar assimilation from our place assimilation example (§2.6), and click Input to outputs.... In the resulting command window, you specify 1000 trials, a noise strength of 2.0, and an+pa for the input form. After you click OK, a Strings object will appear in the list. If you click Info, you will see that it contains 1000 strings. If you click Inspect, you will see that most of the strings are ampa, but some of them are anpa. These are the output forms computed from 1000 evaluations for the input /an+pa/. To count how many instances of [ampa] and [anpa] were generated, you select the Strings object and click To Distributions. You will see a new Distributions object appear in the list. If you draw this to the Picture window (with Draw as numbers...), you will see something like: ampa815 anpa185 which means that our grammar, when fed with 1000 /an+pa/ inputs, produced [ampa] 815 times, and [anpa] 185 times, which is consistent with our initial guess that a ranking difference of 2.7 would cause approximately an 80% - 20% distribution of [ampa] and [anpa]. Checking the distribution hypothesis To see whether the guess of a 2.7 ranking difference is correct, we perform 1,000,000 trials instead of 1000. The output distribution (if you have enough memory in your computer) becomes something like (set the Precision to 7 in the Draw command window): ampa830080 anpa169920 The expected values under the 80% - 20% distribution hypothesis are: ampa800000 anpa200000 We compute (e.g. with Calculator...) a χ2 of 300802/800000 + 300802/200000 = 5655.04, which, of course, is much too high for a distribution with a single degree of freedom. So the ranking difference must be smaller. If it is 2.4 (change the ranking of *GESTURE to 102.4), the numbers become something like ampa801974 anpa198026 which gives a χ2 of 24.35. By using the Calculator with the formula chiSquareQ (24.35, 1), we find that values larger than this have a probability of 8·10-7 under the 80% - 20% distribution hypothesis, which must therefore be rejected again. Rather than continuing this iterative procedure to find the correct ranking values for an 80% - 20% grammar, we will use the Gradual Learning Algorithm (§5) to determine the rankings automatically, without any memory of past events other than the memory associated with maintaining the ranking values. Measuring all inputs To measure the outcomes of all the possible inputs at once, you select an OTGrammar and choose To output Distributions.... As an example, try this on our place assimilation grammar. You can supply 1000000 for the number of trials, and the usual 2.0 for the standard deviation of the noise. After you click OK, a Distributions object will appear in the list. If you draw this to the Picture window, the result will look like: /an+pa/ → anpa169855 /an+pa/ → ampa830145 /at+ma/ → atma999492 /at+ma/ → apma508 We see that the number of [apma] outputs is not zero. This is due to the difference of 9.3 between the rankings of *REPLACE (t, p) and *GESTURE. If you rank *REPLACE (t, p) at 116.0, the number of produced [apma] reduces to about one in a million, as you can easily check with some patience. Links to this page OT learning OT learning 2. The grammar 
OT_learning_2__The_grammar	OT learning 2. The grammar This is chapter 2 of the OT learning tutorial. We can ask the grammar to produce an output form for any input form that is in its list of tableaus. 2.1. Viewing a grammar (NOCODA example, OTGrammarEditor) 2.2. Inside the grammar (saving, inspecting) 2.3. Defining your own grammar 2.4. Evaluation (noise) 2.5. Editing a grammar 2.6. Variable output (place assimilation example) 2.7. Tableau pictures (printing, EPS files) 2.8. Asking for one output 2.9. Output distributions Links to this page OT learning 3. Generating language data 
OT_learning_3_1__Data_from_a_pair_distribution	OT learning 3.1. Data from a pair distribution If the grammar contains faithfulness constraints, the learner needs pairs of underlying and adult surface forms. For our place assimilation example, she needs a lot of /at+ma/ - [atma] pairs, and four times as many /an+pa/ - [ampa] pairs as /an+pa/ - [anpa] pairs. We can specify this language-data distribution in a PairDistribution object, which we could simply save as a text file: ooTextFile PairDistribution 4 pairs at+ma atma 100 at+ma apma 0 an+pa anpa 20 an+pa ampa 80 The values appear to represent percentages, but they could also have been 1.0, 0.0, 0.2, and 0.8, or any other values with the same proportions. We could also have left out the second pair and specified 3 pairs instead of 4 pairs in the third line. We can create this pair distribution with Create place assimilation distribution from the Optimality Theory submenu of the New menu in the Objects window. To see that it really contains the above data, you can draw it to the Picture window. To change the values, use Inspect (in which case you should remember to click Change after any change). To generate input-output pairs from the above distribution, select the PairDistribution and click To Stringses.... If you then just click OK, there will appear two Strings objects in the list, called input (underlying forms) and output (surface forms). Both contain 1000 strings. If you Inspect them both, you can see that e.g. the 377th string in input corresponds to the 377th string in output, i.e., the two series of strings are aligned. See also the example at PairDistribution: To Stringses.... These two Strings objects are sufficient to help an OTGrammar grammar to change its constraint rankings in such a way that the output distributions generated by the grammar match the output distributions in the language data. See §5. Links to this page OT learning OT learning 3. Generating language data 
OT_learning_3_2__Data_from_another_grammar	OT learning 3.2. Data from another grammar Instead of generating input-output pairs directly from a PairDistribution object, you can also generate input forms and their winning outputs from an OTGrammar grammar. Of course, that's what the language data presented to real children comes from. Our example will be a tongue-root harmony grammar. Choose Create tongue-root grammar... from the Optimality Theory submenu of the New menu. Set Constraint set to Five, and Ranking to Wolof. Click OK. An object called OTGrammar Wolof will appear in the list. Click View & Edit. You will see the following grammar appear in the OTGrammarEditor: ranking value disharmony plasticity *[rtr / hi] 100.000 100.000 1.000 PARSE (rtr) 50.000 50.000 1.000 *GESTURE (contour) 30.000 30.000 1.000 PARSE (atr) 20.000 20.000 1.000 *[atr / lo] 10.000 10.000 1.000 This simplified Wolof grammar, with five constraints with clearly different rankings, is equivalent to the traditional OT ranking *[rtr / hi] >> PARSE (rtr) >> *GESTURE (contour) >> PARSE (atr) >> *[atr / lo] These constraints are based on a description of Wolof by Archangeli & Pulleyblank (1994: 225–239). For the meaning of these constraints, see Boersma (1998: 295), or the Create tongue-root grammar... manual page. For each input, there are four output candidates: the vowel heights will be the same as those in the input, but the tongue-root values of V1 and V2 are varied. For example, for the input [ita] we will have the four candidates [ita], [itə], [ɪta], and [ɪtə]. With this way of generating candidates, we see that the five constraints are completely ranked. First, the absolute prohibition on surface [ɪ] shows that *[rtr / hi] outranks RTR faithfulness (otherwise, [ɪtɪ] would have been the winner): Second, the faithful surfacing of the disharmonic /itɛ/ shows that RTR faithfulness must outrank the harmony (anti-contour) constraint (otherwise, [ite] would have been the winner): Third, the RTR-dominant harmonicization of underlying disharmonic /etɛ/ shows that harmony must outrank ATR faithfulness (otherwise, [etɛ] would have won): Finally, the faithful surfacing of the low ATR vowel /ə/ even if not forced by harmony, shows that ATR faithfulness outranks *[atr / lo] (otherwise, [ata] would have been the winning candidate): These four ranking arguments clearly establish the crucial rankings of all five constraints. Generating inputs from the grammar According to Prince & Smolensky (1993), the input to an OT grammar can be anything. This is the idea of richness of the base. When doing a practical investigation, however, we are only interested in the inputs that will illustrate the properties of our partial grammars. In the case of simplified Wolof, this means the 36 possible V1tV2 sequences where V1 and V2 are any of the six front vowels i, ɪ, e, ɛ, ə, and a (see Create tongue-root grammar...). A set of inputs can be generated from an OTGrammar object by inspecting the list of tableaus. So select the Wolof tongue-root grammar and choose Generate inputs.... Set Number of trials to 100, and click OK. A Strings object named Wolof_in will appear in the list. Click Inspect and examine the 100 input strings. You will see that they have been randomly chosen from the 36 possible V1tV2 sequences as described at Create tongue-root grammar...: ɛta, etɛ, ɛti, itɛ, ɛtɛ, iti, ɛtɪ, itɪ, ɪti, etɛ, ... Thus, when asked to generate a random input, these grammars produce any of the 36 possible V1tV2 sequences, all with equal probability. Generating outputs from the grammar To compute the outputs for the above set of input forms, select both the OTGrammar object and the input Strings object, and choose Inputs to outputs..., perhaps specifying zero evaluation noise. A new Strings objects called Wolof_out will appear in the list. If you Inspect it, you will see that it contains a string sequence aligned with the original input strings: ɛta, ɛtɛ, ɛti, itɛ, ɛtɛ, iti, ɛti, iti, iti, ɛtɛ, ... In this way, we have created two Strings objects, which together form a series of input-output pairs needed for learning a grammar that contains faithfulness constraints. Links to this page OT learning OT learning 3. Generating language data OT learning 4. Learning an ordinal grammar 
OT_learning_3__Generating_language_data	OT learning 3. Generating language data A learner needs two things: a grammar that she can adjust (\SS2), and language data. 3.1. Data from a pair distribution 3.2. Data from another grammar (tongue-root-harmony example) Links to this page OT learning 
OT_learning_4__Learning_an_ordinal_grammar	OT learning 4. Learning an ordinal grammar With the data from a tongue-root-harmony language with five completely ranked constraints, we can have a throw at learning this language, starting with a grammar in which all the constraints are ranked at the same height, or randomly ranked, or with articulatory constraints outranking faithfulness constraints. Let's try the third of these. Create an infant tongue-root grammar by choosing Create tongue-root grammar... and specifying Five for the constraint set and Infant for the ranking. The result after a single evaluation will be like: ranking value disharmony plasticity *GESTURE (contour) 100.000 100.631 1.000 *[atr / lo] 100.000 100.244 1.000 *[rtr / hi] 100.000 97.086 1.000 PARSE (rtr) 50.000 51.736 1.000 PARSE (atr) 50.000 46.959 1.000 Such a grammar produces all kinds of non-adult results. For instance, the input /ətɪ/ will surface as [atɪ]: The adult form is very different: [əti]. The cause of the discrepancy is in the order of the constraints *[atr / lo] and *[rtr / hi], which militate against [ə] and [ɪ], respectively. Simply reversing the rankings of these two constraints would solve the problem in this case. More generally, Tesar & Smolensky (1998) claim that demoting all the constraints that cause the adult form to lose into the stratum just below the highest-ranked constraint violated in the learner's form (here, moving *[atr / lo] just below *[rtr / hi] into the same stratum as PARSE (rtr)), will guarantee convergence to the target grammar, if there is no variation in the data (Tesar & Smolensky's algorithm is actually incorrect, but can be repaired easily, as shown by Boersma (2009b)). But Tesar & Smolensky's algorithm cannot be used for variable data, since all constraints would be tumbling down, exchanging places and producing wildly different grammars at each learning step. Since language data do tend to be variable, we need a gradual and balanced learning algorithm, and the following algorithm is guaranteed to converge to the target language, if that language can be described by a stochastic OT grammar. The reaction of the learner to hearing the mismatch between the adult [əti] and her own [atɪ], is simply: 1. to move the constraints violated in her own form, i.e. *[rtr / hi] and PARSE (atr), up by a small step along the ranking scale, thus decreasing the probability that her form will be the winner at the next evaluation of the same input; 2. and to move the constraints violated in the adult form, namely *[atr / lo] and PARSE (rtr), down along the ranking scale, thus increasing the probability that the adult form will be the learner's winner the next time. If the small reranking step (the plasticity) is 0.1, the grammar will become: ranking value disharmony plasticity *GESTURE (contour) 100.000 100.631 1.000 *[atr / lo] 99.900 100.244 1.000 *[rtr / hi] 100.100 97.086 1.000 PARSE (rtr) 49.900 51.736 1.000 PARSE (atr) 50.100 46.959 1.000 The disharmonies, of course, will be different at the next evaluation, with a probability slightly higher than 50% that *[rtr / hi] will outrank *[atr / lo]. Thus the relative rankings of these two grounding constraints have moved into the direction of the adult grammar, in which they are ranked at opposite ends of the grammar. Note that the relative rankings of PARSE (atr) and PARSE (rtr) are now moving in a direction opposite to where they will have to end up in this RTR-dominant language. This does not matter: the procedure will converge nevertheless. We are now going to simulate the infant who learns simplified Wolof. Take an adult Wolof grammar and generate 1000 input strings and the corresponding 1000 output strings following the procedure described in §3.2. Now select the infant OTGrammar and both Strings objects, and choose Learn.... After you click OK, the learner processes each of the 1000 input-output pairs in succession, gradually changing the constraint ranking in case of a mismatch. The resulting grammar may look like: ranking value disharmony plasticity *[rtr / hi] 100.800 98.644 1.000 *GESTURE (contour) 89.728 94.774 1.000 *[atr / lo] 89.544 86.442 1.000 PARSE (rtr) 66.123 65.010 1.000 PARSE (atr) 63.553 64.622 1.000 We already see some features of the target grammar, namely the top ranking of *[rtr / hi] and RTR dominance (the mutual ranking of the PARSE constraints). The steps have not been exactly 0.1, because we also specified a relative plasticity spreading of 0.1, thus giving steps typically in the range of 0.7 to 1.3. The step is also multiplied by the constraint plasticity, which is simply 1.000 in all examples in this tutorial; you could set it to 0.0 to prevent a constraint from moving up or down at all. The leak is the part of the constraint weight (especially in Harmonic Grammar) that is thrown away whenever a constraint is reranked; e.g if the leak is 0.01 and the step is 0.11, the constraint weight is multiplied by (1 – 0.01·0.11) = 0.9989 before the learning step is taken; in this way you could implement forgetful learning of correlations. After learning once more with the same data, the result is: ranking value disharmony plasticity *[rtr / hi] 100.800 104.320 1.000 PARSE (rtr) 81.429 82.684 1.000 *[atr / lo] 79.966 78.764 1.000 *GESTURE (contour) 81.316 78.166 1.000 PARSE (atr) 77.991 77.875 1.000 This grammar now sometimes produces faithful disharmonic utterances, because the PARSE now often outrank the gestural constraints at evaluation time. But there is still a lot of variation produced. Learning once more with the same data gives: ranking value disharmony plasticity *[rtr / hi] 100.800 100.835 1.000 PARSE (rtr) 86.392 82.937 1.000 *GESTURE (contour) 81.855 81.018 1.000 *[atr / lo] 78.447 78.457 1.000 PARSE (atr) 79.409 76.853 1.000 By inspecting the first column, you can see that the ranking values are already in the same order as in the target grammar, so that the learner will produce 100 percent correct adult utterances if her evaluation noise is zero. However, with a noise of 2.0, there will still be variation. For instance, the disharmonies above will produce [ata] instead of [ətə] for underlying /ətə/. Learning seven times more with the same data gives a reasonable proficiency: ranking value disharmony plasticity *[rtr / hi] 100.800 99.167 1.000 PARSE (rtr) 91.580 93.388 1.000 *GESTURE (contour) 85.487 86.925 1.000 PARSE (atr) 80.369 78.290 1.000 *[atr / lo] 75.407 74.594 1.000 No input forms have error rates above 4 percent now, so the child has learned a lot with only 10,000 data, which may be on the order of the number of input data she receives every day. We could have sped up the learning process appreciably by using a plasticity of 1.0 instead of 0.1. This would have given a comparable grammar after only 1000 data. After 10,000 data, we would have ranking value disharmony plasticity *[rtr / hi] 107.013 104.362 1.000 PARSE (rtr) 97.924 99.984 1.000 *GESTURE (contour) 89.679 89.473 1.000 PARSE (atr) 81.479 83.510 1.000 *[atr / lo] 73.067 72.633 1.000 With this grammar, all the error rates are below 0.2 percent. We see that crucially ranked constraints will become separated after a while by a gap of about 10 along the ranking scale. If we have three constraints obligatorily ranked as A >> B >> C in the adult grammar, with ranking differences of 8 between A and B and between B and C in the learner's grammar (giving an error rate of 0.2%), the ranking A >> C has a chance of less than 1 in 100 million to be reversed at evaluation time. This relativity of error rates is an empirical prediction of our stochastic OT grammar model. Our Harmonic Grammars with constraint noise (Noisy HG) are slightly different in that respect, but are capable of learning a constraint ranking for any language that can be generated from an ordinal ranking. As proved by Boersma & Pater (2008), the same learning rule as was devised for MaxEnt grammars by Jäger (2003) is able to learn all languages generated by nonnoisy HG grammars as well; the GLA, by contrast, failed to converge on 0.4 percent of randomly generated OT languages (failures of the GLA on ordinal grammars were discovered first by Pater (2008)). This learning rule for HG and MaxEnt is the same as the GLA described above, except that the learning step of each constraint is multiplied by the difference of the number of violations of this constraint between the correct form and the incorrect winner; this multiplication is crucial (without it, stochastic gradient ascent is not guaranteed to converge), as was noted by Jäger for MaxEnt. The same procedure for updating weights occurs in Soderstrom, Mathis & Smolensky (2006), who propose an incremental version (formulas 21 and 35d) of the harmony version (formulas 14 and 18) of the learning equation for Boltzmann machines (formula 13). The differences between the three implementations is that in Stochastic OT and Noisy HG the evaluation noise (or temperature) is in the constraint rankings, in MaxEnt it is in the candidate probabilities, and in Boltzmann machines it is in the activities (i.e. the constraint violations). The upate procedure is also similar to that of the perceptron, a neural network invented by Rosenblatt (1962) for classifying continuous inputs. Links to this page OT learning OTGrammar: Learn one... 
OT_learning_5__Learning_a_stochastic_grammar	OT learning 5. Learning a stochastic grammar Having shown that the algorithm can learn deep obligatory rankings, we will now see that it also performs well in replicating the variation in the language environment. Create a place assimilation grammar as described in §2.6, and set all its rankings to 100.000: ranking value disharmony plasticity *GESTURE 100.000 100.000 1.000 *REPLACE (t, p) 100.000 100.000 1.000 *REPLACE (n, m) 100.000 100.000 1.000 Create a place assimilation distribution and generate 1000 string pairs (§3.1). Select the grammar and the two Strings objects, and learn with a plasticity of 0.1: ranking value disharmony plasticity *REPLACE (t, p) 104.540 103.140 1.000 *REPLACE (n, m) 96.214 99.321 1.000 *GESTURE 99.246 97.861 The output distributions are now (using OTGrammar: To output Distributions..., see §2.9): /an+pa/ → anpa14.3% /an+pa/ → ampa85.7% /at+ma/ → atma96.9% /at+ma/ → apma3.1% After another 10,000 new string pairs, we have: ranking value disharmony plasticity *REPLACE (t, p) 106.764 107.154 1.000 *GESTURE 97.899 97.161 1.000 *REPLACE (n, m) 95.337 96.848 1.000 With the following output distributions (measured with a million draws): /an+pa/ → anpa18.31% /an+pa/ → ampa81.69% /at+ma/ → atma99.91% /at+ma/ → apma0.09% The error rate is acceptably low, but the accuracy in reproducing the 80% - 20% distribution could be better. This is because the relatively high plasticity of 0.1 can only give a coarse approximation. So we lower the plasticity to 0.001, and supply 100,000 new data: ranking value disharmony plasticity *REPLACE (t, p) 106.810 107.184 1.000 *GESTURE 97.782 99.682 1.000 *REPLACE (n, m) 95.407 98.760 1.000 With the following output distributions: /an+pa/ → anpa20.08% /an+pa/ → ampa79.92% /at+ma/ → atma99.94% /at+ma/ → apma0.06% So besides learning obligatory rankings like a child does, the algorithm can also replicate very well the probabilities of the environment. This means that a GLA learner can learn stochastic grammars. Links to this page OT learning OTGrammar & 2 Strings: Learn... OTGrammar: Learn one... 
OT_learning_6__Shortcut_to_grammar_learning	OT learning 6. Shortcut to grammar learning Once you have mastered the tedious procedures of making Praat learn stochastic grammars, as described in the previous chapters of this tutorial, you can try a faster procedure, which simply involves selecting an OTGrammar object together with a PairDistribution object, and clicking Learn.... Once you click OK, Praat will feed the selected grammar with input/output pairs drawn from the selected distribution, and the grammar will be modified every time its output is different from the given output. Here is the meaning of the arguments: Evaluation noise (standard value: 2.0) the standard deviation of the noise added to the ranking of each constraint at evaluation time. Strategy (standard value: Symmetric all) what to do when the learner's output is different from the given output. Possibilities: Demotion only: lower the ranking of every constraint that is violated more in the correct output than in the learner's output. This algorithm crashes if there is variation in the data, i.e. if some inputs can have more than one possible adult outputs. Symmetric one: lower the ranking of the highest-ranked constraint that is violated more in the adult output than in the learner's output, and raise the ranking of the highest-ranked constraint that is violated more in the learner's output than in the adult output. This is the minimal algorithm described and refuted in Boersma (1998), chapters 14-15. Symmetric all: lower the ranking of all constraints that are violated more in the adult output than in the learner's output, and raise the ranking of all constraints that are violated more in the learner's output than in the adult output. This is the algorithm described in Boersma & Hayes (2001). Weighted uncancelled: the same as Symmetric all, but the size of the learning step is divided by the number of moving constraints. This makes sure that the average ranking of all the constraints is constant. Weighted all: the Symmetric all strategy can reworded as follows: lower the ranking of all constraints that are violated in the adult output, and raise the ranking of all constraints that are violated in the learner's output. Do that, but divide the size of the learning step by the number of moving constraints. EDCD: Error-Driven Constraint Demotion, the algorithm described by Tesar & Smolensky (1998). All constraints that prefer the adult form and are ranked above the highest-ranked constraint that prefers the learner's form, are demoted to the ranking of that last constraint minus 1.0. Initial plasticity (standard value: 1.0) Replications per plasticity (standard value: 100000) Plasticity decrement (standard value: 0.1) Number of plasticities (standard value: 4) these four arguments determine the learning scheme, i.e. the number of times the grammar will receive data at a certain plasticity. With the standard values, there will be 100000 data while the plasticity is 1.0 (the initial plasticity), 100000 data while the plasticity is 0.1, 100000 data while the plasticity is 0.01, and 100000 data while the plasticity is 0.001. If you want learning at a constant plasticity, set the number of plasticities to 1. Note that for the decision strategies of HarmonicGrammar, LinearOT, PositiveHG or MaximumEntropy the learning step for a constraint equals the plasticity multiplied by the difference between the numbers of violations of this constraint in the adult output and in the learner's output. Rel. plasticity spreading (standard value: 0.1) if this is not 0, the size of the learning step will vary randomly. For instance, if the plasticity is set to 0.01, and the relative plasticity spreading is 0.1, you will get actual learning steps that could be anywhere between 0.007 and 0.013, according to a Gaussian distribution with mean 0.01 and standard deviation 0.001. Honour local rankings (standard value: on) if this is on, the fixed rankings that you supplied in the grammar will be maintained during learning: if a constraint falls below a constraint that is supposed to be universally lower-ranked, this second constraint will be demoted as well. Number of chews (standard value: 1) the number of times that each input-output pair is fed to the grammar. Setting this number to 20 will give a slightly different (perhaps more accurate) result than simply raising the plasticity by a factor of 20. Links to this page OT learning 
OT_learning_7__Learning_from_overt_forms	OT learning 7. Learning from overt forms In order to be able to learn phonological production, both EDCD and GLA require pairs of underlying form and surface form. However, the language-learning child hears neither of these forms: she only hears overt forms, with less structural information than the underlying and surface forms contain. Interpretive parsing The language-learning child has to construct both the surface form and the underlying form from the overt form that she hears. Tesar & Smolensky (1998) proposed that the child computes a surface form from the overt form by using the same constraint ranking as in production. For instance, the overt form [σ σ σ], which is a sequence of three syllables with stress on the second syllable, will be interpreted as the surface form /(σ σˈ) σ/ in iambic left-aligning languages (IAMBIC >> TROCHAIC, and ALLFEETLEFT >> ALLFEETRIGHT), but as the surface form /σ (σˈ σ)/ in trochaic right-aligning languages. Tesar & Smolensky call this procedure Robust Interpretive Parsing, because it works even if the listener's grammar would never produce such a form. For instance, if IAMBIC >> ALLFEETRIGHT >> TROCHAIC >> ALLFEETLEFT, the listener herself would produce the iambic right-aligned /σ (σ σˈ)/ for any trisyllabic underlying form, though she will still interpret [σ σˈ σ] as /(σ σˈ) σ/, which is illegal in her own grammar. Hearing forms that are illegal in one's own grammar is of course a common situation for language-learning children. In Tesar & Smolensky's view, the underlying form can be trivially computed from the surface form, since the surface form contains enough information. For instance, the surface form /(σ σˈ) σ/ must lead to the underlying form |σ σ σ| if all parentheses and stress marks are removed. Since McCarthy & Prince (1995), this containment view of surface representations has been abandoned. In Praat, therefore, the underlying form is not trivially computed from the surface form, but all the tableaus are scanned for the surface form that violates the least high-ranked constraints (in the usual OT sense), as long as it contains the given overt form. For instance, if IAMBIC >> ALLFEETRIGHT >> TROCHAIC >> ALLFEETLEFT, the overt form [σ σˈ σ] occurs in two candidates: the surface form /(σ σˈ) σ/ in the tableau for the underlying form |σ σ σ|, and the surface form /σ (σˈ σ)/ in the tableau for the underlying form |σ σ σ|. The best candidate is the surface form /(σ σˈ) σ/ in the tableau for the underlying form |σ σ σ|. Hence, Praat's version of Robust Interpretive Parsing will map the overt form [σ σˈ σ] to the underlying form |σ σ σ| (the ‘winning tableau’) and to the surface form /(σ σˈ) σ/ (to be sure, this is the same result as in Tesar & Smolensky's version, but crucial differences between the two versions will appear when faithfulness constraints are involved). In Praat, you can do interpretive parsing. For example, create a grammar with Create metrics grammar... from the New menu. Then choose Get interpretive parse... from the Query submenu and supply [L1 L L] for the overt form, which means a sequence of three light syllables with a main stress on the first. The Info window will show you the optimal underlying and surface forms, given the current constraint ranking. Learning from partial forms Now that the learning child can convert an overt form to an underlying-surface pair, she can compare this surface form to the surface form that she herself would have derived from this underlying form. For instance, If IAMBIC >> ALLFEETRIGHT >> TROCHAIC >> ALLFEETLEFT, the winning tableau is |σ σ σ|, and the perceived adult surface form is /(σ σˈ) σ/. But from the underlying form |σ σ σ|, the learner will derive /σ (σ σˈ)/ as her own surface form. The two surface forms are different, so that the learner can take action by reranking one or more constraints, perhaps with EDCD or GLA. In Praat, you can learn from partial forms. Select the metrics grammar and choose Learn from one partial output..., and supply [L1 L L]. If you do this several times, you will see that the winner for the tableau |L L L| will become one of the two forms with overt part [L1 L L]. To run a whole simulation, you supply a Distributions object with one column, perhaps from a text file. The following text file shows the overt forms for Latin, with the bisyllabic forms occurring more often than the trisyllabic forms: ooTextFile Distributions 1 column with numeric data Latin 28 rows [L1 L] 25 [L1 H] 25 [H1 L] 25 [H1 H] 25 [L1 L L] 5 [H1 L L] 5 [L H1 L] 5 [H H1 L] 5 [L1 L H] 5 [H1 L H] 5 [L H1 H] 5 [H H1 H] 5 [L L1 L L] 1 [L H1 L L] 1 [L L H1 L] 1 [L H H1 L] 1 [L L1 L H] 1 [L H1 L H] 1 [L L H1 H] 1 [L H H1 H] 1 [H L1 L L] 1 [H H1 L L] 1 [H L H1 L] 1 [H H H1 L] 1 [H L1 L H] 1 [H H1 L H] 1 [H L H1 H] 1 [H H H1 H] 1 Read this file into Praat with Read from file.... A Distributions object then appears in the object list. Click To Strings..., then OK. A Strings object containing 1000 strings, drawn randomly from the distribution, with relative frequencies as in the text file, will appear in the list. Click Inspect to check the contents. You can now select the OTGrammar together with the Strings and choose Learn from partial outputs.... A thousand times, Praat will construct a surface form from the overt form by interpretive parsing, and also construct the underlying form in the same way, from which it will construct another surface form by evaluating the tableau. Whenever the two surface forms are not identical, some constraints will be reranked. In the current implementation, the disharmonies for interpretive parsing and for production are the same, i.e., if the evaluation noise is not zero, the disharmonies are randomly renewed before each interpretive parsing but stay the same for the subsequent virtual production. Links to this page OT learning 
OTGrammar	OTGrammar One of the types of objects in Praat. See the OT learning tutorial. Inside an OTGrammar With Inspect, you will see the following attributes: constraints a list of constraints. Each constraint contains the following attributes: name the fixed name of the constraint, for instance PARSE. ranking the continuous ranking value; will change during learning. disharmony the effective ranking value during stochastic evaluation; with a non-zero evaluation noise, this will be different from ranking. fixedRankings an often empty list of locally ranked pairs of constraints. Each local-ranking pair contains the following attributes: higher the index of the universally higher-ranked of the two constraints, a number between 1 and the number of constraints. lower the index of the universally lower-ranked of the two constraints. tableaus a list of tableaus. Each tableau contains the following attributes: input the input string of the tableau. For production grammaras, the underlying form of the utterance, for example |an+pa| or |bɹɪŋ + PAST|. candidates a list of output candidates. Each output candidate consists of: output the output string of the tableau. In two-level phonology: the surface form of the utterance, for example [anpa] or [ampa] or [bɹɔːt] or [bɹæŋ]. In multi-level phonology: the combination of phonological surface and phonetic results, for example /anpa/[anpa] or /ampa/[ampa] or /bɹɔːt/[bɹɔːt] or /bɹæŋ/[bɹæŋ]. marks a list of the number of violations of each constraint for this output form. If there are 13 constraints, this list will contain 13 integer numbers for each candidate. OTGrammar creation You can easily create some OTGrammar examples from the New menu, or type your own grammars into a text file and read the file into Praat. See the OT learning tutorial. OTGrammar actions You can perform the following actions on selected OTGrammar objects: OTGrammar: Generate inputs... OTGrammar: Input to output... OTGrammar: Input to outputs... (compute the output distribution for a given input) OTGrammar: To output Distributions... OTGrammar & Strings: Inputs to outputs... OTGrammar: Learn one... OTGrammar & 2 Strings: Learn... You can view an OTGrammar in an OTGrammarEditor. Links to this page Create tongue-root grammar... OT learning 1. Kinds of grammars OT learning 2.1. Viewing a grammar OT learning 2.2. Inside the grammar OT learning 2.7. Tableau pictures OT learning 2.9. Output distributions OT learning 3.1. Data from a pair distribution OT learning 3.2. Data from another grammar OT learning 4. Learning an ordinal grammar OT learning 6. Shortcut to grammar learning OT learning 7. Learning from overt forms OTGrammar & PairDistribution: Find positive weights... Robust Interpretive Parsing 
OTGrammar___2_Strings__Learn___	OTGrammar & 2 Strings: Learn... Causes the selected OTGrammar object to process a number of input/output pairs according to the Gradual Learning Algorithm by Boersma (1997) and Boersma & Hayes (2001) or with any other reranking strategies. See OT learning 4. Learning an ordinal grammar and OT learning 5. Learning a stochastic grammar. 
OTGrammar___PairDistribution__Find_positive_weights___	OTGrammar & PairDistribution: Find positive weights... A command to change the weights of the selected OTGrammar on the basis of the language data in the selected PairDistribution. This command works only if the decision strategy of the selected OTGrammar is HarmonicGrammar, LinearOT, PositiveHG, or ExponentialHG. Also, the selected PairDistribution must contain exactly one non-zero-probability output for every possible input of the grammar. The procedure follows the linear programming method by Pater, Potts & Bhatt (2007). This method tries to find a special correct weighting of the constraints, namely one that minimizes the sum of the constraint weights. Settings Weight floor (standard value: 1.0) After the command finishes, every weight will have at least this value. Margin of separation (standard value: 1.0) After the command finishes, the harmony of every optimal (and correct) output candidate will be at least this much greater than the harmony of any competitor in the same tableau. Links to this page What was new in 5.1? 
OTGrammar___Strings__Inputs_to_outputs___	OTGrammar & Strings: Inputs to outputs... An action that creates a Strings object from a selected OTGrammar and a selected Strings. The selected Strings object is considered as a list of inputs to the OTGrammar grammar. Settings Noise the standard deviation of the noise that will be temporarily added to the ranking value at each evaluation. The resulting Strings object will contain the output string of the grammar for each of the input strings. See OT learning 3.2. Data from another grammar. 
OTGrammar__Generate_inputs___	OTGrammar: Generate inputs... A command to create a Strings object from a selected OTGrammar. A practical grammar-specific implementation of the richness of the base: the inputs are drawn at random with equal probabilities from the inputs associated with the tableaus. For an example, see OT learning 3.2. Data from another grammar. Setting Number of trials the number of times a string will be drawn from the possible inputs to the grammar. 
OTGrammar__Input_to_output___	OTGrammar: Input to output... A command to ask the selected OTGrammar object to evaluate the candidates associated with a specified input form. See OT learning 2.8. Asking for one output for tutorial information. Settings Input form the input form whose surface form you want to know. If this string is not in the list of the possible inputs of the selected OTGrammar, you will get an error message. Noise (standard value: 2.0) the standard deviation of the noise added to the ranking value of every constraint during evaluation. See OT learning 2.4. Evaluation. 
OTGrammar__Input_to_outputs___	OTGrammar: Input to outputs... A command to ask the selected OTGrammar object to evaluate a number of times the candidates associated with a specified input form. The result is a Distributions object. See OT learning 2.9. Output distributions for tutorial information and examples. Settings Trials (standard value: 1000) the number of evaluations that you want to perform. Noise (standard value: 2.0) the standard deviation of the noise added to the ranking value of every constraint during the evaluations. See OT learning 2.4. Evaluation. Input form the input form whose surface forms you want to measure. If this string is not in the list of the possible inputs of the selected OTGrammar, you will get an error message. 
OTGrammar__Learn_one___	OTGrammar: Learn one... Causes every selected OTGrammar object to process one input/output pair according to the Gradual Learning Algorithm by Boersma (1998) and Boersma (2000). See OT learning 4. Learning an ordinal grammar and OT learning 5. Learning a stochastic grammar. 
OTGrammar__To_output_Distributions___	OTGrammar: To output Distributions... A command to ask the selected OTGrammar object to evaluate a number of times the candidates associated with every input form. The result is a Distributions object. See OT learning 2.9. Output distributions. Links to this page OT learning 5. Learning a stochastic grammar 
OTGrammarEditor	OTGrammarEditor One of the editors in Praat, for viewing and editing the grammar in an OTGrammar object. See the OT learning tutorial for examples. Usage The menu command that you will probably use most often if you investigate variation, is the Evaluate (noise 2.0) command, which you can invoke from the Edit menu or by pressing Command-2. This command performs a new evaluation with the current ranking values. Some noise is added to the ranking values, so that the disharmonies of the constraint will change. This may cause a change in the ranking order of the constraints, which in its turn may cause a different candidate to win in some tableaus. Links to this page OT learning 2. The grammar OT learning 2.1. Viewing a grammar OT learning 2.8. Asking for one output OT learning 3.2. Data from another grammar Types of objects 
overlap-add	overlap-add A method for manipulating the pitch and duration of an acoustic speech signal. This method was realized by Moulines & Charpentier (1990), who called it Time-Domain Pitch-Synchronous Overlap-and-Add (TD-PSOLA). Nowadays, PSOLA™ and TD-PSOLA™ are trademarks owned by France Telecom®. Overlap-add synthesis When a Sound is created from a Manipulation object, the following steps are performed: 1. From the PitchTier, new points are generated along the entire time domain, with the method of PitchTier: To PointProcess. 2. The period information in the original pulses (available in the Manipulation object) is used to remove from the new pulses all points that lie within voiceless intervals (i.e., places where the distance between adjacent points in the original pulses is greater than 20 ms). 3. The voiceless parts are copied from the source Sound to the target Sound, re-using some parts if the local duration is greater than 1. 4. For each target point, we look up the nearest source point. A piece of the source Sound, centred around the source point, is copied to the target Sound at a location determined by the target point, using a bell-shaped window whose left-hand half-length is the minimum of the left-hand periods adjacent to the source and target points (and analogously for the right-hand half-length). Links to this page Manipulation: Get resynthesis (overlap-add) Manipulation: Play (overlap-add) ManipulationEditor Sound & Pitch: Change gender... Sound & Pitch: Change speaker... Sound & Pitch: To PointProcess (peaks)... Sound: Change gender... Sound: Change speaker... Sound: Lengthen (overlap-add)... Types of objects What was new in 3.8? 
PairDistribution	PairDistribution One of the types of objects in Praat. A PairDistribution object represents the relative probabilities with which the specified pairs of strings occur. Class description struct-list pairs a list of relative string-pair probabilities. Each element consists of: string string1 the first string. string string2 the second string. real weight the relative probability associated with the string pair. This value cannot be negative. Links to this page OT learning 3.1. Data from a pair distribution OT learning 3.2. Data from another grammar OT learning 6. Shortcut to grammar learning OTGrammar & PairDistribution: Find positive weights... PairDistribution: To Stringses... 
PairDistribution__To_Stringses___	PairDistribution: To Stringses... A command to generate a number of string pairs from the selected PairDistribution object. This command will create two aligned Strings objects of equal size. Settings Number (standard: 1000) the number of the strings in either resulting Strings object. Name of first Strings (standard: input) the name of the resulting Strings object associated with the first string of each pair. Name of second Strings (standard: output) the name of the resulting Strings object associated with the second string of each pair. Example Suppose the PairDistribution contains the following: 4 pairs at+ma atma 100 at+ma apma 0 an+pa anpa 20 an+pa ampa 80 The resulting Strings object input may then contain: at+ma, an+pa, an+pa, at+ma, at+ma, an+pa, an+pa, an+pa, an+pa, at+ma, ... The Strings object output may then contain: atma, ampa, ampa, atma, atma, ampa, anpa, ampa, ampa, atma, ... Links to this page OT learning 3.1. Data from a pair distribution 
ParamCurve	ParamCurve One of the types of objects in Praat. An object of class ParamCurve represents a sequence of time-stamped points (x (ti), y (ti)) in a two-dimensional space. 
Paste_history	Paste history A command in the Edit menu of a ScriptEditor, for inserting the history of commands. See History mechanism. Links to this page Scripting 2. How to script settings windows 
Pater__2008_	Pater (2008) Joe Pater (2008): Gradual learning and convergence. Linguistic Inquiry 39: 334–345. Links to this page OT learning 4. Learning an ordinal grammar 
Pater__Potts___Bhatt__2007_	Pater, Potts & Bhatt (2007) Joe Pater, Christopher Potts & Rajesh Bhatt (2007): Harmonic Grammar with linear programming. Manuscript, University of Massachusetts, Amherst. Rutgers Optimality Archive 872. Links to this page OTGrammar & PairDistribution: Find positive weights... 
Pattern	Pattern One of the types of objects in PRAAT. An object of type Pattern represents a sequence of patterns that can serve as inputs for a neural net. All elements in a Pattern have to be in the interval [0,1]. Pattern commands Creation: Create Pattern with zeroes... TableOfReal: To Pattern and Categories... Synthesis: FFNet & Pattern: To Categories... Pattern & Categories: To FFNet... Inside a Pattern With Inspect you will see that this type contains the same attributes as a Matrix. Links to this page Activation Create iris example... Discriminant & Pattern: To Categories... Excitations: To Pattern... FeatureWeights Feedforward neural networks 2. Quick start FFNet & Pattern & Activation: Get average costs... FFNet & Pattern & Activation: Get total costs... FFNet & Pattern & Categories: Get average costs... FFNet & Pattern & Categories: Get total costs... FFNet & Pattern & Categories: Learn slow... FFNet & Pattern & Categories: Learn... FFNet: Categories FFNet: Pattern k-means clustering 2. Quick start KNN & Pattern & Categories & FeatureWeights: Evaluate... KNN & Pattern & Categories: Evaluate... KNN & Pattern & Categories: Learn... KNN & Pattern & Categories: To FeatureWeights... KNN & Pattern & FeatureWeights: To Categories... KNN & Pattern & FeatureWeights: To TableOfReal... KNN & Pattern: To Categories... KNN & Pattern: To TabelOfReal... kNN classifiers 2. Quick start KNN: Extract input Pattern Pattern & Categories: To KNN classifier... Pattern & FeatureWeights: To Categories... Pattern & FeatureWeights: To Dissimilarity... Pattern to Dissimilarity Pattern: To Categories... Pattern: To Dissimilarity... 
Pattern___Categories__To_FeatureWeights___	Pattern & Categories: To FeatureWeights... Compute an estimate of the optimal feature weights using the RELIEF-F algorithm. Setting k neighbours The size of the neighbourhood. See also: kNN classifiers 1.1.1.1. Filter-based feature weighting kNN classifiers 1.1.1.2. Wrapper-based feature weighting kNN classifiers Links to this page kNN classifiers 3. Command overview 
Pattern___Categories__To_FFNet___	Pattern & Categories: To FFNet... Create a new FFNet feedforward neural network. The number of inputs of the newly created FFNet will be equal to the number of columns in the Pattern and the number of outputs will be equal to the number of unique categories in the Categories. Settings Number of units in hidden layer 1, Number of units in hidden layer 2 determine the number of units in the hidden layers. If you want a neural net with no hidden layers, both numbers have to be 0. If you want a neural net with only 1 hidden layer then one of these numbers has to differ from 0. Links to this page Feedforward neural networks 4. Command overview 
Pattern___Categories__To_KNN_classifier___	Pattern & Categories: To KNN classifier... Create and train a KNN classifier using the selected Pattern and Categories objects as training data. Settings Name The name of the KNN classifier. See also: kNN classifiers kNN classifiers 1. What is a kNN classifier? Links to this page kNN classifiers 3. Command overview 
Pattern___FeatureWeights__To_Categories___	Pattern & FeatureWeights: To Categories... Split the given Pattern into a fixed number of clusters using the %%k%-means clustering algorithm and the feature weights contained within the selected FeatureWeights object. A Categories object containing numbered categories corresponding to the generated clusters will be created. Settings k clusters The number of clusters to be generated. Cluster size ratio constraint The minimum allowed ratio between the smallest and the biggest cluster. Maximum number of reseeds The maximum allowed number of reseeds used to enforce the cluster size ratio constraint. See also: kNN classifiers kNN classifiers 1.1.1. Feature weighting Links to this page kNN classifiers 3. Command overview 
Pattern___FeatureWeights__To_Dissimilarity___	Pattern & FeatureWeights: To Dissimilarity... Generate a Dissimilarity matrix from the selected Pattern using the feature weights contained within the selected FeatureWeights object. Dissimilarities are computed using the Euclidean distance. See also: Multidimensional scaling kNN classifiers 1.1.1. Feature weighting kNN classifiers Links to this page kNN classifiers 3. Command overview 
Pattern__To_Categories___	Pattern: To Categories... Split the given Pattern into a fixed number of clusters using the %%k%-means clustering algorithm. A Categories object containing numbered categories corresponding to the generated clusters will be created. Settings k clusters The number of clusters to be generated. Cluster size ratio constraint The minimum allowed ratio between the smallest and the biggest cluster. Maximum number of reseeds The maximum allowed number of reseeds used to enforce the cluster size ratio constraint. See also: kNN classifiers Links to this page kNN classifiers 3. Command overview 
Pattern__To_Dissimilarity___	Pattern: To Dissimilarity... Generate a Dissimilarity matrix from the selected Pattern. Dissimilarities are computed using the Euclidean distance See also: Multidimensional scaling kNN classifiers Links to this page kNN classifiers 3. Command overview 
Pattern_to_Dissimilarity	Pattern to Dissimilarity A Dissimilarity matrix can be used in conjunction with Multidimensional scaling to aid visualization of high-dimensional data. A Dissimilarity object is a matrix of the distances, according to the chosen distance function, between all the data points in the Pattern object. A Dissimilarity object can be created by selecting a Pattern object and choosing To Dissimilarity. The dissimilarity matrix can also be computed using feature weights. This is done by selecting a Pattern object, an FeatureWeights object and choosing To Dissimilarity. 
Patterson___Wightman__1976_	Patterson & Wightman (1976) R. Patterson & F. Wightman (1976): Residue pitch as a function of component spacing. Journal of the Acoustical Society of America 59: 1450–1459. Links to this page Create Sound from tone complex... 
PCA	PCA One of the types of objects in PRAAT. See the Principal component analysis tutorial. An object of type PCA represents the principal components analysis of a multivariate dataset. Commands Creation: Principal component analysis tutorial TableOfReal: To PCA Inside a PCA With Inspect you will see that this type contains the same attributes as an Eigen with the following extras: numberOfObservations the number of observations in the multivariate dataset that originated the PCA, usually equal to the dataset's number of rows. labels[1..dimension] the label that corresponds to each dimension. centroid the centroids of the originating multivariate data set. Links to this page Eigen: Draw eigenvector... GaussianMixture & PCA: Draw concentration ellipses... GaussianMixture & PCA: To Matrix (density)... GaussianMixture: Draw concentration ellipses... GaussianMixture: Draw marginal pdf... GaussianMixture: Split component... GaussianMixture: To PCA PCA & Configuration: To TableOfReal (reconstruct) PCA & Covariance: Project PCA & PCA: Get angle between pc1-pc2 planes PCA & PCA: To Procrustes... PCA & SSCP: Project PCA & TableOfReal: Get fraction variance... PCA & TableOfReal: To Configuration... PCA & TableOfReal: To TableOfReal (z-scores)... PCA: Get eigenvalue... PCA: Get eigenvector element... PCA: Get equality of eigenvalues... PCA: Get fraction variance accounted for... PCA: Get number of components (VAF)... 
PCA___Configuration__To_TableOfReal__reconstruct_	PCA & Configuration: To TableOfReal (reconstruct) A command to reconstruct a TableOfReal from the selected Configuration and PCA. The TableOfReal is reconstructed from the eigenvectors of the PCA and elements of the Configuration are the weight factors: ti = Σk cik ek, where ti is the i-th row in the resulting TableOfReal object, cik is the element at row i and column k in the Configuration object and ek the k-th eigenvector from the PCA object. Links to this page PCA: To TableOfReal (reconstruct 1)... 
PCA___Covariance__Project	PCA & Covariance: Project A command to project the Covariance object onto the eigenspace of the PCA object. Further details can be found in Eigen & SSCP: Project. Links to this page PCA & TableOfReal: Get fraction variance... 
PCA___PCA__Get_angle_between_pc1-pc2_planes	PCA & PCA: Get angle between pc1-pc2 planes A command to calculate the angle between two planes. Each plane is spanned by the first two eigenvectors from the corresponding PCA. Algorithm The algorithm is described in section 12.4.3 of Golub & van Loan (1996): First we form the projection of one set of eigenvectors on the other set. This results in a 2×2 matrix C: C = E1′ E2, where E1 and E2 are 2×dimension and dimension×2 matrices that contain the first two eigenvectors of the PCA's, respectively. Next, we compute the singular value decomposition of C: C = U Σ V′ Now the cosine of the angle between the two planes is given by σ2 and the angle in degrees is therefore: arccos (σ2)·180/π 
PCA___PCA__To_Procrustes___	PCA & PCA: To Procrustes... A command to calculate a Procrustes from the two selected PCA's. Determines the orthogonal Procrustes transform. Algorithm 12.4.1 in Golub & van Loan (1996). 
PCA___SSCP__Project	PCA & SSCP: Project A command to project the SSCP object onto the eigenspace of the PCA object. Further details can be found in Eigen & SSCP: Project. 
PCA___TableOfReal__Get_fraction_variance___	PCA & TableOfReal: Get fraction variance... A command to query the selected PCA and TableOfReal object for the explained fraction of the variance if the TableOfReal object were projected onto the PCA space. Algorithm 1. The TableOfReal is converted to a Covariance object. 2. The Covariance object is projected on the PCA eigenspace and the newly obtained projected Covariance object is queried for the fraction variance. 
PCA___TableOfReal__To_Configuration___	PCA & TableOfReal: To Configuration... A command to construct a Configuration from the selected TableOfReal and PCA. Setting Number of dimensions determines the number of dimensions of the resulting Configuration. Algorithm The TableOfReal is projected on the eigenspace of the PCA, i.e., each row of the TableOfReal is treated as a vector, and the inner product with the eigenvectors of the PCA determine its coordinates in the Configuration. Because the algorithm performs a projection, the resulting Configuration will only be centered, i.e., its centroid will be at 0, if the data in the TableOfReal object are centered too. See also Eigen & TableOfReal: Project.... Links to this page Principal component analysis 
PCA___TableOfReal__To_TableOfReal__z-scores____	PCA & TableOfReal: To TableOfReal (z-scores)... A command to construct a TableOfReal with z-scores from the selected TableOfReal and PCA. Setting Number of dimensions determines the number of dimensions of the resulting Configuration. Algorithm The values dij in the new TableOfReal are calculated as dij = eigenvectorj· zi, which is the inproduct of the j-th eigenvector and the z-score vector zi of the i-th row whose elements zij are defined as zij = (dataij - meanj) / sqrt (eigenvaluej), in which dataij is the data value at row i and column j of the selected TableOfReal and meanj is the j-th centroid value of the PCA. The square root of the j-th eigenvalue is the standard deviation in the j-th principal direction. 
PCA__Get_eigenvalue___	PCA: Get eigenvalue... A command to query the selected PCA for the ith eigenvalue. 
PCA__Get_eigenvector_element___	PCA: Get eigenvector element... A command to query the selected PCA for the jth element of the ith eigenvector. 
PCA__Get_equality_of_eigenvalues___	PCA: Get equality of eigenvalues... A command to get the probability that some of the eigenvalues of the selected PCA object are equal. A low probability means that it is not very likely that that these numbers are equal. We test the hypothesis H0: λfrom = ... = λto that r (= to–from+1) of the eigenvalues λ of the covariance matrix are equal. The remaining eigenvalues are unrestricted as to their values and multiplicities. The alternative hypothesis to H0 is that some of the eigenvalues in the set are distinct. Settings Eigenvalue range define the range of eigenvalues to be tested for equality. Conservative test when on, a more conservative estimate for n is chosen (see below). Details The test statistic is: χ2 = –n Σj=from..to ln eigenvalue[j] + n r ln (Σj=from..to eigenvalue[j] / r), with r(r+1)/2 –1 degrees of freedom. Here n = totalNumberOfCases – 1. A special case occurs when the variation in the last r dimensions is spherical. In a slightly more conservative test we may replace n by n–from–(2r2+r+2)/6r. Also see Morrison (1990), page 336. Links to this page Principal component analysis 
PCA__Get_fraction_variance_accounted_for___	PCA: Get fraction variance accounted for... A command to query the selected PCA for the fraction variance accounted for by the selected components. Setting Principal component range defines the range of the principal components. If you choose both numbers equal, you get the fraction of the variance explained by that one component. Details The contribution is defined as: Σi=from..to eigenvalue[i] / Σi=1..numberOfEigenvalues eigenvalue[i] Links to this page Principal component analysis 
PCA__Get_number_of_components__VAF____	PCA: Get number of components (VAF)... A command to ask the selected PCA for the minimum number of components that are necessary to explain the given fraction variance accounted for. Setting Variance accounted for (fraction) the fraction variance accounted for that must be explained. 
PCA__To_TableOfReal__reconstruct_1____	PCA: To TableOfReal (reconstruct 1)... A command to reconstruct a single data item. The result is stored as a TableOfReal with only one row. Settings Coefficients the weight for the eigenvectors. The algorithm is explained in PCA & Configuration: To TableOfReal (reconstruct). 
Pen_menu	Pen menu One of the menus of the Picture window. Purpose To choose the line type and colour to be used in subsequent drawing of lines and text. Behaviour The line type used by Draw inner box (solid), and the line type of the dotted lines in the Mark... commands will not be affected. The commands in the Margins menu will always draw in black. 
Periodicity_menu	Periodicity menu A menu that occurs in the Dynamic menu for a Sound. This menu contains commands for analysing the pitch contour of the selected Sound: Sound: To Pitch... Sound: To Pitch (ac)... Sound: To Pitch (cc)... Sound: To Harmonicity (cc)... Sound: To Harmonicity (ac)... Links to this page Intro 4.5. The Pitch object 
Permutation	Permutation One of the types of objects in Praat. A Permutation object with n elements consists of some ordering of the numbers 1,2...n. Interpretation A permutation like for example (2,3,5,4,1) is an arrangement of the five objects 1, 2, 3, 4, and 5. It tells us that the second object is in the first position, the third object is in the second position, the fifth object in the third position and so on. If we combine a Permutation together with an other object, like a Strings for example, we may force a new arrangement of the strings, according to the specification in the Permutation (see Strings & Permutation: Permute strings). Commands Creation: Create Permutation... Query: Get number of elements Get value... Get index... Modification: Sort Swap blocks... Swap positions... Swap numbers... Swap one from range... Permutations: Permute randomly... Permute randomly (blocks)... Interleave... Rotate... Reverse... Invert Successive permutations: Multiply Usage Strings & Permutation: Permute strings to rearrange the strings in a Strings object. TableOfReal & Permutation: Permute rows to rearrange the rows in a TableOfReal object. Links to this page Index: To Permutation... Permutation: Next Permutation: Previous Strings: To Permutation... 
Permutation__Get_index___	Permutation: Get index... Get the index position of the value. Example The query for the index of value 3 for the permutation (3,2,4,5,1) gives 1. Links to this page Permutation 
Permutation__Get_value___	Permutation: Get value... Get the value at the index position. Example The query for the value at index 3 for the permutation (3,2,4,5,1) gives 4. Links to this page Permutation 
Permutation__Interleave___	Permutation: Interleave... Generates a new Permutation by interleaving elements from successive blocks. We always start with the first element in the first block. When the offset is zero, the next element will be the first element of the second block, then the first element of the third block. After the first element of the last block, we start again with the second elements in each block. And so on. (In card playing, with two blocks of 26 cards each, this is called a faro shuffle and eight successive faro shuffles will return the deck to precisely the order in which you began.) If the offset differs from zero and equals 1 for example, we start with the first element in the first block, then the second element in the second block, the third element in the third block and so on. When the last element of a block is reached and the number of blocks is not exhausted the next element will be the first from the next block. When the last block is reached, we start the same cycle again with the next lower element in the first block (which by the way need not be the second element, see also example 4). Settings Index range the range of elements that will be permuted. Block size the size of a block. An integer number of blocks must fit in the chosen Index range. Offset determines the relative positions of selected elements in successive blocks. Examples 1. With Index range = [0,0], Block size = 3, and Offset = 0, the permutation ((1,2,3),(4,5,6),(7,8,9)) is turned into (1,4,7,2,5,8,3,6,9). 2. With Index range = [0,0], Block size = 3, and Offset = 1, the permutation ((1,2,3),(4,5,6),(7,8,9)) is turned into (1,5,9,2,6,7,3,4,8). 3. With Index range = [0,0], Block size = 3, and Offset = 2, the permutation ((1,2,3),(4,5,6),(7,8,9)) is turned into (1,6,8,2,4,9,3,5,7). 4. With Index range = [0,0], Block size = 4, and Offset = 1, the permutation ((1,2,3,4),(5,6,7,8)) is turned into (1,6,3,8,2,7,4,5). 
Permutation__Invert	Permutation: Invert Generates the inverse of the selected Permutation. Example If the permutation is (1,5,3,2,4) the inverse will be (1,4,3,5,2). If we multiply these two permutations the result will be the identity permutation (1,2,3,4,5). 
Permutation__Next	Permutation: Next Get the next permutation in lexicographic permutation order. The next permutation is obtained from the selected permutation by swapping values at only two positions. Starting with the identity permutation and repeatedly applying this function will iterate through all possible permutations. If no further permutation is available, i.e. the selected permutation is at the lexicographic end position (n, n-1, ..., 3, 2, 1), the current permutation will not change anymore. Examples If we start with (1,2,3,4) successively applying Next will generate the following sequence (1,2,4,3), (1,3,2,4), (1,3,4,2), (1,4,2,3), (1,4,3,2), etc. Links to this page Permutation: Previous 
Permutation__Permute_randomly___	Permutation: Permute randomly... Generates a new Permutation by randomly permuting a range of elements in the selected Permutation object. Setting Index range defines the range of elements that will be permuted. The elements outside this range will be kept intact. Example If we start with the permutation (4,6,3,1,5,2,7) and a chosen Index range that runs from 3 to 6, a new permutation will be generated as follows: 1. A new permutation of the same dimension as the selected one will be created. 2. Because the index range starts at 3, the first two elements of the selected permutation will be copied to the first two locations in the newly created permutation. The new permutation is now (4,6,.,.,.,.,.), where a dot (.) means that the element is unspecified. 3. The elements 3 to 6 of the selected permutation, i.e. the numbers (3,1,5,2) will be randomly permuted. There are 24 possible permutations of these 4 numbers. Say the outcome happens to be (5,1,3,2). The new permutation is now (4,6,5,1,3,2,.). 4. The remaining element (7) is copied to the new permutation. Finally, this results in the new permutation being (4,6,5,1,3,2,7). 
Permutation__Permute_randomly__blocks____	Permutation: Permute randomly (blocks)... Generates a new Permutation by randomly permuting blocks of size blocksize. Settings Index range the range of elements whose blocks will be permuted. Block size the size of the blocks that will be permuted. There must fit an integer number of blocks in the chosen range. Permute within blocks when on, the elements in each block are also randomly permuted. No doublets guarantees that the first element in each block does not equal the last element of the previous block modulo the block size. E.g. the numbers 3, 6, 9 are all equal modulo 3. This parameter only has effect when Permute within blocks is on. Examples 1. With Index range = [0,0], Block size = 3 and Permute within blocks is off, the permutation ((1,2,3),(4,5,6),(7,8,9)) is turned into one of six possible permutations, for example into ((4,5,6),(7,8,9),(1,2,3)). (The option No doublets will be ignored and the parentheses are only there to indicate the blocks.) 2. With Index range = [0,0], Block size = 3, Permute within blocks is on and No doublets is off, the permutation ((1,2,3),(4,5,6),(7,8,9)) might turn into ((5,4,6),(9,8,7),(3,1,2)). 3. With the same options as 2 but No doublets is on, the previously given outcome is forbidden because the last element of the first block (6) and the first element of the next block (9) are equal modulo 3 (the blocksize). A valid outcome might then be ((5,4,6),(8,9,7),(3,1,2)). Links to this page Strings & Permutation: Permute strings 
Permutation__Previous	Permutation: Previous Get the previous permutation in lexicographic permutation order. The previous permutation is obtained from the selected permutation by swapping values at only two positions. If no further permutation is available, i.e. the current permutation is at the lexicographic start position (1, 2, 3, ..., n-1, n), the current permutation will not change anymore. The Previous operation follows the opposite order of Permutation: Next. 
Permutation__Reverse___	Permutation: Reverse... Reverse the elements in the given range. Setting Index range defines the range of indices that will be reversed. Examples 1. With Index range = [0,0], the permutation (1,2,3,4,5) is turned into (5,4,3,2,1). 2. With Index range = [3,0], the permutation (1,2,3,4,5) is turned into (1,2,5,4,3). Links to this page Permutation Strings: To Permutation... 
Permutation__Rotate___	Permutation: Rotate... A circular shift of all elements within the given range. Settings Index range the range of elements that will be circularly permuted. Step size define how many positions each element will be shifted. Examples 1. With Step size = 2 and Index range = [1,5], the permutation (1,2,3,4,5) is turned into (4,5,1,2,3). 2. With Step size = 2 and Index range = [2,5], the permutation ((1),(2,3,4,5)) is turned into ((1),(4,5,2,3)) 3. With Step size = -1 and Index range = [0,0], the permutation (1,2,3,4,5) is turned into (2,3,4,5,1). Links to this page Permutation 
Permutation__Sort	Permutation: Sort Sorts the elements ascending, i.e. set the selected Permutation to the identity permutation. 
Permutation__Swap_blocks___	Permutation: Swap blocks... A command to swap the contents of two index ranges in the selected Permutation. Settings From index, To index the two starting positions from where elements are to be swapped. The blocks may overlap. Block size determines the number of pairs to swap. Behaviour If the Block size equals one, only the elements at the From index and To index position are swapped. If blocksize is greater than one, the two elements at From index+1 and To index+1 will be swapped too. This goes on until the last two elements in each block have been swapped. Examples 1. Swap two blocks: with From index = 1, To index = 4, and Block size = 2, the permutation (1,2,3,4,5) is turned into (4,5,3,1,2). 2. Swap two elements: with From index = 1, To index = 4, and Block size = 1, the permutation (1,2,3,4,5) is turned into (4,2,3,1,5). 3. Swap two overlapping blocks: with From index = 1, To index = 3, and Block size = 3, the permutation (1,2,3,4,5) is turned into (3,4,5,2,1). 
Permutation__Swap_numbers___	Permutation: Swap numbers... Swaps two numbers in the selected Permutation. Settings First number, Second number the two numbers that have to be swapped. The order of these numbers is not important. Example With First number = 1 and Second number = 3, the permutation (1,3,4,2,5) is turned into (3,1,4,2,5). 
Permutation__Swap_one_from_range___	Permutation: Swap one from range... An element at an index, randomly chosen from a range, will be permuted with an element at a prescribed index position. Settings Index range defines the range of indices from which one will be randomly chosen. Index defines the special index position whose element will be interchanged with the one chosen from the range. Forbid same when on, forbids the randomly chosen position and the index position to be the same. This switch is only of relevance when the chosen range happens to overlap the index position. Examples With Index range = [0,0], Index = 3, Forbid same is off and (1,2,3,4,5) as the starting permutation, the outcome might be one of the five permutations (3,2,1,4,5), (1,3,2,4,5), (1,2,3,4,5), (1,2,4,3,5), (1,2,5,4,3). If Forbid same were chosen as on, the (1,2,3,4,5) permutation is forbidden and the outcome could only be one of the four remaining permutations. Links to this page Permutation 
Permutation__Swap_positions___	Permutation: Swap positions... Swaps the contents at two indices in the selected Permutation. Settings First index, Second index the two indices from where elements have to be swapped. The order of these indices is not important. Example With First index = 1 and Second index = 3, the permutation (1,3,4,2,5) is turned into (4,3,1,2,5). 
Permutations__Multiply	Permutations: Multiply Apply the selected Permutations one after the other. Permutations are not commutative, i.e. applying permutation p1 after p2 might not give the same outcome as applying p2 after p1. Links to this page Permutation: Invert 
Peterson___Barney__1952_	Peterson & Barney (1952) G.E. Peterson & H.L. Barney (1952): Control methods used in a study of the vowels. Journal of the Acoustical Society of America 24: 175–184 Links to this page Create formant table (Peterson & Barney 1952) Table: Box plots where... 
Phonetic_symbols	Phonetic symbols To draw phonetic symbols in the Picture window or in the TextGridEditor, make sure that you have installed the Charis SIL and/or Doulos SIL font, for instance from www.sil.org or from www.praat.org. You can either type the symbols directly (if your computer has an input method for them), or use backslash sequences as described in: Phonetic symbols: consonants Phonetic symbols: vowels Phonetic symbols: diacritics Links to this page Font menu Special symbols What was new in 5.1? 
Phonetic_symbols__consonants	Phonetic symbols: consonants To draw phonetic symbols for consonants in the Picture window or in the TextGridEditor, make sure that you have installed the Charis SIL and/or Doulos SIL font, for instance from www.sil.org or from www.praat.org. You can either type the symbols directly (if your computer has an input method for them), or use the backslash sequences in the following table. Other consonant symbols: ɫ \l~ (l with tilde): velarized l ɧ \hj (heng with hooktop): the Swedish rounded post-alveolar & velar fricative How to remember the codes For most of the codes, the first letter tells you the most similar letter of the English alphabet. The second letter can be t (turned), c (capital or curled), s (script), - (barred), l (with leg), i (inverted), or j (left tail). Some phonetic symbols are similar to Greek letters but have special phonetic (f) versions with serifs (ɸ, β, ɣ) or are otherwise slightly different (θ, χ). The codes for ŋ (engma), ð (eth), ʃ (esh), and ʒ (yogh) are traditional alternative spellings. The retroflexes have a period in the second place, because an alternative traditional spelling is to write a dot under them. The code for ɾ is an abbreviation for fishhook. Links to this page Phonetic symbols 
Phonetic_symbols__diacritics	Phonetic symbols: diacritics To draw phonetic diacritical symbols in the Picture window or in the TextGridEditor, make sure that you have installed the Charis SIL and/or Doulos SIL font, for instance from www.sil.org or from www.praat.org. You can either type the symbols directly (if your computer has an input method for them), or use the backslash sequences in the following list. Understrikes: n̩ n\|v (combining vertical line below): syllabic consonant b̥ b\0v (combining ring below): voiceless (e.g. lenis voiceless plosive, voiceless nasal or approximant) o̞ o\Tv (combining down tack below, lowering): lowered vowel; or turns a fricative into an approximant o̝ o\T^ (combining up tack below, raising): raised vowel; or turns an approximant into a fricative o̘ o\T( (combining left tack below, atr): advanced tongue root o̙ o\T) (combining right tack below, rtr): retracted tongue root e̠ e\-v (combining macron below): backed o̟ o\+v (combining plus sign below): fronted o̤ o\:v (combining diaeresis below): breathy voice o̰ o\~v (combining tilde below): creaky voice d̪ d\Nv (combining bridge below): dental (as opposed to alveolar) d̺ d\Uv (combining inverted bridge below): apical d̻ d\Dv (combining square below): laminal u̯ u\nv (combining inverted breve below): nonsyllabic e̹ e\3v (combining right half ring below): slightly rounded u̜ u\cv (combining left half ring below): slightly unrounded Overstrikes: ɣ̊ \gf\0^ (combining ring above): voiceless ɛ́ \ef\'^ (combining acute accent): high tone ɛ̀ \ef\`^ (combining grave accent): low tone ɛ̄ \ef\-^ (combining macron): mid tone (or so) ɛ̃ \ef\~^ (combining tilde): nasalized ɛ̌ \ef\v^ (combining caron, háček, wedge): rising tone ɛ̂ \ef\^^ (combining circumflex accent): falling tone ö o\:^ (combining diaeresis): centralized ɛ̆ \ef\N^ (combining breve): short k͡p t͡s k\lip (combining double inverted breve, ligature): simultaneous articulation, or single segment In line: ː \:f the phonetic length sign ˑ \.f half length ˈ \'1 primary stress ˌ \'2 secondary stress | \|f the phonetic stroke t̚ t\cn (combining left angle above, corner): unreleased plosive ɜ˞ \er\hr (combining rhotic hook): rhotacized vowel Not available in EPS files (i.e. only publishable with copy-paste or with PDF files): tʰ t\^h aspiration bʱ b\^H voiced aspiration (breathiness) tʲ t\^j palatalization tˠ t\^g, tᵚ t\^M, tᶭ t\^G velarization kʷ k\^w rounding tᶣ t\^Y rounding with palatalization aˀ a\^? glottalization tˁ t\^9 pharyngealization tˡ t\^l lateral release tⁿ t\^n, pᵐ p\^m, kᵑ k\^N nasal release tˢ t\^s, kˣ k\^x, pᶠ p\^f affrication ʸ \^y (palatalization in a deprecated American notation) a‿b a\_ub undertie (liaison, if spaces don't mean breaks in your transcription) ʦ \ts t–s ligature ʧ \tS tesh ligature pʼ p\ap apostrophe (for ejectives) Links to this page Phonetic symbols What was new in 5.3? 
Phonetic_symbols__vowels	Phonetic symbols: vowels To draw phonetic symbols for vowels in the Picture window or in the TextGridEditor, make sure that you have installed the Charis SIL and/or Doulos SIL font, for instance from www.sil.org or from www.praat.org. You can either type the symbols directly (if your computer has an input method for them), or use the backslash sequences in the following table. Other vowel symbols are: ɚ \sr (schwa with right hook): rhotacized schwa Not available in EPS files (i.e. only publishable with copy-paste or with PDF files): ɿ \id syllabic dental approximant ʅ \ir syllabic retroflex (or apico-postalveolar) approximant How to remember the codes For most of the codes, the first letter tells you the most similar letter of the English alphabet. The second letter can be t (turned), c (capital), s (script), r (reversed), - (barred or retracted), or / (slashed). One symbol (ɛ) is a phonetic version of a Greek letter. The codes for ə, ɤ, ʊ and ɞ are abbreviations for schwa, ram's horn, horseshoe, and kidney bean. Links to this page Phonetic symbols What was new in 5.3? 
phonToDifferenceLimens	phonToDifferenceLimens A routine for converting sensation level in phons into intensity difference limen level, the inverse of differenceLimensToPhon. Formula phonToDifferenceLimens (phon) = 30 · ((61/60) phon – 1) Derivation In first approximation, humans can detect an intensity difference of 1 phon, i.e. if two sounds that differ only in intensity are played a short time after each other, people can generally detect their intensity difference if it is greater than 1 phon. But the sensitivity is somewhat better for louder sounds. According to Jesteadt, Wier & Green (1977), the relative difference limen of intensity is given by DLI = ΔI / I = 0.463 · (I / I0) –0.072 In this formula, I is the intensity of the sound in Watt/m2, I0 is the intensity of the auditory threshold (i.e. 10–12 Watt/m2 at 1000 Hz), and ΔI is the just noticeable difference. Boersma (1998: 109) calculates a difference-limen scale from this. Given an intensity I, the number of difference limens above threshold is ∫I0I dx ΔI(x) = (1 / 0.463) ∫I0I dx I0–0.072 x0.072–1 = (1 / (0.463·0.072)) ((I/I0)0.072 – 1) The sensation level in phon is defined as SL = 10 log10 (I/I0) so that the number of difference limens above threshold is (1 / (0.463·0.072)) (10(0.072/10)(10log(I/I0)) – 1) = 30 · (1.0167SL – 1) Links to this page Formulas 4. Mathematical functions 
Picture_window	Picture window One of the two main windows in Praat. File menu • Save as PDF file... • Save as PNG file... • Save as EPS file... • Save as Windows metafile... • Read from Praat picture file..., Save as Praat picture file... • PostScript settings... • Print... Edit menu • Undo • Copy to clipboard • Erase all Margins menu • Draw inner box • Text left/right/top/bottom... • Marks left/right/top/bottom every... • One mark left/right/top/bottom... • Marks left/right/top/bottom... • Logarithmic marks left/right/top/bottom... • One logarithmic mark left/right/top/bottom... • Axes... World menu • Text... • Axes... Select menu • Select inner viewport..., Select outer viewport..., Viewport text... Pen menu Font menu Links to this page Add to fixed menu... Draw menu File menu Fixed menu commands Formant: Draw tracks... Formant: Speckle... Hidden commands Insert picture from file... Intro 3.4. Printing the spectrogram Intro 3.5. The Spectrogram object Intro 3.8. The Spectrum object Intro 4.4. Printing the pitch contour Intro 4.5. The Pitch object Intro 5.4. The Formant object Intro 6.4. The Intensity object Matrix: Draw as squares... Matrix: Paint cells... OT learning 2.7. Tableau pictures Phonetic symbols Phonetic symbols: consonants Phonetic symbols: diacritics Phonetic symbols: vowels Pitch: Draw... PointProcess: Draw... Scripting 1. Your first scripts Scripting 3.1. Hello world Special symbols Spectrogram: Paint... Text styles TextGrid What was new in 3.6? 
Pitch	Pitch One of the types of objects in Praat. For tutorial information, see Intro 4. Pitch analysis. A Pitch object represents periodicity candidates as a function of time. It does not mind whether this periodicity refers to acoustics, perception, or vocal-cord vibration. It is sampled into a number of frames centred around equally spaced times. Pitch commands Creation: Sound: To Pitch...: preferred method (autocorrelation). Sound: To Pitch (ac)...: autocorrelation method (all parameters). Sound: To Pitch (cc)...: cross-correlation method. Drawing: Pitch: Draw... Viewing and editing: PitchEditor Synthesis: Pitch: To PointProcess: create points in voiced intervals. Sound & Pitch: To PointProcess (cc): near locations of high amplitude. Sound & Pitch: To PointProcess (peaks)...: near locations of high amplitude. Conversion: Pitch: To PitchTier: time-stamp voiced intervals. Pitch & PointProcess: To PitchTier...: interpolate values at specified times. Inside a Pitch object With Inspect, you will see the following attributes: xmin start time, in seconds. xmax end time, in seconds. nx the number of frames (≥ 1). dx time step = frame length = frame duration, in seconds. x1 the time associated with the first frame, in seconds. This will usually be in the range [xmin, xmax]. The time associated with the last frame (i.e., x1 + (nx – 1) dx)) will also usually be in that range. ceiling a frequency above which a candidate is considered voiceless. framei, i = 1 ... nx the frames (see below). Attributes of a pitch frame Each frame contains the following attributes: nCandidates the number of candidates in this frame (at least one: the `unvoiced' candidate). candidatej, j = 1 ... nCandidates the information about each candidate (see below). Attributes of each candidate Each candidate contains the following attributes: frequency the candidate's frequency in Hz (for a voiced candidate), or 0 (for an unvoiced candidate). strength the degree of periodicity of this candidate (between 0 and 1). Interpretation The current pitch contour is determined by the path through all first candidates. If the first candidate of a certain frame has a frequency of 0, or a frequency above ceiling, this frame is considered voiceless. Links to this page FAQ: Pitch analysis Formulas 7. Attributes of objects Get frame number from time... Get number of frames Get time from frame number... Get time step Intro 4.5. The Pitch object Pitch: Interpolate Pitch: Smooth... PitchTier: Get mean (curve)... PitchTier: Get standard deviation (points)... PitchTier: To Pitch... Play Sound & Pitch: Change gender... Sound & Pitch: Change speaker... Sound & Pitch: To FormantFilter... Sound: To Pitch (shs)... time domain What was new in 3.6? What was new in 3.7? 
Pitch___PointProcess__To_PitchTier___	Pitch & PointProcess: To PitchTier... A command that creates a PitchTier object from one selected Pitch and one selected PointProcess object. Purpose to return the frequencies in the Pitch contour at the times specified by the PointProcess. Setting Check voicing (standard: on) determines whether, if the time of a mark is not within a voiced frame, you will get a message like No periodicity at time xxx., and no PitchTier is created. If this button is off, the resulting pitch frequency will be 0.0 Hz. Normal behaviour For all the times in the PointProcess, a pitch frequency is computed from the information in the Pitch, by linear interpolation. All the resulting time-frequency pairs are put in a new PitchTier object. The time domain of the resulting PitchTier is a union of the domains of the original Pitch and PointProcess functions. 
Pitch__Draw___	Pitch: Draw... A command for drawing the selected Pitch objects into the Picture window. Settings From time (s) To time (seconds) the time domain along the horizontal axis. If these are both zero, the time domain of the Pitch itself is taken (autowindowing). Minimum frequency (Hz) Maximum frequency (Hz) the frequency range along the vertical axis. Maximum frequency must be greater than Minimum frequency. Behaviour In unvoiced frames, nothing will be drawn. In voiced frames, the pitch frequency associated with the frame is thought to represent the time midpoint of the frame, but frequencies will be drawn at all time points in the frame, as follows: If two adjacent frames are both voiced, the frequency of the time points between the midpoints of the frames is linearly interpolated from both midpoints. If a voiced frame is adjacent to another voiced frame on one side, and to a voiceless frame on the other side, the frequencies in the half-frame on the unvoiced side will be linearly extrapolated from the midpoints of the two voiced frames involved. If a voiced frame is adjacent to two unvoiced frames, a horizontal line segment will be drawn at the frequency of the midpoint. 
Pitch__Interpolate	Pitch: Interpolate A command that converts every selected Pitch object. 
Pitch__Smooth___	Pitch: Smooth... A command that converts every selected Pitch object. 
Pitch__To_PitchTier	Pitch: To PitchTier A command that converts a Pitch object into a PitchTier object. Algorithm The PitchTier object will contain as many points as there were voiced frames in the Pitch. The time of each point is the time associated with the centre of the corresponding frame of the Pitch contour. The frequency of the point is the pitch frequency associated in this frame with the current path through the candidates. Links to this page Manipulation Pitch: To PointProcess 
Pitch__To_PointProcess	Pitch: To PointProcess A command that uses a Pitch object to generate a PointProcess. Purpose to interpret an acoustic periodicity contour as the frequency of an underlying point process (such as the sequence of glottal closures in vocal-fold vibration). Algorithm 1. A PitchTier is created with Pitch: To PitchTier. 2. The algorithm of PitchTier: To PointProcess generates points along the entire time domain of the PitchTier. 3. The PitchTier is removed (it never appeared in the List of Objects). 4. The voiced/unvoiced information in the Pitch is used to remove all points that lie within voiceless frames. Links to this page Voice 6. Automating voice analysis with a script 
pitch_floor	pitch floor The pitch floor is the bottom of the pitch range in the Sound window (see the Intro). The standard setting is 75 hertz; pitch values below this pitch floor will not be computed or shown by Praat. To change the pitch floor, choose Pitch settings.... Links to this page FAQ: Pitch analysis 
Pitch_settings___	Pitch settings... A command in the Pitch menu of the SoundEditor and TextGridEditor windows. See Intro 4.2. Configuring the pitch contour. Links to this page Advanced pitch settings... Advanced pulses settings... FAQ: Pitch analysis pitch floor Voice Voice 5. Comparison with other programs Voice 6. Automating voice analysis with a script 
PitchEditor	PitchEditor One of the Editors in Praat, for viewing and modifying a Pitch object. What the Pitch editor shows In the window of the PitchEditor, you will see the following features: Digits between 0 and 9 scattered all over the drawing area. Their locations represent the pitch candidates, of which there are several for every time frame. The digits themselves represent the goodness of a candidate, multiplied by ten. For instance, if you see a 9 at the location (1.23 seconds, 189 hertz), this means that in the time frame at 1.23 seconds, there is a pitch candidate with a value of 189 hertz, and its goodness is 0.9. The number 0.9 may be the relative height of an autocorrelation peak, a cross-correlation peak, or a spectral peak, depending on the method by which the Pitch object was computed. A path of red disks. These disks represent the best path through the candidates, i.e. our best guess at what the pitch contour is. The path will usually have been determined by the path finder, which was called by the pitch-extraction algorithm, and you can change the path manually. The path finder takes into account the goodness of each candidate, the intensity of the sound in the frame, voiced-unvoiced transitions, and frequency jumps. It also determines whether each frame is voiced or unvoiced. A voicelessness bar at the bottom of the drawing area. If there is no suitable pitch candidate in a frame, the frame is considered voiceless, which is shown as a blue rectangle in the voicelessness bar. A line of digits between 0 and 9 along the top. These represent the relative intensity of the sound in each frame. Moving the marks To move the cursor hair or the beginning or end of the selection, use the time selection mechanism. Changing the path To change the path through the candidates manually, click on the candidates of your choice. The changes will immediately affect the Pitch object that you are editing. To make a voiced frame voiceless, click on the voicelessness bar. To change the path automatically, choose Path finder... from the Edit menu; this will have the same effect as filling in different values in the Sound: To Pitch (ac)... command window, but is much faster because the candidates do not have to be determined again. Resynthesis To hum any part of the pitch contour, click on one of the buttons below or above the data area (there can be 1 to 8 of these buttons), or use a Play command from the View menu. Changing the ceiling To change the ceiling, but not the path, choose Change ceiling... from the Edit menu; if the new ceiling is lower than the old ceiling, some formerly voiced frames may become unvoiced; if the new ceiling is higher than the old ceiling, some formerly unvoiced frames may become voiced. Links to this page Intro 4.5. The Pitch object Types of objects 
PitchTier	PitchTier One of the types of objects in Praat. A PitchTier object represents a time-stamped pitch contour, i.e. it contains a number of (time, pitch) points, without voiced/unvoiced information. For instance, if your PitchTier contains two points, namely 150 Hz at a time of 0.5 seconds and 200 Hz at a time of 1.5 seconds, then this is to be interpreted as a pitch contour that is constant at 150 Hz for all times before 0.5 seconds, constant at 200 Hz for all times after 1.5 seconds, and linearly interpolated for all times between 0.5 and 1.5 seconds (i.e. 170 Hz at 0.7 seconds, 210 Hz at 1.1 seconds, and so on). PitchTier objects are used for two purposes: for manipulating the pitch curve of an existing sound (see Intro 8.1. Manipulation of pitch) and for synthesizing a new sound (see Source-filter synthesis 1. Creating a source from pitch targets, and for an example Source-filter synthesis 3. The ba-da continuum). PitchTier commands Creation: From scratch: • Create PitchTier... • PitchTier: Add point... Copy from another object: • Pitch: To PitchTier: trivial copying of voiced frames. • PointProcess: Up to PitchTier...: single value at specified times. • Pitch & PointProcess: To PitchTier...: copying interpolated values at specified points. Synthesize from another object: • PointProcess: To PitchTier...: periodicity analysis. Extract from a Manipulation object: • Manipulation: Extract pitch tier Viewing and editing: PitchTierEditor: with or without a Sound. ManipulationEditor Conversion: PitchTier: Down to PointProcess: copy the times. Synthesis: PitchTier: To PointProcess: area-1 pulse generation (used in overlap-add). Manipulation: Replace pitch tier Queries: time domain Get low index from time... Get high index from time... Get nearest index from time... PitchTier: Get mean (curve)... PitchTier: Get mean (points)... PitchTier: Get standard deviation (curve)... PitchTier: Get standard deviation (points)... Get area...: the number of periods Modification: Remove point... Remove point near... Remove points between... PitchTier: Add point... PitchTier: Stylize... Links to this page constant extrapolation linear interpolation Pitch: To PointProcess PitchTier: To Pitch... Sound: To KlattGrid (simple)... What was new in 3.6? What was new in 3.7? 
PitchTier__Add_point___	PitchTier: Add point... A command to add a point to each selected PitchTier. Settings Time (s) the time at which a point is to be added. Pitch (Hz) the pitch value of the requested new point. Behaviour The tier is modified so that it contains the new point. If a point at the specified time was already present in the tier, nothing happens. Links to this page Create PitchTier... Intro 8.1. Manipulation of pitch Source-filter synthesis 1. Creating a source from pitch targets 
PitchTier__Down_to_PointProcess	PitchTier: Down to PointProcess A command to degrade every selected PitchTier to a PointProcess. Behaviour The times of all the pitch points are trivially copied, and so is the time domain. The pitch information is lost. 
PitchTier__Get_mean__curve____	PitchTier: Get mean (curve)... A query to the selected PitchTier object. Return value the mean of the curve within a specified time window. Settings From time (s) To time (s) the time window, in seconds. Values outside this window are ignored. If To time is not greater than From time, the entire time domain of the tier is considered. Algorithm The curve consists of a sequence of line segments. The contribution of the line segment from (t1, f1) to (t2, f2) to the area under the curve is 1/2 (f1 + f2) (t2 – t1) The mean is the sum of these values divided by toTime – fromTime. For a PitchTier that was created from a Pitch object, this command gives the same result as Get mean.... for the original Pitch object (but remember that the median, as available for Pitch objects, is more robust). To get the mean in the entire curve, i.e. weighted by the durations of the line pieces, Use PitchTier: Get mean (points)... instead. 
PitchTier__Get_mean__points____	PitchTier: Get mean (points)... A query to the selected PitchTier object. Return value the mean of the points within a specified time window. Settings From time (s) To time (s) the time window, in seconds. Values outside this window are ignored. If To time is not greater than From time, the entire time domain of the tier is considered. To get the mean in the entire curve, i.e. weighted by the durations of the line pieces, Use PitchTier: Get mean (curve)... instead. 
PitchTier__Get_standard_deviation__curve____	PitchTier: Get standard deviation (curve)... A query to the selected PitchTier object. Return value the standard deviation in the curve within a specified time window. Settings From time (s) To time (s) the selected time domain. Values outside this domain are ignored. If To time is not greater than From time, the entire time domain of the tier is considered. Algorithm The curve consists of a sequence of line segments. The contribution of the line segment from (t1, f1) to (t2, f2) to the variance-multiplied-by-time is [ 1/4 (f1 + f2)2 + 1/12 (f1 – f2)2 ] (t2 – t1) The standard deviation is the square root of: the sum of these values divided by toTime – fromTime. To get the standard deviation in the points only, i.e. not weighted by the durations of the line pieces, Use PitchTier: Get standard deviation (points)... instead. 
PitchTier__Get_standard_deviation__points____	PitchTier: Get standard deviation (points)... A query to the selected PitchTier object. Return value the standard deviation in the points within a specified time window. Settings From time (s) To time (s) the selected time domain. Values outside this domain are ignored. If To time is not greater than From time, the entire time domain of the tier is considered. For a PitchTier that was created from a Pitch object, this command gives the same result as Get standard deviation.... for the original Pitch object (but remember that variation measures based on quantiles, as available for Pitch objects, are more robust). To get the standard deviation in the entire curve, i.e. weighted by the durations of the line pieces, Use PitchTier: Get standard deviation (curve)... instead. 
PitchTier__Stylize___	PitchTier: Stylize... A command that modifies the selected PitchTier object (or the pitch curve in the ManipulationEditor). Purpose to end up with a much simplified pitch curve. Settings Frequency resolution (standard: 2.0 semitones) the minimum amount by which every remaining pitch point will lie above or below the line that connects its two neigbours. Algorithm 1. Look up the pitch point that is closest to the straight line that connects its two neighbouring points. 2. If this pitch point is further away from that straight line than Frequency resolution, we are finished: the curve cannot be stylized any further. 3. If we are not finished, the pitch point we found in step 1 is removed. 4. Go back to step 1. 
PitchTier__To_Pitch___	PitchTier: To Pitch... Synthesizes a new Pitch from the selected PitchTier. 
PitchTier__To_PointProcess	PitchTier: To PointProcess A command that uses a PitchTier object to generate a PointProcess. Purpose to interpret an acoustic periodicity contour as the frequency of an underlying point process (such as the sequence of glottal closures in vocal-fold vibration). Algorithm Points are generated along the entire time domain of the PitchTier, because there is no voiced/unvoiced information. The area between two adjacent points under the linearly interpolated pitch contour, is always 1. Links to this page overlap-add Pitch: To PointProcess Source-filter synthesis 1. Creating a source from pitch targets 
PitchTierEditor	PitchTierEditor One of the Editors in Praat, for viewing and manipulating a PitchTier object, which is optionally shown together with a Sound object. Objects The editor shows: The Sound, if you selected a Sound object together with the PitchTier object before you clicked View & Edit. The PitchTier: blue points connected with blue lines. Playing To play (a part of) the resynthesized sound: click on any of the 8 buttons below and above the drawing area, or choose a Play command from the View menu. To play the original sound instead, use Shift-click. Adding a point Click at the desired time location, and choose Add point at cursor or type Command-P. Removing points To remove one or more pitch points, make a time selection and choose Remove point(s) from the Point menu. If there is no selection, the point nearest to the cursor is removed. Links to this page Types of objects 
Play	Play A command that is available if you select a Sound, Pitch, or PointProcess object. It gives you an acoustic representation of the selected object, if your loudspeakers are on and you did not mute your computer sound system. A Play button is also available in the SoundRecorder window and in the View menu of the SoundEditor or TextGridEditor. In the editors, you will usually play a sound by clicking on any of the rectangles around the data. Links to this page Intro 8.2. Manipulation of duration 
Plomp__1967_	Plomp (1967) Reinier Plomp (1967): Frequencies dominant in the perception of pitch of complex sounds. Journal of the Acoustical Society of America 42: 191–198. Links to this page Create Sound from tone complex... 
plug-ins	plug-ins Experienced Praat script writers can distribute their product as a plug-in to Praat. The Praat plug-in mechanism When Praat starts up, it will execute all Praat scripts called setup.praat that reside in directories whose name starts with plugin_ and that themselves reside in your Praat preferences directory. How to write a Praat plug-in Suppose that you have a set of Praat scripts specialized in the analysis and synthesis of vocalizations of guinea pigs, and that these scripts are called analyseQueak.praat and createQueak.praat (queak is what guinea pigs tend to say). With the ScriptEditor, you have put the script analyseQueak.praat in the dynamic menu that appears if the user selects a Sound object, and you have put the script createQueak.praat in the New menu. Only the latter script requires the user to supply some settings in a form, so the two menu commands are Analyse queak (without dots) and Create queak... (with three dots), respectively. Suppose now that you want to distribute those two commands to other guinea pig vocalization researchers. What you do is that you create a Praat script called setup.praat (in the same directory as the two other scripts), that contains the following two lines: Add action command: Sound, 1, , 0, , 0, Analyse queak, , 0, analyseQueak.praat Add menu command: Objects, New, Create queak..., , 0, createQueak.praat (If you ran this script, Praat would install those two commands in the correct menus, and remember them in the buttons file; but you are now going to install them in a different way.) You now put the three scripts in a new directory called plugin_Queak, and put this directory in your Praat preferences directory. If you are on Windows, you will now have a directory called something like C:\Documents and Settings\Your Name\Praat\plugin_Queak. If you now start up Praat, Praat will automatically execute the script C:\Documents and Settings\Your Name\Praat\plugin_Queak\setup.praat and thereby install the two buttons. The two buttons will not be remembered in the buttons file, but they will be installed at every Praat start-up. De-installation involves removing (or renaming) the plugin_Queak directory. To distribute the Queak plug-in among your colleague guinea pig researchers, you can use any installer program to put the plugin_Queak directory into the user's Praat preferences directory; or you could ask those colleagues to move the plugin_Queak directory there by hand. The structure of your plug-in directory In the example setup.praat file above, the names of the scripts analyseQueak.praat and createQueak.praat occur without any directory information. This works because Praat regards these file names as being relative to the directory where setup.praat is located. If your plug-in is much larger than two scripts, you may want to put subdirectories into the directory plugin_Queak. For instance, if you put analyseQueak.praat into the subdirectory analysis, your line in the setup.praat script would look as follows: Add action command: Sound, 1, , 0, , 0, Analyse queak, , 0, analysis/analyseQueak.praat The forward slash (/) in this example makes your plug-in platform-independent: it will work unchanged on Windows, Macintosh, and Unix. Nothing prevents you from adding data files to your plug-in. For instance, your plugin_Queak directory could contain a subdirectory sounds full of guinea pig recordings, and you could make them available in the New or Open menu. Using a plug-in for site-wide customization If your local guinea pig research group shares a number of Praat scripts, these can be made available to everybody in the following way: 1. Create a script that adds buttons to the fixed and dynamic menus, using the commands Add menu command... and Add action command.... This script could be a slightly edited copy of someone's buttons file. 2. Put this script where everybody can see it, for instance in U:\MaldenGuineaPigResearchButtons.praat, where U is your shared computer. 3. Create a file setup.praat that contains only the following line: runScript: U:\MaldenGuineaPigResearchButtons.praat 4. Put the setup.praat file in a new directory called plugin_MaldenGuineaPigResearch, and distribute this directory among your local colleagues. This procedure allows all members of the group to automatically enjoy all the later changes in your custom command set. Links to this page Add to dynamic menu... Add to fixed menu... ButtonEditor Hidden commands initialization script plugins Programming with Praat What was new in 4.5? 
plugins	plugins See plug-ins. 
PointEditor	PointEditor One of the Editors in Praat, for viewing and manipulating a PointProcess object, which is optionally shown together with a Sound object. Objects The editor shows: • The Sound, if you selected a Sound object together with the PointProcess object before you clicked View & Edit. • The PointProcess; vertical blue lines represent the points. Playing To play (a part of) the resynthesized sound (pulse train): click on any of the 8 buttons below and above the drawing area, or choose a Play command from the View menu. To play the original sound instead, use Shift-click. Adding a point Click at the desired time location, and choose Add point at cursor or type Command-P. Removing points To remove one or more points, make a time selection and choose Remove point(s) from the Point menu. If there is no selection, the point nearest to the cursor is removed. Links to this page Types of objects 
PointProcess	PointProcess One of the types of objects in Praat. A PointProcess object represents a point process, which is a sequence of points ti in time, defined on a domain [tmin, tmax]. The index i runs from 1 to the number of points. The points are sorted by time, i.e. ti+1 > ti. PointProcess commands Creation from scratch: • Create empty PointProcess... • Create Poisson process... Creation of a pulse train from a pitch contour: • PitchTier: To PointProcess: area-1 along entire time domain. • Pitch: To PointProcess: same, but excludes voiceless intervals. • Sound & Pitch: To PointProcess (cc): pitch-synchronous: near locations of high amplitude. • Sound & Pitch: To PointProcess (peaks)...: pitch-synchronous: near locations of high amplitude. • Sound: To PointProcess (periodic, cc)...: near locations of high amplitude. • Sound: To PointProcess (periodic, peaks)...: near locations of high amplitude. Creation from converting another object: • Matrix: To PointProcess • PitchTier: Down to PointProcess • IntensityTier: Down to PointProcess Hearing: • PointProcess: Play: pulse train. • PointProcess: Hum: pulse train with formants. Drawing: • PointProcess: Draw... Editing: • PointProcess: View & Edit: invokes a PointEditor. • PointProcess & Sound: View & Edit: invokes a PointEditor. • Inside a ManipulationEditor. Queries: • PointProcess: Get jitter (local)...: periodic jitter. • PointProcess: Get jitter (local, absolute)...: periodic jitter. • PointProcess: Get jitter (rap)...: periodic jitter. • PointProcess: Get jitter (ppq5)...: periodic jitter. • PointProcess: Get jitter (ddp)...: periodic jitter. • PointProcess: Get low index...: index of nearest point not after specified time. • PointProcess: Get high index...: index of nearest point not before specified time. • PointProcess: Get nearest index...: index of point nearest to specified time. • PointProcess: Get interval...: duration of interval around specified time. Set calculations: • PointProcesses: Union: the union of two point processes. • PointProcesses: Intersection: the intersection of two point processes. • PointProcesses: Difference: the difference of two point processes. Modification: • PointProcess: Add point...: at a specified time. • PointProcess: Remove point...: at specified index. • PointProcess: Remove point near...: near specified time. • PointProcess: Remove points...: between specified indices. • PointProcess: Remove points between...: between specified times. Analysis: • PointProcess: To PitchTier...: pitch values in interval centres. • PointProcess & Sound: To Manipulation Synthesis: • PointProcess: To Sound (pulse train)... • PointProcess: To Sound (hum)... Conversion: • PointProcess: To Matrix • PointProcess: Up to TextGrid... • PointProcess: Up to PitchTier... • PointProcess: Up to IntensityTier... Links to this page Formulas 7. Attributes of objects Intensity & PointProcess: To IntensityTier... Manipulation Manipulation: Extract pulses Manipulation: Replace pulses Pitch & PointProcess: To PitchTier... Play PointProcess: To Sound (phonation)... PointProcess: To TextGrid (vuv)... PointProcess: To TextGrid... Source-filter synthesis 1. Creating a source from pitch targets time domain Voice 6. Automating voice analysis with a script What was new in 3.6? 
PointProcess__Add_point___	PointProcess: Add point... A command to add a point to each selected PointProcess. Setting Time (s) the time at which a point is to be added. Behaviour The point process is modified so that it contains the new point. If a point at the specified time was already present in the point process, nothing happens. 
PointProcess__Draw___	PointProcess: Draw... A command to draw every selected PointProcess into the Picture window. 
PointProcess__Get_high_index___	PointProcess: Get high index... A query to the selected PointProcess object. Return value the index of the nearest point at or after the specified time, 0 if the point process contains no points, or a number higher than the number of points if the specified time is after the last point. Setting Time (s) the time from which a point is looked for, in seconds. 
PointProcess__Get_interval___	PointProcess: Get interval... A query to the selected PointProcess object. Return value the duration of the interval around a specified time. if the point process contains no points or if the specified time falls before the first point or not before the last point, the value is undefined. Otherwise, the result is the distance between the nearest points to the left and to the right of the specified time. If the point process happens to contain a point at exactly the specified time, the duration of the interval following this point is returned. Setting Time (s) the time around which a point is looked for, in seconds. 
PointProcess__Get_jitter__ddp____	PointProcess: Get jitter (ddp)... A command that becomes available in the Query submenu when you select a PointProcess object. This command will write into the Info window the Difference of Differences of Periods, a jitter measure defined as the average absolute difference between the consecutives differences between consecutive intervals, divided by the average interval (an interval is the time between two consecutive points). As jitter is often used as a measure of voice quality (see Voice 2. Jitter), the intervals are often considered to be glottal periods. For this reason, the command has settings that can limit the possible duration of the interval (or period) or the possible difference in the durations of consecutive intervals (periods). 1. The command window Time range (s) the start time and end time of the part of the PointProcess that will be measured. Points outside this range will be ignored. Period floor (s) the shortest possible interval that will be used in the computation of jitter, in seconds. If an interval is shorter than this, it will be ignored in the computation of jitter (and the previous and next intervals will not be regarded as consecutive). This setting will normally be very small, say 0.1 ms. Period ceiling (s) the longest possible interval that will be used in the computation of jitter, in seconds. If an interval is longer than this, it will be ignored in the computation of jitter (and the previous and next intervals will not be regarded as consecutive). For example, if the minimum frequency of periodicity is 50 Hz, set this argument to 0.02 seconds; intervals longer than that could be regarded as voiceless stretches and will be ignored in the computation. Maximum period factor the largest possible difference between consecutive intervals that will be used in the computation of jitter. If the ratio of the durations of two consecutive intervals is greater than this, this pair of intervals will be ignored in the computation of jitter (each of the intervals could still take part in the computation of jitter in a comparison with its neighbour on the other side). 2. Usage The jitter can be used as a measure of voice quality. See Voice 2. Jitter. 3. Algorithm (In the following the term absolute means two different things: (1) the absolute (i.e. non-negative) value of a real number, and (2) the opposite of relative.) DDP is defined as the relative mean absolute (i.e. non-negative) third-order difference of the point process (= the second-order difference of the interval process), as follows. First, we define the absolute (i.e. non-relative) Average Perturbation (in seconds) as one third of the mean absolute (non-negative) difference of difference of consecutive intervals: absDDP(seconds) = ∑i=2N-1 |(Ti+1 - Ti) - (Ti - Ti-1)| / (N - 2) where Ti is the duration of the ith interval and N is the number of intervals. If an interval Ti-1 or Ti or Ti+1 is not between Period floor and Period ceiling, or if Ti-1/Ti or Ti/Ti-1 or Ti+1/Ti or Ti/Ti+1 is greater than Maximum period factor, the term |2Ti - Ti-1 - Ti+1| is not counted in the sum, and N is lowered by 1 (if N ends up being less than 3, the result of the command is undefined). Second, we define the mean period as meanPeriod(seconds) = ∑i=1N Ti / N where Ti is the duration of the ith interval and N is the number of intervals. If an interval Ti is not between Period floor and Period ceiling, or if Ti-1/Ti or Ti/Ti-1 is greater than Maximum period factor and Ti+1/Ti or Ti/Ti+1 is greater than Maximum period factor, the term Ti is not counted in the sum, and N is lowered by 1; this procedure ensures that in the computation of the mean period we use at least all the intervals that had taken part in the computation of DDP. Finally, we compute DDP as DDP = absDDP(seconds) / meanPeriod(seconds) The result is exactly 3 times the RAP jitter measurement: a value between 0 and 6, or between 0 and 600 percent. 
PointProcess__Get_jitter__local____	PointProcess: Get jitter (local)... A command that becomes available in the Query submenu when you select a PointProcess object. This command will write into the Info window the local jitter, which is the average absolute difference between consecutive intervals, divided by the average interval (an interval is the time between two consecutive points). As jitter is often used as a measure of voice quality (see Voice 2. Jitter), the intervals are often considered to be glottal periods. For this reason, the command has settings that can limit the possible duration of the interval (or period) or the possible difference in the durations of consecutive intervals (periods). 1. The command window Time range (s) the start time and end time of the part of the PointProcess that will be measured. Points outside this range will be ignored. Period floor (s) the shortest possible interval that will be used in the computation of jitter, in seconds. If an interval is shorter than this, it will be ignored in the computation of jitter (and the previous and next intervals will not be regarded as consecutive). This setting will normally be very small, say 0.1 ms. Period ceiling (s) the longest possible interval that will be used in the computation of jitter, in seconds. If an interval is longer than this, it will be ignored in the computation of jitter (and the previous and next intervals will not be regarded as consecutive). For example, if the minimum frequency of periodicity is 50 Hz, set this setting to 0.02 seconds; intervals longer than that could be regarded as voiceless stretches and will be ignored in the computation. Maximum period factor the largest possible difference between consecutive intervals that will be used in the computation of jitter. If the ratio of the durations of two consecutive intervals is greater than this, this pair of intervals will be ignored in the computation of jitter (each of the intervals could still take part in the computation of jitter in a comparison with its neighbour on the other side). 2. Usage The local jitter can be used as a measure of voice quality; it is the most common jitter measurement and is usually expressed as a percentage. See Voice 2. Jitter. 3. Algorithm (In the following the term absolute means two different things: (1) the absolute (i.e. non-negative) value of a real number, and (2) the opposite of relative.) The local jitter is defined as the relative mean absolute second-order difference of the point process (= the first-order difference of the interval process), as follows. First, we define the absolute (non-relative) local jitter (in seconds) as the mean absolute (non-negative) difference of consecutive intervals: jitter(seconds) = ∑i=2N |Ti - Ti-1| / (N - 1) where Ti is the duration of the ith interval and N is the number of intervals. If an interval Ti-1 or Ti is not between Period floor and Period ceiling, or if Ti-1/Ti or Ti/Ti-1 is greater than Maximum period factor, the term |Ti - Ti-1| is not counted in the sum, and N is lowered by 1 (if N ends up being less than 2, the result of the command is undefined). Second, we define the mean period as meanPeriod(seconds) = ∑i=1N Ti / N where Ti is the duration of the ith interval and N is the number of intervals. If an interval Ti is not between Period floor and Period ceiling, or if Ti-1/Ti or Ti/Ti-1 is greater than Maximum period factor and Ti+1/Ti or Ti/Ti+1 is greater than Maximum period factor, the term Ti is not counted in the sum, and N is lowered by 1; this procedure ensures that in the computation of the mean period we use at least all the intervals that had taken part in the computation of the absolute local jitter. Finally, we compute the (relative) local jitter as jitter = jitter(seconds) / meanPeriod(seconds) The result is a value between 0 and 2, or between 0 and 200 percent. Links to this page Advanced pulses settings... PointProcess: Get jitter (rap)... 
PointProcess__Get_jitter__local__absolute____	PointProcess: Get jitter (local, absolute)... A command that becomes available in the Query submenu when you select a PointProcess object. This command will write into the Info window the absolute local jitter, which is the average absolute difference between consecutive intervals, in seconds (an interval is the time between two consecutive points). As jitter is often used as a measure of voice quality (see Voice 2. Jitter), the intervals are often considered to be glottal periods. For this reason, the command has settings that can limit the possible duration of the interval (or period) or the possible difference in the durations of consecutive intervals (periods). 1. The command window Time range (s) the start time and end time of the part of the PointProcess that will be measured. Points outside this range will be ignored. Period floor (s) the shortest possible interval that will be used in the computation of jitter, in seconds. If an interval is shorter than this, it will be ignored in the computation of jitter (and the previous and next intervals will not be regarded as consecutive). This setting will normally be very small, say 0.1 ms. Period ceiling (s) the longest possible interval that will be used in the computation of jitter, in seconds. If an interval is longer than this, it will be ignored in the computation of jitter (and the previous and next intervals will not be regarded as consecutive). For example, if the minimum frequency of periodicity is 50 Hz, set this argument to 0.02 seconds; intervals longer than that could be regarded as voiceless stretches and will be ignored in the computation. Maximum period factor the largest possible difference between consecutive intervals that will be used in the computation of jitter. If the ratio of the durations of two consecutive intervals is greater than this, this pair of intervals will be ignored in the computation of jitter (each of the intervals could still take part in the computation of jitter in a comparison with its neighbour on the other side). 2. Usage The local jitter can be used as a measure of voice quality. See Voice 2. Jitter. 3. Algorithm The absolute local jitter is defined as the absolute (i.e. non-relative) mean absolute (i.e. non-negative) second-order difference of the point process (= the first-order difference of the interval process), as follows. The absolute local jitter (in seconds) is the mean absolute (non-negative) difference of consecutive intervals: jitter(seconds) = ∑i=2N |Ti - Ti-1| / (N - 1) where Ti is the duration of the ith interval and N is the number of intervals. If an interval Ti-1 or Ti is not between Period floor and Period ceiling, or if Ti-1/Ti or Ti/Ti-1 is greater than Maximum period factor, the term |Ti - Ti-1| is not counted in the sum, and N is lowered by 1 (if N ends up being less than 2, the result of the command is undefined). 
PointProcess__Get_jitter__ppq5____	PointProcess: Get jitter (ppq5)... A command that becomes available in the Query submenu when you select a PointProcess object. This command will write into the Info window the five-point Period Perturbation Quotient, a jitter measure defined as the average absolute difference between an interval and the average of it and its four closest neighbours, divided by the average interval (an interval is the time between two consecutive points). As jitter is often used as a measure of voice quality (see Voice 2. Jitter), the intervals are often considered to be glottal periods. For this reason, the command has settings that can limit the possible duration of the interval (or period) or the possible difference in the durations of consecutive intervals (periods). 1. The command window Time range (s) the start time and end time of the part of the PointProcess that will be measured. Points outside this range will be ignored. Period floor (s) the shortest possible interval that will be used in the computation of jitter, in seconds. If an interval is shorter than this, it will be ignored in the computation of jitter (and the previous and next intervals will not be regarded as consecutive). This setting will normally be very small, say 0.1 ms. Period ceiling (s) the longest possible interval that will be used in the computation of jitter, in seconds. If an interval is longer than this, it will be ignored in the computation of jitter (and the previous and next intervals will not be regarded as consecutive). For example, if the minimum frequency of periodicity is 50 Hz, set this argument to 0.02 seconds; intervals longer than that could be regarded as voiceless stretches and will be ignored in the computation. Maximum period factor the largest possible difference between consecutive intervals that will be used in the computation of jitter. If the ratio of the durations of two consecutive intervals is greater than this, this pair of intervals will be ignored in the computation of jitter (each of the intervals could still take part in the computation of jitter in a comparison with its neighbour on the other side). 2. Usage The jitter can be used as a measure of voice quality. See Voice 2. Jitter. 3. Algorithm The five-point Period Perturbation Quotient (PPQ5) is defined in terms of five consecutive intervals, as follows. First, we define the absolute (i.e. non-relative) PPQ5 (in seconds): absPPQ5(seconds) = ∑i=3N-2 |Ti - (Ti-2 + Ti-1 + Ti + Ti+1 + Ti+2) / 5| / (N - 4) where Ti is the duration of the ith interval and N is the number of intervals. If an interval Ti-2 or Ti-1 or Ti or Ti+1 or Ti+2 is not between Period floor and Period ceiling, or if Ti-2/Ti-1 or Ti-1/Ti-2 or Ti-1/Ti or Ti/Ti-1 or Ti+1/Ti or Ti/Ti+1 or Ti+2/Ti+1 or Ti+1/Ti+2 is greater than Maximum period factor, the term |Ti - (Ti-2 + Ti-1 + Ti + Ti+1 + Ti+2) / 5| is not counted in the sum, and N is lowered by 1 (if N ends up being less than 5, the result of the command is undefined). Second, we define the mean period as meanPeriod(seconds) = ∑i=1N Ti / N where Ti is the duration of the ith interval and N is the number of intervals. If an interval Ti is not between Period floor and Period ceiling, or if Ti-1/Ti or Ti/Ti-1 is greater than Maximum period factor and Ti+1/Ti or Ti/Ti+1 is greater than Maximum period factor, the term Ti is not counted in the sum, and N is lowered by 1; this procedure ensures that in the computation of the mean period we use at least all the intervals that had taken part in the computation of the absolute PPQ5. Finally, we compute the five-point Period Perturbation Quotient as PPQ5 = PPQ5(seconds) / meanPeriod(seconds) The result is a value between 0 and 4, or between 0 and 400 percent. 
PointProcess__Get_jitter__rap____	PointProcess: Get jitter (rap)... A command that becomes available in the Query submenu when you select a PointProcess object. This command will write into the Info window the Relative Average Perturbation (RAP), a jitter measure defined as the average absolute difference between an interval and the average of it and its two neighbours, divided by the average interval (an interval is the time between two consecutive points). As jitter is often used as a measure of voice quality (see Voice 2. Jitter), the intervals are often considered to be glottal periods. For this reason, the command has settings that can limit the possible duration of the interval (or period) or the possible difference in the durations of consecutive intervals (periods). 1. The command window Time range (s) the start time and end time of the part of the PointProcess that will be measured. Points outside this range will be ignored. Period floor (s) the shortest possible interval that will be used in the computation of jitter, in seconds. If an interval is shorter than this, it will be ignored in the computation of jitter (and the previous and next intervals will not be regarded as consecutive). This setting will normally be very small, say 0.1 ms. Period ceiling (s) the longest possible interval that will be used in the computation of jitter, in seconds. If an interval is longer than this, it will be ignored in the computation of jitter (and the previous and next intervals will not be regarded as consecutive). For example, if the minimum frequency of periodicity is 50 Hz, set this argument to 0.02 seconds; intervals longer than that could be regarded as voiceless stretches and will be ignored in the computation. Maximum period factor the largest possible difference between consecutive intervals that will be used in the computation of jitter. If the ratio of the durations of two consecutive intervals is greater than this, this pair of intervals will be ignored in the computation of jitter (each of the intervals could still take part in the computation of jitter in a comparison with its neighbour on the other side). 2. Usage The RAP can be used as a measure of voice quality; it is the second most common jitter measurement (after local jitter). See Voice 2. Jitter. 3. Algorithm Relative Average Perturbation is defined in terms of three consecutive intervals, as follows. First, we define the absolute (i.e. non-relative) Average Perturbation (in seconds): absAP(seconds) = ∑i=2N-1 |Ti - (Ti-1 + Ti + Ti+1) / 3| / (N - 2) where Ti is the duration of the ith interval and N is the number of intervals. If an interval Ti-1 or Ti or Ti+1 is not between Period floor and Period ceiling, or if Ti-1/Ti or Ti/Ti-1 or Ti+1/Ti or Ti/Ti+1 is greater than Maximum period factor, the term |Ti - (Ti-1 + Ti + Ti+1) / 3| is not counted in the sum, and N is lowered by 1 (if N ends up being less than 3, the result of the command is undefined). Second, we define the mean period as meanPeriod(seconds) = ∑i=1N Ti / N where Ti is the duration of the ith interval and N is the number of intervals. If an interval Ti is not between Period floor and Period ceiling, or if Ti-1/Ti or Ti/Ti-1 is greater than Maximum period factor and Ti+1/Ti or Ti/Ti+1 is greater than Maximum period factor, the term Ti is not counted in the sum, and N is lowered by 1; this procedure ensures that in the computation of the mean period we use at least all the intervals that had taken part in the computation of the absolute average perturbation. Finally, we compute the Relative Average Perturbation as RAP = absAP(seconds) / meanPeriod(seconds) The result is a value between 0 and 2, or between 0 and 200 percent. Links to this page PointProcess: Get jitter (ddp)... 
PointProcess__Get_low_index___	PointProcess: Get low index... A query to the selected PointProcess object. Return value the index of the nearest point before or at the specified time, or 0 if the point process contains no points or the specified time is before the first point. Setting Time (s) the time from which a point is looked for, in seconds. 
PointProcess__Get_nearest_index___	PointProcess: Get nearest index... A query to the selected PointProcess object. Return value the index of the point nearest to the specified time, or 0 if the point process contains no points. Setting Time (s) the time around which a point is looked for, in seconds. 
PointProcess__Hum	PointProcess: Hum A command to hear a PointProcess. Algorithm A Sound is created with the algorithm described at PointProcess: To Sound (hum).... This sound is then played. 
PointProcess__Play	PointProcess: Play A command to hear a PointProcess. Algorithm A Sound is created with the algorithm described at PointProcess: To Sound (pulse train).... This sound is then played. 
PointProcess__Remove_point___	PointProcess: Remove point... A command to remove a point from every selected PointProcess. Setting Index the index of the point that is to be removed. Behaviour Does nothing if index is less than 1 or greater than the number of points nt in the point process. Otherwise, one point is removed (e.g., if index is 3, the third point is removed), and the other points stay the same. 
PointProcess__Remove_point_near___	PointProcess: Remove point near... A command to remove a point from every selected PointProcess. Setting Time (s) the time (in seconds) around which a point is to be removed. Behaviour Does nothing if there are no points in the point process. Otherwise, the point nearest to time is removed, and the other points stay the same. 
PointProcess__Remove_points___	PointProcess: Remove points... A command to remove a range of points from every selected PointProcess. Settings From index (≥ 1) the first index of the range of points that are to be removed. To index the last index of the range of points that are to be removed. Behaviour All points that originally fell in the range [fromIndex, toIndex] are removed, and the other points stay the same. 
PointProcess__Remove_points_between___	PointProcess: Remove points between... A command to remove a range of points from every selected PointProcess. Settings From time (s) the start of the domain from which all points are to be removed. To time (s) the end of the domain from which all points are to be removed. Behaviour All points that originally fell in the domain [fromTime, toTime], including the edges, are removed, and the other points stay the same. Links to this page Source-filter synthesis 1. Creating a source from pitch targets 
PointProcess__To_PitchTier___	PointProcess: To PitchTier... A command to compute a PitchTier from a PointProcess. Setting Maximum interval (s) the maximum duration of a period; intervals longer than this are considered voiceless. Algorithm A pitch point is constructed between each consecutive pair of points in the PointProcess, if these are more than maximumInterval apart. The associated pitch value will be the inverse of the duration of the interval between the two points. 
PointProcess__To_Sound__hum____	PointProcess: To Sound (hum)... A command to convert every selected PointProcess into a Sound. Algorithm A Sound is created with the algorithm described at PointProcess: To Sound (pulse train).... This sound is then run through a sequence of second-order filters that represent five formants. Links to this page PointProcess: Hum 
PointProcess__To_Sound__phonation____	PointProcess: To Sound (phonation)... A command to convert every selected PointProcess into a Sound. Algorithm A glottal waveform is generated at every point in the point process. Its shape depends on the settings power1 and power2 according to the formula U(x) = xpower1 - xpower2 where x is a normalized time that runs from 0 to 1 and U(x) is the normalized glottal flow in arbitrary units (the real unit is m3/s). If power1 = 2.0 and power2 = 3.0, the glottal flow shape is that proposed by Rosenberg (1971), upon which for instance the Klatt synthesizer is based (Klatt & Klatt (1990)): If power1 = 3.0 and power2 = 4.0, the glottal flow shape starts somewhat smoother, reflecting the idea that the glottis opens like a zipper: For the generation of speech sounds, we do not take the glottal flow itself, but rather its derivative (this takes into account the influence of radiation at the lips). The glottal flow derivative is given by dU(x)/dx = power1 x(power1-1) - power2 x(power2-1) The flow derivative clearly shows the influence of the smoothing mentioned above. The unsmoothed curve, with power1 = 2.0 and power2 = 3.0, looks like: Unlike the unsmoothed curve, the smoothed curve, with power1 = 3.0 and power2 = 4.0, starts out horizontally: Another setting is the open phase. If it is 0.70, the glottis will be open during 70 percent of a period. Suppose that the PointProcess has a pulse at time 0, at time 1, at time 2, and so on. The pulses at times 1 and 2 will then be turned into glottal flows starting at times 0.30 and 1.30: The final setting that influences the shape of the glottal flow is the collision phase. If it is 0.03, for instance, the glottal flow derivative will not go abruptly to 0 at a pulse, but will instead decay by a factor of e (≈ 2.7183) every 3 percent of a period. In order to keep the glottal flow curve smooth (and the derivative continuous), the basic shape discussed above has to be shifted slightly to the right and truncated at the time of the pulse, to be replaced there with the exponential decay curve; this also makes sure that the average of the derivative stays zero, as it was above (i.e. the area under the positive part of the curve equals the area above the negative part). This is what the curves look like if power1 = 3.0, power2 = 4.0, openPhase = 0.70 and collisionPhase = 0.03: These curves have moved 2.646 percent of a period to the right. At time 1, the glottal flow curve turns from a convex polynomial into a concave exponential, and the derivative still has its minimum there. Settings Sampling frequency (Hz) the sampling frequency of the resulting Sound object, e.g. 44100 hertz. Adaptation factor the factor by which a pulse height will be multiplied if the pulse time is not within Maximum period from the previous pulse, and by which a pulse height will again be multiplied if the previous pulse time is not within Maximum period from the pre-previous pulse. This factor is against abrupt starts of the pulse train after silences, and is 1.0 if you do want abrupt starts after silences. Maximum period (s) the minimal period that will be considered a silence, e.g. 0.05 seconds. Example: if Adaptation factor is 0.6, and Adaptation time is 0.02 s, then the heights of the first two pulses after silences of at least 20 ms will be multiplied by 0.36 and 0.6, respectively. Links to this page KlattGrid Source-filter synthesis 1. Creating a source from pitch targets What was new in 5.3? 
PointProcess__To_Sound__pulse_train____	PointProcess: To Sound (pulse train)... A command to convert every selected PointProcess into a Sound. Algorithm A pulse is generated at every point in the point process. This pulse is filtered at the Nyquist frequency of the resulting Sound by converting it into a sampled sinc function. Settings Sampling frequency (Hz) the sampling frequency of the resulting Sound object, e.g. 44100 hertz. Adaptation factor the factor by which a pulse height will be multiplied if the pulse time is not within Adaptation time from the pre-previous pulse, and by which a pulse height will again be multiplied if the pulse time is not within Adaptation time from the previous pulse. This factor is against abrupt starts of the pulse train after silences, and is 1.0 if you do want abrupt starts after silences. Adaptation time (s) the minimal period that will be considered a silence, e.g. 0.05 seconds. Interpolation depth the extent of the sinc function to the left and to the right of the peak, e.g. 2000 samples. Example: if Adaptation factor is 0.6, and Adaptation time is 0.02 s, then the heights of the first two pulses after silences of at least 20 ms will be multiplied by 0.36 and 0.6, respectively. Links to this page PointProcess: Play PointProcess: To Sound (hum)... 
PointProcess__To_TextGrid___	PointProcess: To TextGrid... A command to create an empty TextGrid from every selected PointProcess. The only information in the PointProcess that is used, is its starting and finishing times. Settings Tier names a list of the names of the tiers that you want to create, separated by spaces. Point tiers a list of the names of the tiers that you want to be point tiers; the rest of the tiers will be interval tiers. Example If Tier names is a b c, and Point tiers is b, the resulting TextGrid object will contain an interval tier named a, a point tier named b, and another interval tier named c. 
PointProcess__To_TextGrid__vuv____	PointProcess: To TextGrid (vuv)... A command to create a TextGrid with voiced/unvoiced information from every selected PointProcess. Settings Maximum period (s) the maximum interval that will be consider part of a larger voiced interval. Mean period (s) half of this value will be taken to be the amount to which a voiced interval will extend beyond its initial and final points. Mean period should be less than Maximum period, or you may get intervals with negative durations. Example If Maximum period is 0.02 s, and Mean period is 0.01 s, and the point process is 0.1 seconds long, with points at 20, 28, 39, 61, and 72 milliseconds, the resulting TextGrid object will contain an interval tier with U intervals at [0 ms, 15 ms], [44 ms, 56 ms], and [77 ms, 100 ms], and V intervals at [15 ms, 44 ms] and [56 ms, 77 ms]. Links to this page What was new in 3.7? 
PointProcess__Up_to_IntensityTier___	PointProcess: Up to IntensityTier... A command to promote every selected PointProcess to an IntensityTier. Setting Intensity (dB) the intensity that will be associated with every point. Behaviour The times of all the points are trivially copied, and so is the time domain. The intensity information will be the same for every point. 
PointProcess__Up_to_PitchTier___	PointProcess: Up to PitchTier... A command to promote every selected PointProcess to a PitchTier. Setting Frequency (Hz) the pitch frequency that will be associated with every point. Behaviour The times of all the points are trivially copied, and so is the time domain. The pitch information will be the same for every point. 
PointProcess__Up_to_TextGrid___	PointProcess: Up to TextGrid... A command to promote every selected PointProcess to a TextGrid with a single text tier in it. Setting Text the text that will be placed in every point. Behaviour The times of all the points are trivially copied, and so is the time domain. The text information will be the same for every point. 
PointProcesses__Difference	PointProcesses: Difference A command to compute the difference of two selected PointProcess objects. Behaviour The resulting PointProcess will contain only those points of the first selected original point process that do not occur in the second. The time domain of the resulting point process is equal to the time domain of the first original point process. 
PointProcesses__Intersection	PointProcesses: Intersection A command to merge two selected PointProcess objects into one. Behaviour The resulting PointProcess will contain only those points that occur in both original point processes. The time domain of the resulting point process is the intersection of the time domains of the original point processes. 
PointProcesses__Union	PointProcesses: Union A command to merge two selected PointProcess objects into one. Behaviour The resulting PointProcess will contain all the points of the two original point processes, sorted by time. Points that occur in both original point processes, will occur only once in the resulting point process. The time domain of the resulting point process is the union of the time domains of the original point processes. 
Pols_et_al___1973_	Pols et al. (1973) L.C.W. Pols, H.R.C. Tromp & R. Plomp (1973): Frequency analysis of Dutch vowels from 50 male speakers. Journal of the Acoustical Society of America 53: 1093–1101. Links to this page Canonical correlation analysis Create formant table (Pols & Van Nierop 1973) Create TableOfReal (Pols 1973)... Discriminant analysis 
Polygon	Polygon One of the types of objects in Praat. A Polygon object represents a sequence of points (xi, yi) in a two-dimensional space. Links to this page Create simple Polygon... DTW: To Polygon... Polygon: Rotate... Polygon: Simplify Polygon: Translate... Sound: To Polygon... What was new in 5.3? 
Polygon__Get_location_of_point___	Polygon: Get location of point... Determines whether a given point is on the Inside, the Outside, on an Edge or on a Vertex of the selected Polygon. Algorithm We determine how often a horizontal line extending from the point crosses the polygon. If the number of crossings is even, the point is on the outside, else on the inside. Special care is taken to be able to detect if a point is on the boundary of the polygon. The used algorithm is from Hormann & Agathos (2001) 
Polygon__Rotate___	Polygon: Rotate... Rotates the selected Polygon counterclockwise with respect to the given coordinates. 
Polygon__Simplify	Polygon: Simplify Removes collinear vertices from a Polygon. Example Given the Polygon with the seven vertices indicated by the red open circles, the Simplify action results in the Polygon with four vertices indicated by the filled black circles. 
Polygon__Translate___	Polygon: Translate... Translates the selected Polygon over the given vector. Given the old coordinates (xi, yi) and the translation (xt,yt), the new coordinates are: xi′ = xi + xt yi′ = yi + yt 
Polynomial	Polynomial One of the types of objects in PRAAT. An object of type Polynomial represents a polynomial function on a domain. A polynomial of degree n is defined as: p(x) = c1 + c2 x + c3 x2 + ... cn+1 xn. The real numbers ck are called the polynomial coefficients. Commands Creation Create Polynomial... (in the New menu) LPC: To Polynomial (slice)... (from prediction coefficients) LegendreSeries: To Polynomial ChebyshevSeries: To Polynomial Drawing Draw... Queries Get function value...: get p(x) Get coefficient value...: get ci Get minimum...: minimum of p(x) on an interval Get x of minimum... Get maximum...: maximum of p(x) on an interval Get x of maximum... Get area... Modification Set domain...: new domain Set coefficient value...: change one coefficient Conversion To Spectrum... (evaluation over unit-circle) To Polynomial (derivative) To Polynomial (primitive) To Roots: roots of polynomial Links to this page Polynomial: Scale x... Polynomials: Multiply Roots What was new in 3.9? 
Polynomial__Get_area___	Polynomial: Get area... A command to compute the area below the selected Polynomial object. Settings Xmin, Xmax define the interval. The area is defined as xmin∫xmax p(x) dx. 
Polynomial__Get_function_value___	Polynomial: Get function value... A command to compute p(x) for the selected Polynomial object. 
Polynomial__Get_maximum___	Polynomial: Get maximum... A command to compute, on a specified interval, the maximum value of the selected Polynomial object. 
Polynomial__Get_minimum___	Polynomial: Get minimum... A command to compute, on a specified interval, the minimum value of the selected Polynomial object. 
Polynomial__Get_x_of_maximum___	Polynomial: Get x of maximum... A command to compute, on a specified interval, the location of the maximum of the selected Polynomial object. 
Polynomial__Get_x_of_minimum___	Polynomial: Get x of minimum... A command to compute, on a specified interval, the location of the minimum of the selected Polynomial object. 
Polynomial__Scale_x___	Polynomial: Scale x... A command to transform the selected Polynomial object to a new domain. Xmin and Xmax define the new domain. Behaviour The polynomial is transformed from domain [xmin, xmax] to domain [Xmin, Xmax] in such a way that its form stays the same. This is accomplished by first calculating: f(x′) = Σk=1..numberOfCoefficients ck x′k, where x′ = a x + b, and then collecting terms of equal degree. The a and b are defined as a = (xmin – xmax) / (Xmin – Xmax) b = xmin – a Xmin 
Polynomial__To_Polynomial__derivative_	Polynomial: To Polynomial (derivative) A command to compute the derivative of the selected Polynomial object. 
Polynomial__To_Polynomial__primitive_	Polynomial: To Polynomial (primitive) A command to compute the primitive of the selected Polynomial object. 
Polynomial__To_Roots	Polynomial: To Roots A command to compute the roots of the selected Polynomial objects. Algorithm The roots are found from the polished eigenvalues of a special companion matrix. For further explanation on these methods see Press et al. (1992). 
Polynomial__To_Spectrum___	Polynomial: To Spectrum... A command to compute the spectrum of the selected Polynomial objects. Settings Nyquist frequency (Hz) defines the highest frequency in the spectrum. The lowest frequency of the spectrum will be 0 Hz. Number of frequencies defines the number of frequencies in the spectrum. Algorithm We calculate the spectrum by evaluating the polynomial at regularly spaced points zk on the upper half of a circle with radius r = 1 in the complex plane. The upperhalf of the unit circle, where k·φ is in the interval [0, π], will be mapped to frequencies [0, Nyquist frequency] in the spectrum. The complex values zk (k=1..numberOfFrequencies) are defined as: zk = r ei k φ, where, φ = π / (numberOfFrequencies – 1) and r = 1. 
Polynomials__Multiply	Polynomials: Multiply A command to multiply two polynomials with each other. The result of multiplying 1 + 2 x and 2 – x2 will be the polynomial: 2 + 4 x – x2 – 2 x3. 
PostScript_settings___	PostScript settings... One of the commands in the File menus of many windows. The PostScript settings influence Printing and saving to Encapsulated PostScript files. Settings Allow direct PostScript printing (Windows only) this determines whether Praat prints explicit PostScript commands to your printer if it is a PostScript printer. This is what you will usually want. However, if you find that some of the options that you choose in the Print window seem not to be supported (e.g. scaling, printing two-up...), you may switch this off; Praat will then send native Windows drawing commands, which the printer driver will try to translate to PostScript. If your printer does not support PostScript, this switch is ignored. On Macintosh, this switch is ignored, because all printingis done in PDF. On Unix, this switch is superfluous, because all printing is done directly in PostScript. Grey resolution you can choose from two image qualities: • the finest quality for grey plots (106 spots per inch), which gives the best results directly from the printer; • a photocopyable quality, which has fewer spots per inch (85) and gives the best results after photocopying. Your choice of the grey resolution influences direct PostScript printing and saving to Encapsulated PostScript files. Paper size (Unix only) you can choose from A4 (210 × 297 mm), A3 (297 × 420 mm) or US Letter (8.5 × 11″). This choice applies to Unix only; on Windows, you choose the paper size in the Print... window; on Macintosh, you choose the paper size in the Page setup... window. Orientation (Unix only) you can choose between portrait (e.g., 297 mm high and 210 mm wide) and landscape (e.g., 210 mm high and 297 mm wide). This choice applies to Unix only; on Windows, you choose the orientation in the Print... window; on Macintosh, you choose the orientation in the Page setup... window. Magnification (Unix only) the relative size with which your picture will be printed; normally 1.0. This choice applies to Unix only; on Windows, you choose the scaling in the Print... window; on Macintosh, you choose the scaling in the Page setup... window. Print command (Unix only) When printing on Unix, a temporary PostScript® file is created in the /tmp directory; it will have a name like picXXXXXX, and is automatically removed after printing. This file is sent to the printer with the print command, which will often look like lp -c %s, where %s stands for the file name. Links to this page Picture window Save as EPS file... 
power_spectral_density	power spectral density The average power in a sound during a certain time range and in a certain frequency range, expressed in Pa2/Hz. Mathematical definition The complex spectrum of a sound x(t) in the time range (t1, t2) is X(f) ≡ ∫t1t2 x(t) e-2πift dt for any frequency f in the two-sided frequency domain (-F, +F). If x(t) is expressed in units of Pascal, X(f) is expressed in units of Pa/Hz. In Praat, this complex spectrum is the quantity stored in a Spectrum. From the complex spectrum we can compute the one-sided power spectral density in Pa2/Hz as PSD(f) ≡ 2|X(f)|2 / (t2 - t1) where the factor 2 is due to adding the contributions from positive and negative frequencies. In Praat, this power spectral density is the quantity stored in a Spectrogram. The PSD divides up the total power of the sound. To see this, we integrate it over its entire one-sided frequency domain (0, F): ∫0F PSD(f) df = ∫0F 2|X(f)|2/(t2-t1) df = = 1/(t2-t1) ∫-F+F |X(f)|2 df = 1/(t2-t1) ∫t1t2 |x(t)|2 dt where the last step uses Parceval's theorem. The result is precisely the average power of the sound in the time range (t1, t2). The logarithmic power spectral density It is often useful to express the power spectral density in dB relative to Pref = 2·10-5 Pa: PSDdB(f) = 10 log10 { PSD(f) / Pref2 } Since the argument of the logarithm is in units of Hz-1, this spectral measure can loosely be said to be in units of `dB/Hz'. In Praat, this logarithmic power spectral density is the quantity stored in an Ltas; it is also the quantity shown in pictures of a Spectrum and a Spectrogram. 
PowerCepstrogram	PowerCepstrogram One of the types of objects in PRAAT. Description The PowerCepstrogram shows cepstral slices as a function of time. Links to this page PowerCepstrogram: Paint... PowerCepstrogram: Smooth... Sound: To PowerCepstrogram... 
PowerCepstrogram__Paint___	PowerCepstrogram: Paint... A command to draw the selected PowerCepstrogram object(s) in shades of grey. Settings Time range (s) the time domain along the x axis. Quefrency range (s) the quefency domain along the y axis. Maximum (dB) cells that have cepstral values greater or equal than this value are drawn in black. Autoscaling If on, overrules the effects of the previous option and the following three options. I.e. the global maximum and the global minimum cepstral values determine the maximum blackness and the minimal blackness. Values in-between have apropriate values of grey. Dynamic range (dB) All values more than Dynamic range below the maximum will be drawn in white. Values in-between have apropriate values of grey. Dynamic compression (0-1) determines how much stronger weak frames should be made before drawing. Normally this parameter is between 0 and 1. If it is 0, no dynamic compression will take place. If it is 1, all time frames (vertical bands) will contain cepstral values that are drawn in black. If the global maximum is set at 80 dB, autoscaling is off, dynamic range is 30 dB and dynamic compression is 0.4 then for a frame with a local maximum of 40 dB all values will be lifted by 0.4*(80-40)=16 dB, so that its maximum will be seen at 56 dB (thus making the corresponding cell visible). Garnish Draws a box around the cepstrogram and labels the axes. 
PowerCepstrogram__Smooth___	PowerCepstrogram: Smooth... Smoothes the selected PowerCepstrogram by averaging cepstra. The smoothed PowerCepstrogram is the result of two separate steps. In the first step, cepsta are averaged across time. In the second step, cepstra are averaged across quefrency. Settings Time averaging window (s) determines how many frames will used in the first step, averaging across time. The user-supplied value will be divided by the Cepstrograms's time step value (its dx). If numberOfFramesToAverage, the result of the division, turns out to be one or less, no averaging across time is performed. If numberOfFramesToAverage is larger than one and is even, one will be added. Each new cepstral frame will be the average of numberOfFramesToAverage frames of the input Cepstrogram. For example, if numberOfFramesToAverage turns out to be 5, then the j-th new cepstral frame is the result of averaging the 5 frames with indices j–2 , j–1, j, j+1 and j+2 for all frames j=3..numberOfFrames–2, i.e. besides frame j, the 2 frames on either side are used in the averaging. The numberOfFramesToAverage has to be uneven to allow for this symmetric behaviour. Quefrency averaging window (s) determines how many quefrency bins will be used for the averaging across quefrency step. The number of bins used in this step is the result of the division of the user-supplied value by the quefrency step value (the Cepstrogram's dy). If the result turns out to be one or less, no averaging across quefrencies is performed. If the resulting value is even, one will be added. If, for example, the result happens to be 3 then the value in quefrency bin k will be the average value of the values in quefrency bins k–1, k and k+1. Note The following commands should reproduce the smoothing described in the Hillenbrand & Houde (1996) article, where they use a 20 ms (10 frame) time smoothing and a 1 ms (10 bin) quefrency smoothing. selectObject (Sound xxx) To PowerCepstrogram: 0.041, 0.002, 5000.0 Smooth: 0.02, 0.001 
PowerCepstrogram__To_Table__peak_prominence____	PowerCepstrogram: To Table (peak prominence)... A command to create a table with cepstral peak prominence values. Settings The meaning of these settings is explained here. 
PowerCepstrum	PowerCepstrum One of the types of objects in PRAAT. Description A PowerCepstrum is the log power spectrum of the log power spectrum. The vertical scale will show the amplitude expressed in dB. The horizontal scale shows quefrency in units of seconds. Links to this page PowerCepstrogram 
PowerCepstrum__Draw_tilt_line___	PowerCepstrum: Draw tilt line... Draws the line that models the backgound of the power cepstrum. 
PowerCepstrum__Get_peak_prominence___	PowerCepstrum: Get peak prominence... Calculates the cepstral peak prominence measure (CPP) as defined by Hillenbrand et al. (1994) The CPP measure is the difference in amplitude between the cepstral peak and the corresponding value on the regression line that is directly below the peak (i.e., the predicted magnitude for the quefrency at the cepstral peak). The CPP measure represents how far the cepstral peak emerges from the cepstrum background. Settings Search peak in pitch range determine the limits of the quefrency range where a peak is searched for. The lower quefrency is determined as 1 / pitchCeiling and this value is in general more critical than the value of the upper quefrency which equals 1 / pitchFloor. A pitchCeiling of 300 Hz will correspond to a lower quefrency of 1/300≈0.0033 seconds. Interpolation determines how the amplitude of a peak is determined. Tilt line quefrency range the quefrency range for which the amplitudes (in dB) will be modelled by a straight line. The lower value for this range in the Hillenbrand article was chosen as 0.001 s in order to reduce the effect of the low quefrency data on the straight line fit. In our analysis this value is not so critical as we use a more robust straight line fit. Fit method the default method is Theil's robust line fit. However, to be compatible with the past, a standard least squares line fit has also been implemented. Note The CPP value does not depend on the reference value used in the dB calculation of the power cepstrum. Links to this page PowerCepstrogram: To Table (peak prominence)... 
Praat_menu	Praat menu The first menu in the Object window. On MacOS X, this menu is in the main menu bar. Links to this page Calculator... Formulas 1.1. Formulas in the calculator Formulas 1.9. Formulas in scripts Goodies New Praat script Open Praat script... Quit ScriptEditor Scripting 7.2. Scripting an editor from within Technical 
Praat_script	Praat script An executable text that consists of menu commands and action commands. See the Scripting tutorial. Links to this page Add to dynamic menu... Add to fixed menu... buttons file Formulas Formulas 1.9. Formulas in scripts Info window initialization script Open Praat script... ScriptEditor What was new in 3.6? What was new in 3.7? 
preferences_directory	preferences directory The Praat preferences directory is the directory where Praat saves the preferences file and the buttons file, and where you can install plug-ins and save the preferences of your scripts (in your subdirectory of the apps subdirectory). If the preferences directory does not exist, it will automatically be created when you start Praat. Unix If your home directory is /people/miep/, your Praat preferences directory will be /people/miep/.praat-dir/. Macintosh If you are user miep, your Praat preferences directory will be /Users/miep/Library/Preferences/Praat Prefs/. Windows If you are user Miep, your Praat preferences directory will be C:\Documents and Settings\Miep\Praat\. Links to this page Scripting 5.1. Variables 
preferences_file	preferences file The file into which some of your preferences are saved across your sessions with Praat. For instance, if you change the font used by the Picture window to Palatino and quit Praat, the Picture-window font will still be Palatino when you start Praat again. The preferences file is written to disk when you quit Praat, and it is read when you start Praat. It is a simple text file that you can read (but should not edit) with any text editor. Where is the preferences file? The preferences file is in your Praat preferences directory. On Unix the file is called prefs5, for instance /people/miep/.praat-dir/prefs5. On Macintosh it is called Prefs5, for instance /Users/miep/Library/Preferences/Praat Prefs/Prefs5. On Windows it is called Preferences5.ini, for instance C:\Documents and Settings\Miep\Praat\Preferences5.ini. Links to this page initialization script 
Press_et_al___1992_	Press et al. (1992) W.H. Press, S.A. Teukolsky, W.T. Vetterling & B.P. Flannery (1992): Numerical recipes in C: The art of scientific computing. Second Edition. Cambridge University Press. Links to this page FFNet & Pattern & Categories: Learn... LPC: To Formant Polynomial: To Roots Sound: To Formant (burg)... vector peak interpolation 
Prince___Smolensky__1993_	Prince & Smolensky (1993) Alan Prince & Paul Smolensky (1993): Optimality Theory: Constraint Interaction in Generative Grammar. Rutgers University Center for Cognitive Science Technical Report 2. Links to this page Optimality Theory OT learning 1. Kinds of grammars OT learning 3.2. Data from another grammar Smolensky & Legendre (2006) 
Principal_component_analysis	Principal component analysis This tutorial describes how you can perform principal component analysis with PRAAT. Principal component analysis (PCA) involves a mathematical procedure that transforms a number of (possibly) correlated variables into a (smaller) number of uncorrelated variables called principal components. The first principal component accounts for as much of the variability in the data as possible, and each succeeding component accounts for as much of the remaining variability as possible. 1. Objectives of principal component analysis To discover or to reduce the dimensionality of the data set. To identify new meaningful underlying variables. 2. How to start We assume that the multi-dimensional data have been collected in a TableOfReal data matrix, in which the rows are associated with the cases and the columns with the variables. Traditionally, principal component analysis is performed on the symmetric Covariance matrix or on the symmetric Correlation matrix. These matrices can be calculated from the data matrix. The covariance matrix contains scaled sums of squares and cross products. A correlation matrix is like a covariance matrix but first the variables, i.e. the columns, have been standardized. We will have to standardize the data first if the variances of variables differ much, or if the units of measurement of the variables differ. You can standardize the data in the TableOfReal by choosing Standardize columns. To perform the analysis, we select the TabelOfReal data matrix in the list of objects and choose To PCA. This results in a new PCA object in the list of objects. We can now make a scree plot of the eigenvalues, Draw eigenvalues... to get an indication of the importance of each eigenvalue. The exact contribution of each eigenvalue (or a range of eigenvalues) to the explained variance can also be queried: Get fraction variance accounted for.... You might also check for the equality of a number of eigenvalues: Get equality of eigenvalues.... 3. Determining the number of components There are two methods to help you to choose the number of components. Both methods are based on relations between the eigenvalues. Plot the eigenvalues, Draw eigenvalues.... If the points on the graph tend to level out (show an elbow), these eigenvalues are usually close enough to zero that they can be ignored. Limit the number of components to that number that accounts for a certain fraction of the total variance. For example, if you are satisfied with 95 of the total variance explained then use the number you get by the query Get number of components (VAF)... 0.95. 4. Getting the principal components Principal components are obtained by projecting the multivariate datavectors on the space spanned by the eigenvectors. This can be done in two ways: 1. Directly from the TableOfReal without first forming a PCA object: To Configuration (pca).... You can then draw the Configuration or display its numbers. 2. Select a PCA and a TableOfReal object together and choose To Configuration.... In this way you project the TableOfReal onto the PCA's eigenspace. 5. Mathematical background on principal component analysis The mathematical technique used in PCA is called eigen analysis: we solve for the eigenvalues and eigenvectors of a square symmetric matrix with sums of squares and cross products. The eigenvector associated with the largest eigenvalue has the same direction as the first principal component. The eigenvector associated with the second largest eigenvalue determines the direction of the second principal component. The sum of the eigenvalues equals the trace of the square matrix and the maximum number of eigenvectors equals the number of rows (or columns) of this matrix. 6. Algorithms If our starting point happens to be a symmetric matrix like the covariance matrix, we solve for the eigenvalue and eigenvectors by first performing a Householder reduction to tridiagonal form, followed by the QL algorithm with implicit shifts. If, conversely, our starting point is the data matrix A , we do not have to form explicitly the matrix with sums of squares and cross products, A′A. Instead, we proceed by a numerically more stable method, and form the singular value decomposition of A, U Σ V′. The matrix V then contains the eigenvectors, and the squared diagonal elements of Σ contain the eigenvalues. Links to this page Acknowledgments Configuration Intro Sound: To Sound (whiten channels)... Statistics Types of objects What was new in 3.9? What was new in 4.4? 
Print___	Print... One of the commands in the File menu of the Picture window. With this command, you send your entire picture immediately to the printer. See the Printing tutorial for details. Links to this page OT learning 2.7. Tableau pictures 
Printing	Printing 1a. Printing on Windows On Windows, the best results will be obtained on PostScript printers, since these have built-in facilities for images (e.g. spectrograms) and rotated text. If a PostScript printer is available, Praat will usually write direct PostScript commands to that printer (see PostScript settings... if you want to switch this off). Praat also supports non-PostScript printers, such as most colour inkjet printers. If you don't have a PostScript printer, and you still want PostScript quality, you can save the picture to an EPS file (Save as EPS file...). You can then view this file with the freely available GhostView™ program, which you can download from http://pages.cs.wisc.edu/~ghost/, or convert it to PDF with either GhostView or Adobe® Acrobat™ Distiller™, which is more reliable than GhostView but is also expensive. 1b. Printing on Macintosh On the Mac, Praat will print in PDF, both to PostScript and non-PostScript printers. 1c. Printing on Linux On Linux, when you tell Praat to print a picture or manual page, Praat will write the picture to a temporary PostScript file and send this file to a printer with the print command, which you can change with PostScript settings.... You do not need a PostScript printer to print PostScript directly, because the lpr program sends PostScript files through the GhostScript program, which is a part of all modern Linux distributions. The print command is typically lpr %s. By changing the print command (with PostScript settings...), you can change it to something fancier. For instance, if you want to save the woods and print two pages on one sheet of paper, you change it to cat %s | mpage -2 -o -f -m0 | lpr. 2. Indirect printing with your word processor If you save your picture to an EPS file, you will be able to include it as a picture in your favourite word processor (Microsoft® Word™, LaTeX...). See Save as EPS file.... On the Mac it is better to save your picture to a PDF file, which both Microsoft® Word™ (when using the .docx format) and LaTeX can process. See Save as PDF file.... 3. Indirect printing through the clipboard On Windows, pictures included in your word processor via Copy to clipboard or Save as Windows metafile... will print fine, though not as nicely as EPS files. On the Mac, pictures included in your word processor (post-2006 versions) via Copy to clipboard will print just as nicely as PDF files (use the .docx format in Microsoft Word). Links to this page Acknowledgments Intro Print... 
Procrustes	Procrustes One of the types of objects in PRAAT. An object of type Procrustes represents the special affine transform that consists of a combination of a translation, a shape preserving transformation and a scaling (this scaling is often called dilation). Because the transformation has to be shape preserving, only a combination of a rotation and a reflection is allowed. A configuration matrix X is transformed in the following way to a new configuration matrix Y: Y = s X T+ 1t', where s is the scaling factor, T is the shape preserving transformation matrix, t is the translation vector, and 1 is the vector with only ones as its elements. For more information about the Procrustes transform and its algorithm see chapter 19 in Borg & Groenen (1997). Links to this page Configuration & Configuration: To Procrustes... Configuration & Procrustes: To Configuration PCA & PCA: To Procrustes... 
Procrustes_transform	Procrustes transform A transformation that only uses a combination of a translation, a scaling and a rigid transformation to transform one Configuration such that it matches as closely as possible another Configuration. We speak of orthogonal Procrustes transform when only the rigid transformation is allowed but no scaling or translation. For more information about the Procrustes transform and its algorithm see chapter 19 in Borg & Groenen (1997). Links to this page Configuration & Configuration: To Procrustes... Configuration: To Configuration (procrustes) Configurations: To AffineTransform (congruence)... PCA & PCA: To Procrustes... 
Programming_with_Praat	Programming with Praat You can extend the functionality of the Praat program by adding modules written in C or C++ to it. All of Praat's source code is available under the General Public Licence. 1. Warning Before trying the task of learning how to write Praat extensions in C or C++, you should be well aware of the possibilities of scripting. Many built-in commands in Praat have started their lives as Praat scripts, and scripts are easier to write than extensions in C or C++. If you have a set of scripts, you can distribute them as a plug-in. 2. Getting the existing source code You obtain the Praat source code via www.praat.org, in a file with a name like praat5347_sources.zip or praat5347_sources.tar.gz (depending on the Praat version), and unpack this by double-clicking. The result will be a set of directories called kar, num, external (with GSL, glpk, FLAC, mp3, portaudio and espeak in it), sys, dwsys, stat, fon, dwtools, LPC, FFNet, gram, artsynth, EEG, contrib, main, makefiles, and test, plus a makefile and an Xcode project for Macintosh. 3. Building Praat on Macintosh Open praat.xcodeproj in Xcode and choose Build and Run. For more details see the download page. 4. Building Praat on Windows Praat for Windows is compiled with MinGW. See the download page for instructions. 5. Building Praat on Linux To compile and link Praat on Linux, you go to the directory that contains the source directories and the makefile, and copy a makefile.defs file from the makefiles directory: > cp makefiles/makefile.defs.linux ./makefile.defs You have to have installed libgtk2.0-dev (and its dependencies) and libasound2-dev. On other Unixes, you do the same, but the file makefile.defs may require some editing after this, because Silicon Graphics Irix, Sparc Solaris and HPUX may use different libraries or have them in different locations than Linux. 6. Extending Praat You can edit main/main_Praat.cpp. This example shows you how to create a very simple program with all the functionality of the Praat program, and a single bit more (namely an additional command in the New menu): #include praat.h DIRECT (HelloFromJane) Melder_information (LHello, I am Jane.); END int main (int argc, char **argv) { praat_init (Praat_Jane, argc, argv); INCLUDE_LIBRARY (praat_uvafon_init) praat_addMenuCommand (LObjects, LNew, LHello from Jane..., NULL, 0, DO_HelloFromJane); praat_run (); return 0; } 7. Learning how to program To see how objects are defined, take a look at sys/Thing.h, sys/Data.h, sys/oo.h, the XXX_def.h files in the fon directory, and the corresponding XXX.cpp files in the fon directory. To see how commands show up on the buttons in the fixed and dynamic menus, take a look at the large interface description file fon/praat_Fon.cpp. 8. Using the Praat shell only For building the Praat shell (the Objects and Picture windows) only, you need only the code in the eight directories kar, GSL, num, external/{FLAC,MP3,portaudio}, sys, and dwsys. You delete the inclusion of praat_uvafon_init from main. You will be able to build a Praat shell, i.e. an Objects and a Picture window, which has no knowledge of the world, i.e., which does not know any objects that can be included in the list of objects. You could use this Praat shell for modelling your own world and defining your own classes of objects. For advanced programmers only. Links to this page Scripting 9.1. Turning a script into a stand-alone program 
Proximity	Proximity One of the types of objects in PRAAT. An object of type Proximity represents proximities between objects. Inside a Proximity With Inspect you will see the following attributes: numberOfRows, numberOfColumns the number of objects (numberOfRows and numberOfColumns are equal and ≥1). rowLabels, columnLabels the names associated with the objects (rowLabels and columnLabels are equal. data [1..numberOfRows][1..numberOfColumns] the proximities between the objects. 
quantile_algorithm	quantile algorithm An algorithm to compute the specified quantile of a sorted array of real numbers. The n% quantile of a continuous real-valued distribution is the value below which n% of the values is expected to lie. If we are given an array of real numbers that we want to interpret as having been drawn from a distribution, we can estimate the quantiles of the underlying distribution. 1. The median The median is a special case of a quantile: it is the 50% quantile. It is usually estimated as follows: from an odd number of values, take the middle value; form an even number, take the average of the two midmost values. For instance, if our values are 15, 20, and 32, the median is 20; if our values are 15, 20, 32, and 60, the median is 26. This estimate is direction-independent: if we multiply all values by -1 (i.e., they become -60, -32, -20, and -15), the median is also multiplied by -1 (it becomes -26). 2. Percentiles? The nth percentile of a set of values is usually defined as the highest attested value for which at most n% of all attested values are less or equal. For instance, if our values are 15, 20, 32, and 60, the 30th percentile is 15. Here is an extensive list: Percentile numberValue 0- 10- 20- 3015 4015 5020 6020 7020 8032 9032 10060 However, this procedure does not yield an estimate of the quantiles of the underlying distribution. For instance, the estimate is direction-dependent: if we multiply all values by -1, the 50th percentile becomes -32 instead of -20, and the 70th percentile becomes -32 instead of the expected -15, which is minus the 30th percentile of the original data set. 3. Unbiased quantiles To get a better estimate of the quantiles of the underlying distribution, the interpolation that we used to determine the median, is generalized to any quantile. We assume that the attested values 15, 20, 32, and 60 each take up one quarter of the quantile space. These four values are in the middles of those quarters, so they are at the 0.125, 0.375, 0.625, and 0.875 quantiles. Quantiles in between 0.125 and 0.875 are evaluated by linear interpolation: the 0.25, 0.50, and 0.75 quantiles are 17.5, 26, and 46, respectively. Note that the 0.50 quantile is the median. The 0.40 quantile, for example, is estimated as 20 + (32 - 20)·(0.40 - 0.375)/(0.625 - 0.375) = 21.2. Quantiles between 0 and 0.125 or between 0.875 and 1 are evaluated by linear extrapolation from the lowest or highest pair of values: the 0% quantile is estimated as 15 - 1/2 (20 - 15) = 12.5, and the 100% quantile is estimated as 60 + 1/2 (60 – 32) = 74. The 0.10 quantile is estimated as 12.5 + (15 – 12.5)·(0.10 – 0.0)/(0.125 – 0.0) = 14.5. Note that the estimated values for the very low or high quantiles can lie outside the range of attested values. In fact, the computed 0% and 100% quantiles are thought to be estimates of the minimum and maximum values of the distribution. For uniform distributions, these estimates are reasonable; for a normal distribution, of course, the 0% and 100% quantiles are meaningless. Links to this page Formant: Get quantile... Table: Get median absolute deviation... 
Query	Query Query commands give you information about objects. Most query commands start with the word Get or sometimes the word Count. You will find these commands in two places: under the Query menu that usually appears if you select an object in the list, and in the Query menus of the editors. Behaviour If you click a query command, the answer will be written to the Info window. Scripting In a script, you can still use query commands to write the information to the Info window but you can also use any query command to put the information into a variable. (see Scripting 6.3. Query commands). In such a case, the value will not be written into the Info window. Query commands in the Praat program The Praat program contains the following query commands: Confusion: Get fraction correct DurationTier: Get target duration... Excitation: Get loudness FilterBank: Get frequency in Hertz... Formant: Get bandwidth at time... Formant: Get maximum... Formant: Get mean... Formant: Get minimum... Formant: Get number of formants Formant: Get quantile... Formant: Get standard deviation Formant: Get time of maximum... Formant: Get time of minimum... Formant: Get value at time... Formulas 7. Attributes of objects Get area... Get high index from time... Get low index from time... Get nearest index from time... Harmonicity: Get maximum... Harmonicity: Get mean... Harmonicity: Get minimum... Harmonicity: Get standard deviation... Harmonicity: Get time of maximum... Harmonicity: Get time of minimum... Harmonicity: Get value at time... Harmonicity: Get value in frame... Intensity: Get maximum... Intensity: Get mean... Intensity: Get minimum... Intensity: Get standard deviation... Intensity: Get time of maximum... Intensity: Get time of minimum... Intensity: Get value at time... Intensity: Get value in frame... Log files Ltas: Get bin number from frequency... Ltas: Get bin width Ltas: Get frequency from bin number... Ltas: Get frequency of maximum... Ltas: Get frequency of minimum... Ltas: Get highest frequency Ltas: Get lowest frequency Ltas: Get maximum... Ltas: Get mean... Ltas: Get minimum... Ltas: Get number of bins Ltas: Get standard deviation... Ltas: Get value at frequency... Ltas: Get value in bin... PitchTier: Get mean (curve)... PitchTier: Get mean (points)... PitchTier: Get standard deviation (curve)... PitchTier: Get standard deviation (points)... PointProcess: Get high index... PointProcess: Get interval... PointProcess: Get low index... PointProcess: Get nearest index... Sound: Get absolute extremum... Sound: Get energy in air Sound: Get energy... Sound: Get intensity (dB) 
Query_menu	Query menu One of the menus in most editors. Links to this page Get first formant Get pitch Get second formant 
Quit	Quit One of the commands in the Praat menu. Purpose To leave the program. Behaviour All objects not written to a file will be lost. However, file-based objects (like large lexica) will be saved correctly. Usage To save your data to a disk file before quitting, choose a command from the Save menu. Links to this page Object window 
Rabiner__1989_	Rabiner (1989) L.R. Rabiner (1989): A tutorial on Hidden Markov Models and selected applications in speech recognition. Proceedings of the IEEE 77: 257–286. Links to this page HMM 
Ramsay__1988_	Ramsay (1988) J.O. Ramsay (1988): Monotone regression splines in action. Statistical Science 3: 425–461. Links to this page MDS models spline 
Read_from_file___	Read from file... One of the commands in the Open menu. Purpose To read one or more objects from a file on disk. Behaviour Many kinds of files are recognized: 1. Text files that are structured as described under Save as text file...; these can contain an object of any type, or a collection of objects. 2. Files that were produced by Save as binary file... (any type). 3. Files in a LISP text format (only for object types that can be written to a LISP file). 4. Files that were made recognizable by the libraries built on Praat. For instance, the phonetics library adds recognizers for many kinds of sound files. If the file contains more than one object, these objects will appear in the list, and their names will be the same as the names that they had when they were saved with Save as text file... or Save as binary file.... Examples • If the file contains only one Pitch object and is called hallo.pit, an object with the name Pitch hallo will appear in the list of objects. You may have more objects with the same name. • If the file contains one object of type Pitch, named hallo, and one object of type Polygon, named kromme, there will appear two objects in the list, called Pitch hallo and Polygon kromme. Links to this page AIFF and AIFC files Confusion Dissimilarity EEG ExperimentMFC 2.9. How an experiment proceeds FLAC files How to concatenate sound files Intro 1.2. Reading a sound from disk Intro 4.5. The Pitch object Intro 5.4. The Formant object Intro 7. Annotation Keyboard shortcuts Macintosh sound files ManPages Matrix NIST files OT learning 2.2. Inside the grammar OT learning 7. Learning from overt forms Save as short text file... Save menu Sesam/LVS files Sound files 2.4. NeXT/Sun (.au) files Sound files 3. Files that Praat can read SoundRecorder SpellingChecker stereo Strings What was new in 3.9? What was new in 5.2? WordList 
Read_from_Praat_picture_file___	Read from Praat picture file... One of the commands in the File menu of the Picture window. Purpose To read a picture that you saved earlier with Save as Praat picture file.... Behaviour The picture will be drawn across whatever is currently visible in the Picture window. Usage With the help of this command, you can transfer a picture from a Unix machine to a Macintosh. Praat for Macintosh can write the picture to an Encapsulated PostScript file with a screen preview. 
Read_Matrix_from_raw_text_file___	Read Matrix from raw text file... A command to read a Matrix object from a file on disk. File format The file should contain each row of the matrix on a separate line. Within each row, the elements must be separated by spaces or tabs. For instance, the following text file will be read as a Matrix with three rows and four columns: 0.19 3 245 123 18e-6 -3e18 0 0.0 1.5 2.5 3.5 4.5 The resulting Matrix will have the same domain and sampling as Matrices created with Create simple Matrix.... In the above example, this means that the Matrix will have xmin = 0.5, xmax = 4.5, nx = 4, dx = 1.0, x1 = 1.0, ymin = 0.5, ymax = 3.5, ny = 3, dy = 1.0, y1 = 1.0. Links to this page TableOfReal 
Read_separate_channels_from_sound_file___	Read separate channels from sound file... A command in the Open menu of the Objects window. You use this if you want to get the channels of a stereo (or multi-channel) sound file as two (or more) separate Sound objects in the list. If the file name is hello.wav, Praat will name the channels hello_ch1, hello_ch2, and so on. 
Read_Strings_from_raw_text_file___	Read Strings from raw text file... A command to read a Strings object from a simple text file. Each line is read as a separate string. See Strings for an example. Links to this page WordList 
Record_mono_Sound___	Record mono Sound... A command in the New menu to record a Sound. Creates a SoundRecorder window, except on very old Macintoshes with 8-bit audio, where it presents a native Macintosh sound-recorder window. Links to this page Intro 1.1. Recording a sound 
Record_stereo_Sound___	Record stereo Sound... A command in the New menu to record a Sound. Creates a SoundRecorder window. 
Regular_expressions	Regular expressions This tutorial describes the syntax of regular expressions in PRAAT Introduction A regular expression is a text string that describes a set of strings. Regular expressions (regex) are useful as a way to search for patterns in text strings and, optionally, replace them by another pattern. Some regex match only one string, i.e., the set they describe has only one member. For example, the regex ab matches the string ab and no others. Other regex match more than one string, i.e., the set they describe has more than one member. For example, the regex a* matches the string made up of any number (including zero) of as. As you can see, some characters match themselves (such as a and b) and these characters are called ordinary characters. The characters that don't match themselves, such as *, are called special characters or meta characters. Many special characters are only special characters in the search regex and are ordinary characters in the substitution regex. You can read the rest of this tutorial sequentially with the help of the <1 and >1 buttons. 1. Special characters (\ ^ ${ } [ ] ( ) . + ? | - &) 2. Quantifiers (how often do we match). 3. Anchors (where do we match) 4. Special constructs with parenthesis (grouping constructs) 5. Special control characters (difficult-to-type characters like \n) 6. Convenience escape sequences (\d \D \l \L \s \S \w \W \B) 7. Octal and hexadecimal escapes (things like \053 or \X2B) 8. Substitution special characters (\1..\9 \U \u \L \l &) More in depth coverage of regular expressions can be found in Friedl (1997). Links to this page Confusion: Condense... Formulas 5. String functions TableOfReal: Change column labels... TableOfReal: Change row labels... What was new in 4.0? 
Regular_expressions_1__Special_characters	Regular expressions 1. Special characters The following characters are the meta characters that give special meaning to the regular expression search syntax: \ the backslash escape character. The backslash gives special meaning to the character following it. For example, the combination \n stands for the newline, one of the control characters. The combination \w stands for a word character, one of the convenience escape sequences while \1 is one of the substitution special characters. Example: The regex aa\n tries to match two consecutive as at the end of a line, inclusive the newline character itself. Example: a\+ matches a+ and not a series of one or as. ^ the caret is the start of line anchor or the negate symbol. Example: ^a matches a at the start of a line. Example: [^0-9] matches any non digit. $ the dollar is the end of line anchor. Example: b$ matches a b at the end of a line. Example: ^b$ matches the empty line. { } the open and close curly bracket are used as range quantifiers. Example: a{2,3} matches aa or aaa. [ ] the open and close square bracket define a character class to match a single character. The ^ as the first character following the [ negates and the match is for the characters not listed. The - denotes a range of characters. Inside a [ ] character class construction most special characters are interpreted as ordinary characters. Example: [d-f] is the same as [def] and matches d, e or f. Example: [a-z] matches any lowercase characters in the alfabet. Example: [^0-9] matches any character that is not a digit. Example: A search for [][()?<>.*?] in the string []()?<>.*? followed by a replace string r has the result rrrrrrrrrrrrr. Here the search string is one character class and all the meta characters are interpreted as ordinary characters without the need to escape them. ( ) the open and close parenthesis are used for grouping characters (or other regex). The groups can be referenced in both the search and the substitution phase. There also exist some special constructs with parenthesis. Example: (ab)\1 matches abab. . the dot matches any character except the newline. Example: .a matches two consecutive characters where the last one is a. Example: .*\.txt$ matches all strings that end in .txt. * the star is the match-zero-or-more quantifier. Example: ^.*$ matches an entire line. + the plus is the match-one-or-more quantifier. ? the question mark is the match-zero-or-one quantifier. The question mark is also used in special constructs with parenthesis and in changing match behaviour. | the vertical pipe separates a series of alternatives. Example: (a|b|c)a matches aa or ba or ca. < > the smaller and greater signs are anchors that specify a left or right word boundary. - the minus indicates a range in a character class (when it is not at the first position after the [ opening bracket or the last position before the ] closing bracket. Example: [A-Z] matches any uppercase character. Example: [A-Z-] or [-A-Z] match any uppercase character or -. & the and is the substitute complete match symbol. Links to this page Regular expressions 
Regular_expressions_2__Quantifiers	Regular expressions 2. Quantifiers Quantifiers specify how often the preceding regular expression should match. * Try to match the preceding regular expression zero or more times. Example: (ab)c* matches ab followed by zero or more cs, i.e., ab, abc, abcc, abccc ... + Try to match the preceding regular expression one or more times. Example: (ab)c+ matches ab followed by one or more cs, i.e., abc, abcc, abccc ... {m, n} Try to match the preceding regular expression between m and n times. If you leave m out, it is assumed to be zero. If you leave n out it is assumed to be infinity. I.e., {,n} matches from zero to n times, {m,} matches a minimum of m times, {,} matches the same as * and {n} is shorthand for {n, n} and matches exactly n times. Example: (ab){1,2} matches ab and abab. ? Try to match zero or one time. Changing match behaviour Default the quantifiers above try to match as much as possible, they are greedy. You can change greedy behaviour to lazy behaviour by adding an extra ? after the quantifier. Example: In the string cabddde, the search abd{1,2} matches abdd, while the search for abd{1,2}? matches abd. Example: In the string cabddde, the search abd+ matches abddd, while the search for abd+? matches abd. Links to this page Regular expressions 1. Special characters 
Regular_expressions_3__Anchors	Regular expressions 3. Anchors Anchors let you specify a very specific position within the search text. ^ Try to match the (following) regex at the beginning of a line. Example: ^ab matches ab only at the beginning of a line and not, for example, in the line cab. $ Try to match the (following) regex at the end of a line. < Try to match the regex at the start of a word. The character class that defines a word can be found at the convenience escape sequences page. > Try to match the regex at the end of a word. \B Not a word boundary Regular expressions Regular expressions 1. Special characters 
Regular_expressions_4__Special_constructs_with_parenthe	Regular expressions 4. Special constructs with parenthesis Some special constructs exist with parenthesis. (?:regex) is a grouping-only construct. They exist merely for efficiency reasons and facilitate grouping. (?=regex) is a positive look-ahead. A match of the regular expression contained in the positive look-ahead construct is attempted. If the match succeeds, control is passed to the regex following this construct and the text consumed by this look-ahead construct is first unmatched. (?!regex) is a negative look-ahead. Functions like a positive look-ahead, only the regex must not match. Example: abc(?!.*abc.*) searches for the last occurrence of abc in a string. (?iregex) is a case insensitive regex. (?Iregex) is a case sensitive regex. Default a regex is case sensitive. Example: (?iaa) matches aa, aA, Aa and AA. (?nregex) matches newlines. (?Nregex) doesn't match newlines. All the constructs above do not capture text and cannot be referenced, i.e., the parenthesis are not counted. However, you can make them capture text by surrounding them with ordinary parenthesis. Links to this page Regular expressions Regular expressions 1. Special characters 
Regular_expressions_5__Special_control_characters	Regular expressions 5. Special control characters Special control characters in a regular expression specify characters that are difficult to type. \a alert (bell). \b backspace. \e ASCII escape character. \f form feed (new page). \n newline. \r carriage return. Example : a search for \r\n followed by a replace \r changes Windows text files to Macintosh text files. Example : a search for \r followed by a replace \n changes Macintosh text files to Unix text files. Example : a search for \r\n followed by a replace \n changes Windows text files to Unix text files. \t horizontal tab. \v vertical tab. Links to this page Regular expressions 1. Special characters Regular expressions 8. Substitution special characters 
Regular_expressions_6__Convenience_escape_sequences	Regular expressions 6. Convenience escape sequences Convenience escape sequences in a regular expression present a shorthand for some character classes. \d matches a digit: [0-9]. Example: -?\d+ matches any integer. \D not a digit: [^0-9]. \l a letter: [a-zA-Z]. \L not a letter: [^a-zA-Z]. \s whitespace: [ \t\n\r\f\v]. \S not whitespace: [^ \t\n\r\f\v]. \w word character: [a-zA-Z0-9_]. Example: \w+ matches a word, i.e., a string of one or more characters that may consist of letters, digits and underscores. \W not a word character: [^a-zA-Z0-9_]. \B any character that is not a word-delimiter. Links to this page Regular expressions 1. Special characters Regular expressions 3. Anchors 
Regular_expressions_7__Octal_and_hexadecimal_escapes	Regular expressions 7. Octal and hexadecimal escapes An octal number can be represented by the octal escape \0 and maximally three digits from the digit class [0-7]. The octal number should not exceed \0377. A hexadecimal number can be represented by the octal escape \x or \Xand maximally two characters from the class [0-9A-F]. The maximum hexadecimal number should not exceed \xFF. Example: \053 and \X2B both specify the + character. Links to this page Regular expressions Regular expressions 8. Substitution special characters 
Regular_expressions_8__Substitution_special_characters	Regular expressions 8. Substitution special characters The substitution string is mostly interpreted as ordinary text except for the special control characters, the octal and hexadecimal escapes and the following character combinations: \1 ... \9 are backreferences at sub-expressions 1 ... 9 in the match. Any of the first nine sub-expressions of the match string can be inserted into the replacement string by inserting a `\' followed by a digit from 1 to 9 that represents the string matched by a parenthesized expression within the regular expression. The numbering is left to right. Example: A search for (a)(b) in the string abc, followed by a replace \2\1 results in bac. & reference at entire match. The entire string that was matched by the search operation will be substituted. Example: a search for . in the string abcd followed by the replace && doubles every character in the result aabbccdd. \U \u to uppercase. The text inserted by & or \1 ... \9 is converted to uppercase (\u only changes the first character to uppercase). Example: A search for (aa) in the string aabb, followed by a replace \U\1bc results in the string AAbcbb. \L \l to lowercase. The text inserted by & or \1 ... \9 is converted to lowercase (\l only changes the first character to lowercase). Example: A search for (AA) with a replace \l\1bc in the string AAbb results in the string aAbcbb. Links to this page Regular expressions Regular expressions 1. Special characters 
Remove	Remove One of the fixed buttons in the Object window. You can choose this command after selecting one or more objects in the list. The selected objects will permanently disappear from the list, and the computer memory that they occupied will be freed. To save your data before removing, choose a command from the Save menu. Links to this page Editors 
Remove_point___	Remove point... A command to remove one point from every selected time-based tier object (DurationTier, IntensityTier, PitchTier). Setting Point number the index of the point you want to remove. Behaviour If Point number is 3, the third point counted from the start of the tier (if it exists) is removed from the tier. 
Remove_point_near___	Remove point near... A command to remove one point from every selected time-based tier object (DurationTier, IntensityTier, PitchTier). Setting Time (s) the time near which you want to remove a point. Behaviour The point nearest to Time (if there is any point) is removed from the tier. 
Remove_points_between___	Remove points between... A command to remove some points from every selected time-based tier object (DurationTier, IntensityTier, PitchTier). Settings From time (s) To time (s) the times between which you want to remove all points. Behaviour Any points between Frome time and To Time (inclusive) are removed from the tier. 
Rename___	Rename... One of the fixed buttons in the Object window. Availability You can choose this command after selecting one object of any type. Purpose You can give the selected object a new name. Behaviour If you type special symbols or spaces, the Object window will replace them with underscores. Links to this page Editors 
Resource_fork	Resource fork One of the two forks of a Macintosh file (the other is the data fork). If a Macintosh file is moved to another platform directly, the resource fork is lost. To backup your Macintosh files, use compression, for instance with DropStuff™. Links to this page Macintosh sound files 
reverberation_time	reverberation time Reverberation is the persistence of sound in a room after the sound source has silenced. The reverberation time is normally defined as the time required for the persistence of a direct sound to decay by 60 dB after the direct sound has silenced. Sometimes this dB level is indicated with a subscript and the reverberation time is given by the symbol T60. The reverberation time depends mainly on a room's volume and area and on the absorption at the walls. Generally absorption is frequency dependent and therefore the reverberation time of a room varies with frequency. Links to this page blind source separation 
Robust_Interpretive_Parsing	Robust Interpretive Parsing The mapping from overt forms to surface forms in the acquisition model by Tesar & Smolensky (1998). In Praat, you can do robust interpretive parsing on any OTGrammar object. See OT learning 7. Learning from overt forms. 
Roots	Roots One of the types of objects in PRAAT. An object of type Roots represents the (complex) roots of a polynomial function. Commands Creation Polynomial: To Roots Drawing Draw... (in the complex plane) Queries Get root...: get complex root Get real part of root... Get imaginary part of root... Links to this page LPC: Draw poles... What was new in 3.9? 
Rosenberg__1971_	Rosenberg (1971) A. Rosenberg (1971): Effect of glottal pulse shape on the quality of natural vowels. Journal of the Acoustical Society of America 49: 583–590. Links to this page PointProcess: To Sound (phonation)... 
Rosenblatt__1962_	Rosenblatt (1962) Frank Rosenblatt (1962): Principles of neurodynamics; perceptrons and the theory of brain mechanisms. Washington: Spartan Books. Links to this page OT learning 4. Learning an ordinal grammar 
Rumelhart___McClelland__1986_	Rumelhart & McClelland (1986) David Rumelhart, James L. McClelland, and the PDP Research Group (eds., 1986): Parallel Distributed Processing: explorations in the microstructure of cognition. MIT Press, Cambridge. Links to this page Smolensky (1986) 
Sakoe___Chiba__1978_	Sakoe & Chiba (1978) H. Sakoe & S. Chiba (1978): Dynamic programming algorithm optimization for spoken word recognition. Transactions on ASSP 26: 43–49. Links to this page DTW: Find path (band & slope)... 
Salience	Salience One of the types of objects in PRAAT. Elements sij in the Salience matrix represent the importance of dimension j (in the Configuration) for data source i. Commands Creation, as a by-product of: Distance: To Configuration (indscal)... Distance: To Configuration (ytl)... Links to this page Distance & Configuration: Get VAF... individual difference scaling Multidimensional scaling 
sampling_frequency	sampling frequency The sampling frequency (or sample rate) is the number of samples per second in a Sound. For example: if the sampling frequency is 44100 hertz, a recording with a duration of 60 seconds will contain 2,646,000 samples. Usual values for the sampling frequency are 44100 Hz (CD quality) and 22050 Hz (just enough for speech, since speech does not contain relevant frequencies above 11025 Hz; see aliasing). To get the sampling frequency of a selected Sound, click Info or choose Get sampling frequency. Links to this page Create Sound from gammatone... Create Sound from Shepard tone... KlattGrid: Play special... KlattGrid: To Sound (phonation)... KlattGrid: To Sound (special)... sampling period Sound: To Spectrum... 
sampling_period	sampling period The sampling period is the time difference between two consecutive samples in a Sound. It is the inverse of the sampling frequency. For example: if the sampling frequency is 44100 Hz, the sampling period is 1/44100 = 2.2675736961451248e-05 seconds: the samples are spaced approximately 23 microseconds apart. To get the sampling period of a selected Sound, click Info or choose Get sampling period. Links to this page Get sampling frequency Sound: Autocorrelate... Sound: To CrossCorrelationTable... Sound: To Spectrum... Sounds: Convolve... Sounds: Cross-correlate... 
Save_as_AIFC_file___	Save as AIFC file... With this command, you save one or more selected Sound and/or LongSound objects as a single 16-bit big-endian AIFC file on disk. See the Sound files tutorial for more information. Links to this page How to concatenate sound files Sound files 4. Files that Praat can write 
Save_as_AIFF_file___	Save as AIFF file... With this command, you save one or more selected Sound and/or LongSound objects as a single 16-bit big-endian AIFF file on disk. See the Sound files tutorial for more information. Links to this page AIFF and AIFC files How to concatenate sound files Sound files 4. Files that Praat can write 
Save_as_binary_file___	Save as binary file... One of the commands in the Save menu. Availability You can choose this command after selecting one or more objects. Behaviour The Object window will ask you for a file name. After you click OK, the objects will be written to a binary file on disk. Usage The file can be read again with Read from file.... File format These files are in a device-independent binary format, and can be written and read on any machine. Links to this page Intro 7. Annotation Sound WordList 
Save_as_EPS_file___	Save as EPS file... A command in the File menu of the Picture window. It saves the picture to an Encapsulated PostScript (EPS) file, which can be imported by many other programs, such as Microsoft® Word™. Usage EPS files are on the way out, mainly because they do not really support international text. On Macintosh and Linux, it is almost always better to use Save as PDF file... instead, or (on the Mac) to use Copy to clipboard. On Windows, which does not really support PDF files yet, you may find that EPS files sometimes creates better quality than Copy to clipboard; you should also check out Save as PNG file... on Windows. To import an EPS file in Word, choose Insert → Picture → From file.... Behaviour Though all the contents of the Picture window are written to the EPS file, only the part that you selected in the Picture window (the viewport) may become visible in Word (or another program). Settings The EPS picture is saved with the grey resolution and fonts that you specified with PostScript settings.... Links to this page OT learning 2.7. Tableau pictures Printing 
Save_as_FLAC_file___	Save as FLAC file... With this command, you save one or more selected Sound and/or LongSound objects as a single 16-bit FLAC audio file on disk. See the Sound files tutorial for more information. Links to this page How to concatenate sound files Sound files 4. Files that Praat can write 
Save_as_NeXT_Sun_file___	Save as NeXT/Sun file... With this command, you save one or more selected Sound and/or LongSound objects as a single 16-bit big-endian NeXT/Sun (.au) file on disk. See the Sound files tutorial for more information. Links to this page How to concatenate sound files Sound files 2.4. NeXT/Sun (.au) files Sound files 4. Files that Praat can write 
Save_as_NIST_file___	Save as NIST file... With this command, you save one or more selected Sound and/or LongSound objects as a single 16-bit little-endian NIST audio file on disk. See the Sound files tutorial for more information. Links to this page How to concatenate sound files Sound files 4. Files that Praat can write 
Save_as_PDF_file___	Save as PDF file... A command in the File menu of the Picture window, on Macintosh and Linux. It saves the picture to a PDF file, which can be imported by several other programs, such as modern versions of Microsoft® Word™. PDF means highest possible quality With PDF pictures you can use high-quality graphics in your word-processor documents. On the Mac, the quality is the same as if you use Copy to clipboard. On Windows, use Save as PNG file... or Save as EPS file... instead. Behaviour Though all the contents of the Picture window are written to the PDF file, only the part that you selected in the Picture window (the viewport) will become visible in Word (or another program). Usage To import a PDF file in Word, choose Insert → Picture → From file.... Word will create a picture with the same size as the originally selected part of the Picture window (the viewport). Links to this page Printing 
Save_as_PNG_file___	Save as PNG file... A command in the File menu of the Picture window, on all platforms. It saves the picture to a PNG (ping) image file, which can be imported by several other programs, such as Microsoft® Word™. For the resolution you can choose between 600 dots per inch (very good quality even when printed) and 300 dpi (enough for all web sites, even on retina displays). Usage in text processors On Windows, PNG files may sometimes have the best quality that you can get, although you should also try Save as EPS file... and Copy to clipboard. On Macintosh or Linux, Save as PDF file... or Copy to clipboard is almost always better. Usage for publication Some publishers do not accept PDF pictures. In such a case, they may accept 600-dpi or 300-dpi PNG pictures. If they accept TIFF pictures only, then you can easily convert your PNG picture to a TIFF picture with any graphics converter program. Behaviour Only the contents of the part of the Picture window that you selected (the viewport) are written to the PNG file. Usage To import a PNG file in Word, choose Insert → Picture → From file.... Word will create a picture with the same size as the originally selected part of the Picture window (the viewport). 
Save_as_Praat_picture_file___	Save as Praat picture file... A command in the File menu of the Picture window. It saves a picture in a format that can be imported into Praat later with Read from Praat picture file.... Usage With the help of this command, you can transfer the contents of the picture window between computers or even between platforms, for instance from a Macintosh to a Windows computer. 
Save_as_short_text_file___	Save as short text file... One of the commands in the Save menu. Availability You can choose this command after selecting one or more objects. Behaviour The Object window will ask you for a file name. After you click OK, the objects will be written to a text file on disk. File format The format is much shorter than the one described at Save as text file.... Most of the comments are gone, and there is normally one piece of data per line. The file can be read again with the all-purpose Read from file.... Links to this page Intro 7. Annotation 
Save_as_text_file___	Save as text file... One of the commands in the Save menu. Availability You can choose this command after selecting one or more objects. Behaviour The Object window will ask you for a file name. After you click OK, the objects will be written to a text file on disk. File format If you selected a single object, e.g., of type Pitch, the file will start with the lines: File type = ooTextFile Object class = Pitch After this, the pitch data will follow. If you selected more than one object, e.g., `Pitch hallo' and `Polygon kromme', the file will look like: File type = ooTextFile Object class = Collection size = 2 item []: item [1]: class = Pitch name = hallo (pitch data...) item [2]: class = Polygon name = kromme (polygon data...) The file can be read again with Read from file..., which, by the way, does not need the verbosity of the above example. The following minimal format will also be read correctly: ooTextFile Collection 2 Pitch hallo (pitch data...) Polygon kromme (polygon data...) Thus, all text that is not a free-standing number and is not enclosed in double quotes or < >, is considered a comment, as is all text following an exclamation mark (`!') on the same line. Links to this page ExperimentMFC 2.9. How an experiment proceeds Intro 7. Annotation OT learning 2.2. Inside the grammar OT learning 2.3. Defining your own grammar Save as short text file... Sound TableOfReal Unicode Write to console 
Save_as_WAV_file___	Save as WAV file... With this command, you save one or more selected Sound and/or LongSound objects as a single 16-bit little-endian WAV file on disk. See the Sound files tutorial for more information. Links to this page How to concatenate sound files Sound files 4. Files that Praat can write stereo 
Save_as_Windows_metafile___	Save as Windows metafile... A command in the File menu of the Picture window, if you are on Windows. It saves the selected part of the picture in an enhanced metafile (.EMF) format, which can be imported by many Windows programs, like Adobe® Illustrator™ or Microsoft® Word™. Behaviour Though all the picture data will be written to the file, only the part that you selected in the Picture window (the viewport) may become visible in the other program. Usage You will not use this command very often, because it is usually easier to copy the selection to the clipboard with the Copy to clipboard command, and `Paste' it into the other program. You may use a metafile instead of the clipboard if the clipboard is too large for the other program to read, or if you want to transfer the picture to another computer. Links to this page Printing 
Save_menu	Save menu One of the menus in the Object window. Purpose With the Save menu, you write one or more selected objects from memory to a file on disk. The data can be read in again with one of the commands in the Open menu (most often simply with Read from file...). Usage: save your work You will often choose a command from this menu just before clicking the Remove button or choosing the Quit command. Fixed commands If no object is selected, the Save menu is empty. If any object is selected, it will at least contain the following commands: • Write to console • Save as text file... • Save as short text file... • Save as binary file... Dynamic commands Depending on the type of the selected object, the following commands may be available in the Save menu: Add to dynamic menu... How to concatenate sound files Intro 2.1. Saving a sound to disk Intro 4.5. The Pitch object Intro 5.4. The Formant object Sounds: Concatenate 
ScalarProduct	ScalarProduct One of the types of objects in PRAAT. An object of type ScalarProduct represents scalar products bij between objects i and j in a metrical space. bij = ∑k=1..numberOfDimensions xikxjk, where xik and xjk are the coordinates of the k-th dimension of points i and j, respectively. From this definition one can see that scalar products, in contrast to distances, do change when the origin is shifted. Creation Distance: To ScalarProduct... 
Schott__2001_	Schott (2001) J. R. Schott (2001): Some tests for the equality of covariance matrices. Journal of Statistical Planning and Inference 94: 25 36. Links to this page Covariances: Report equality 
Scree_plot	Scree plot A scree plot shows the sorted eigenvalues, from large to small, as a function of the eigenvalue index. Links to this page Eigen: Draw eigenvalues... Principal component analysis 
Script_for_analysing_pitch_with_a_TextGrid	Script for analysing pitch with a TextGrid I want the mean pitch of every interval that has a non-empty label on tier 5. if numberOfSelected (Sound) <> 1 or numberOfSelected (TextGrid) <> 1 exitScript: Please select a Sound and a TextGrid first. endif sound = selected (Sound) textgrid = selected (TextGrid) writeInfoLine: Result: selectObject: sound To Pitch: 0.0, 75, 600 pitch = selected (Pitch) selectObject: textgrid n = Get number of intervals: 5 for i to n tekst$ = Get label of interval: 5, i if tekst$ <> t1 = Get starting point: 5, i t2 = Get end point: 5, i selectObject: pitch f0 = Get mean: t1, t2, Hertz appendInfoLine: fixed$ (t1, 3), , fixed$ (t2, 3), , round (f0), , tekst$ selectObject: textgrid endif endfor selectObject: sound, textgrid Links to this page Scripting examples 
Script_for_creating_a_frequency_sweep	Script for creating a frequency sweep I have to find a formula for a sinewave that sweeps from 1 kHz to 12 kHz in 60 seconds while ramping the amplitude from 1 to 12 volts in the same amount of time. The absolute amplitude in volts cannot be handled, of course, but linear crescendo is easy: Create Sound from formula: sweep, 1, 0, 60, 44100, ... 0.05 * (1 + 11 * x/60) * sin (2*pi * (1000 + 11000/2 * x/60) * x) Note the /2 in this formula. Here is the derivation of the formula: frequency (t) = 1000 + 11000 t / 60 phase (t) = ∫ frequency (t) dt = 1000 t + 11000 (t2/2) / 60 signal (t) = sin (phase (t)) Links to this page Scripting examples 
Script_for_listing_F0_statistics	Script for listing F0 statistics I need to split the wave into 50 msec sections, and then for each of those sections get the F0 statistics. That is, for each 50 msec section of speech I want to get the average F0, min, max, and standard deviation. First you create the complete pitch contour, i.e., you select the Sound and choose To Pitch.... You can then use the commands from the Query menu in a loop: startTime = Get start time endTime = Get end time numberOfTimeSteps = (endTime - startTime) / 0.05 writeInfoLine: tmin tmax mean fmin fmax stdev for step to numberOfTimeSteps tmin = startTime + (step - 1) * 0.05 tmax = tmin + 0.05 mean = Get mean: tmin, tmax, Hertz minimum = Get minimum: tmin, tmax, Hertz, Parabolic maximum = Get maximum: tmin, tmax, Hertz, Parabolic stdev = Get standard deviation: tmin, tmax, Hertz appendInfoLine: fixed$ (tmin, 6), , fixed$ (tmax, 6), , fixed$ (mean, 2), ... , fixed$ (minimum, 2), , fixed$ (maximum, 2), , fixed$ (stdev, 2) endfor Notes One should not cut the sound up into pieces of 50 ms and then do To Pitch... on each of them, because Praat will not compute F0 values in the first or last 20 ms (or so) of each piece. This is because the analysis requires a window of 40 ms (or so) for every pitch frame. Instead, one typically does the analysis on the whole sound, then queries the resulting large Pitch object. In that way, the information loss of windowing only affects the two 20 ms edges of the whole sound. The example writes lines to the Info window. If you want to write to a file instead, you start with something like deleteFile: ~/results/out.txt and add lines in the following way: appendFileLine: ~/results/out.txt , fixed$ (tmin, 6), , fixed$ (tmax, 6), , ... fixed$ (mean, 2), , fixed$ (minimum, 2), , fixed$ (maximum, 2), , ... fixed$ (stdev, 2) Links to this page Scripting examples 
Script_for_listing_time_--F0_--intensity	Script for listing time\--F0\--intensity I want a list of pitch and intensity values at the same times. Since Sound: To Pitch... and Sound: To Intensity... do not give values at the same times, you create separate pitch and intensity contours with high time resolution, then interpolate. In the following example, you get pitch and intensity values at steps of 0.01 seconds by interpolating curves that have a time resolution of 0.001 seconds. sound = selected (Sound) tmin = Get start time tmax = Get end time To Pitch: 0.001, 75, 300 Rename: pitch selectObject: sound To Intensity: 75, 0.001 Rename: intensity writeInfoLine: Here are the results: for i to (tmax-tmin)/0.01 time = tmin + i * 0.01 selectObject: Pitch pitch pitch = Get value at time: time, Hertz, Linear selectObject: Intensity intensity intensity = Get value at time: time, Cubic appendInfoLine: fixed$ (time, 2), , fixed$ (pitch, 3), , fixed$ (intensity, 3) endfor Links to this page Scripting examples 
Script_for_listing_time_--F0_pairs	Script for listing time\--F0 pairs I wish to have a list of time markers in one column and F0 in the other. Those times that have no voiced data should be represented as “.” in the F0 column. writeInfoLine: Time: Pitch: numberOfFrames = Get number of frames for iframe to numberOfFrames time = Get time from frame: iframe pitch = Get value in frame: iframe, Hertz if pitch = undefined appendInfoLine: fixed$ (time, 6) else appendInfoLine: fixed$ (time, 6), , fixed$ (pitch, 3) endif endfor If you want to see this in a text file, you can copy and paste from the Info window, or save the Info window, or add a line to the script like appendFile: out.txt, info$( ) Links to this page Scripting examples 
Script_for_onset_detection	Script for onset detection Can anybody provide me with a script that detects the onset of sound (i.e. the end of silence). You can create an Intensity contour and look for the first frame that is above some predefined threshold: To Intensity: 100, 0 n = Get number of frames for i to n intensity = Get value in frame: i if intensity > 40 time = Get time from frame: i writeInfoLine: Onset of sound at: , fixed$ (time, 3), seconds. exit endif endfor Since the intensity is computed with rather long windows, the result may be 0.01 or 0.02 seconds before the actual start of sound. Links to this page Scripting examples 
Script_for_TextGrid_boundary_drawing	Script for TextGrid boundary drawing I want only the dotted lines of the textgrid marked on top of another analysis (e.g. pitch, intensity or so) without the labels being shown below it. n = Get number of intervals: 1 for i to n-1 t = Get end point: 1, i One mark bottom: t, no, no, yes endfor Links to this page Scripting examples 
ScriptEditor	ScriptEditor An aid to scripting. The ScriptEditor is a text editor that allows you to edit, save, and run any Praat script. You can type such a script from scratch, but it is sometimes easier to use the History mechanism, which automatically records all your commands and mouse clicks, and which can paste these directly into a ScriptEditor. To add a script as a button to a fixed or dynamic menu, use Add to fixed menu... or Add to dynamic menu... from the File menu. Example 1 In this example, we create a fixed button that will play a 0.4-second sine wave with a specified frequency. First, we create a ScriptEditor by choosing New Praat script from the Praat menu. Then, we choose Clear history from the Edit menu in the ScriptEditor. We then perform some actions that will create a sine wave, play it, and remove it: 1. Choose Create Sound as pure tone... from the New menu and click OK. 2. Click Play in the dynamic menu. 3. Click the fixed Remove button. We then choose Paste history from the Edit menu in the ScriptEditor (or type Command-H). The text will now contain at least the following lines (delete any other lines): Create Sound as pure tone: tone, 1, 0, 0.4, 44100, 440, 0.2, 0.01, 0.01 Play Remove We can run this script again by choosing Run from the Run menu (or typing Command-R). However, this always plays a sine with a frequency of 440 Hz, so we will add the variable Frequency to the script, which then looks like: form Play a sine wave positive Frequency endform Create Sound as pure tone: tone, 1, 0, 0.4, 44100, frequency, 0.2, 0.01, 0.01 Play Remove When we choose Run, the ScriptEditor will ask us to supply a value for the Frequency variable. We can now play 1-second sine waves with any frequency. It is advisable to supply a standard value for each argument in your script. If the duration should be variable, too, the final script could look like: form Play a sine wave positive Frequency 440 positive Duration 1.0 endform Create Sound as pure tone: tone, 1, 0, duration, 44100, frequency, 0.2, 0.01, 0.01 Play Remove When you run this script, the ScriptEditor will ask you to supply values for the two variables, but the values 440 and 1.0 are already visible in the form window, so that you will get a sensible result if you just click OK. If this script is useful to you, you may want to put a button for it in the New menu, in the Sound submenu: 1. Save the script to a file, with Save from the File menu. The file name that you supply, will be shown in the title bar of the ScriptEditor window. 2. Choose Add to fixed menu... from the File menu. Supply Objects for the window, New for the menu, Play sine wave... for the command, Create Sound from formula... for after command, and 1 for the depth (because it is supposed to be in a submenu); the script argument has already been set to the file name that you supplied in step 1. 3. Click OK and ensure that the button has been added in the New menu. This button will still be there after you leave the program and enter it again; to remove it from the menu, use the ButtonEditor. Example 2 In this example, we will create a shortcut for the usual complex pitch-analysis command. First, we perform the required actions: 1. Select a Sound object. 2. Click To Pitch... and set the arguments to your personal standard values. 3. Click OK. A new Pitch object will appear. We then paste the history into the ScriptEditor, after which this will contain at least a line like (delete all the other lines): To Pitch: 0.01, 150, 900 You can run this script only after selecting one or more Sound objects. If this script is useful to you, you may want to put a button for it in the dynamic menu: 1. Save the script to a file, with Save from the File menu. 2. Choose Add to dynamic menu... from the File menu. Supply Sound for class1 (because the button is supposed to be available only if a Sound is selected), 0 for number1 (because the command is supposed to work for any number of selected Sound objects), To Pitch (child) for the command, To Spectrum for after command, and 0 for the depth (because it is not supposed to be in a submenu); the script argument has already been set to the file name that you supplied in step 1. 3. Click OK and ensure that the button is clickable if you select one or more Sound objects. This button will still be available after you leave the program and enter it again; to remove it from the dynamic menus, use the ButtonEditor. Links to this page Add action command... Add menu command... buttons file Hidden commands Object window Open Praat script... plug-ins Scripting 1. Your first scripts Scripting 2. How to script settings windows Scripting 7.2. Scripting an editor from within What was new in 3.6? 
Scripting	Scripting This is one of the tutorials of the Praat program. It assumes you are familiar with the Intro. A script is a text that consists of menu commands and action commands. If you run the script (perhaps from a ScriptEditor), the commands are executed as if you clicked on them. You can read this tutorial sequentially with the help of the < 1 and 1 > buttons. Scripting 1. Your first scripts (how to create, how to run, how to save) Scripting 2. How to script settings windows (numeric, boolean, multiple-choice, text, file) Scripting 3. Simple language elements Scripting 3.1. Hello world (writeInfoLine, appendInfoLine) Scripting 3.2. Numeric variables (assignments) Scripting 3.3. Numeric queries Scripting 3.4. String variables (assignments) Scripting 3.5. String queries Scripting 3.6. For loops (for, endfor) Scripting 3.7. Layout (white space, comments, continuation lines) Scripting 4. Object selection Scripting 4.1. Selecting objects Scripting 4.2. Removing objects Scripting 4.3. Querying objects Scripting 5. Language elements reference Scripting 5.1. Variables (numeric, string) Scripting 5.2. Expressions (numeric, string) Scripting 5.3. Jumps (if, then, elsif, else, endif) Scripting 5.4. Loops (for/endfor, while/endwhile, repeat/until) Scripting 5.5. Procedures (@, procedure) Scripting 5.6. Arrays Scripting 5.7. Including other scripts Scripting 5.8. Quitting (exitScript) Scripting 6. Communication outside the script Scripting 6.1. Arguments to the script (form/endform, runScript) Scripting 6.2. Writing to the Info window (writeInfoLine, appendInfoLine, appendInfo, tab$) Scripting 6.3. Query commands (Get, Count) Scripting 6.4. Files (fileReadable, readFile, writeFile, deleteFile, createDirectory) Scripting 6.5. Calling system commands (system, environment$, stopwatch) Scripting 6.6. Controlling the user (pause, beginPause/endPause, chooseReadFile$) Scripting 6.7. Sending a message to another program (sendsocket) Scripting 6.8. Messages to the user (exitScript, assert, nowarn, nocheck) Scripting 6.9. Calling from the command line Scripting 7. Scripting the editors Scripting 7.1. Scripting an editor from a shell script (editor/endeditor) Scripting 7.2. Scripting an editor from within Scripting 8. Controlling Praat from another program Scripting 8.1. The sendpraat subroutine Scripting 8.2. The sendpraat program Scripting 8.3. The sendpraat directive Scripting 9.1. Turning a script into a stand-alone program Scripting 9.2. Old functions Also see the scripting examples. Links to this page Acknowledgments Feedforward neural networks 1.1. The learning phase Formulas 1.9. Formulas in scripts History mechanism Intro 8.2. Manipulation of duration Praat script Programming with Praat 
Scripting_1__Your_first_scripts	Scripting 1. Your first scripts This page tells you how to create, run and save a script. To get a feel for how it works, you are advised to try out all the steps. 1. A minimal script Suppose that you want to create a script that allows you to play a selected Sound object twice. You first create an empty script, by choosing New Praat script from the Praat menu in the Praat Objects window. A ScriptEditor window will appear on your screen: In this window, you type Play Play Now select a Sound in the Praat Objects window. As you expect from selecting a Sound, a Play button will appear in the dynamic menu. If you now choose Run from the Run menu in the ScriptEditor, Praat will play the sound twice. This works because Play is a command that becomes available in the dynamic menu when you select a Sound. 2. Some more commands In the above example, you could use the Play command because that was the text on a button currently available in the dynamic menu. Apart from these selection-dependent (dynamic) commands, you can also use all fixed commands from the menus of the Object window and the Picture window. For instance, try the following script: Erase all Draw inner box Play Play Erase all When you run this script, you'll see a rectangle appear in the Praat Picture window (that's what the command Draw inner box in the Margins menu does), then you'll hear the Sound play tiwce, then you'll see the rectangle disappear from the Picture window (that's what the command Erase all from the Edit menu does). Here we see that the Praat scripting language is an example of a procedural programming language, which means that the five statements are executed in the order in which they appear in the script, i.e. first Erase all, then Draw inner box, then Play twice, and finally Erase all. 3. Experimenting with your script You don't have to be afraid of making mistakes. Here are a couple that you can try to make. First, try to run the script when a Sound is not selected (e.g. you create a Pitch object from it and keep that selected, or you throw away the Sound). You will notice that Praat gives you an error message saying The command Play is not available for the current selection. Indeed, if you select a Pitch or if you select nothing, then no command Play appears in the dynamic menu, so the script cannot execute it. Note that the commands Erase all and Draw inner box are still available, because they continue to be present in the menus of the Picture window; therefore, the script will execute the first two lines (Erase all and Draw inner box) and stop running at the third line, i.e. at your first Play. The result is that the box will stay visible in the Picture window, because the fifth line of the script, which should erase the box, is never executed. Second, try to mistype a command (there's a good chance you already did it by accident), e.g. write PLay instead of Play, or Draw inner bocks or whatever. Again, you are likely to get a message saying that that command is not available. Such messages are the most common messages that you'll see when writing scripts; now you know that they mean either that you mistyped something or that you made the wrong selection. 4. Saving your script The File menu of the ScriptEditor has a command Save, with which you can save your script as a file on disk, for instance under the name test.praat. Please try this with the five-line script you just typed. After saving the script, the name of the script file will appear in the window title: After you save your script, you can close the ScriptEditor window without losing the script: you can reopen the script file by using Open Praat script... from the Praat menu, or by choosing New Praat script again, followed by Open... from the ScriptEditor's File menu. It advisable to use .praat as the extension for script file names. On the Mac, if you double-click a .praat file, Praat will automatically start up and show the script. On the Mac and on Windows, if you drag a .praat file on the Praat icon, Praat will also start up and show the script. Links to this page Scripting Scripting 2. How to script settings windows Scripting 3. Simple language elements 
Scripting_2__How_to_script_settings_windows	Scripting 2. How to script settings windows Not all menu commands are as simple as those on the previous page, which act immediately once you choose them from a menu (e.g. Play, Erase all). Most commands in Praat require the user to supply additional information; these are the commands whose title ends in .... For instance, when you select a Sound, the command Draw... will appear in the Draw menu, and when you click it, Praat will present you with a settings window, which asks you to supply six pieces of additional information, i.e. six so-called settings (or in programming jargon: arguments): In this example, all the settings have their standard values: you want to draw the whole time domain of the Sound, you want to have autoscaling vertically, you want to see garnishings around the picture (a box, labelled axes, and numbers), and you want the waveform to be drawn as a curve. Pressing the OK button in the above window is equivalent to executing the following script line: Draw: 0, 0, 0, 0, yes, Curve You see that in a script, all of the arguments are supplied after the command, preceded by a colon and separated by commas, in the same order as in the settings window, counted from top to bottom (and, within a line, from left to right). The texts (= all) and (= auto) above are just Praat's explanations of what it means to type a zero in those fields (namely `draw all times' and `use vertical autoscaling', respectively); in a script they are superfluous and you shouldn't write them. If you want to draw the sound with different settings, say from 1 to 3.2 seconds, scaled between -1 and +1 instead of automatically, with garnishings off, and with the waveform drawn as poles, you would have the following settings window: In a script this would look like Draw: 1.0, 3.2, -1, 1, no, Poles 1. Numeric arguments The first four arguments in the above examples are numeric arguments: they are (real or integer) numbers. You just write them in the script as you would write them into the settings window. 2. Boolean (yes/no) arguments The fifth argument in the above examples (Garnish) is a boolean argument (yes/no choice) and is represented by a check button. In the script you write it as yes (including the quotes) or no (or as 1 or 0). 3. Multiple-choice arguments The sixth argument in the above examples (Drawing method) is a multiple-choice argument and is represented by an option menu. In the script you write the text of the choice, i.e. Curve or Poles in the examples. A multiple choice argument is sometimes represented by a radio box instead of by an option menu. For instance, the last example above could equally well have looked like In supplying arguments to a command in a script, there is no difference between an option menu and a radio box. This last example will therefore again look like the following in a script: Draw: 1.0, 3.2, -1, 1, no, Poles 4. Text arguments Consider another frequently used menu command, namely Create Sound from formula... in the New menu: In a script this would look like: Create Sound from formula: sine, 1, 0.0, 1.0, 44100, 1/2 * sin(2*pi*377*x) Both the first argument (Name) and the sixth argument (Formula) are text arguments. In a script they are written within quotes. 5. File arguments The commands from the Open and Save menus, and several other commands whose names start with Read, Open, or Save, present a file selector window instead of a typical Praat settings window. File selector windows ask the user to supply a single argument: the file name. In a script you can either supply the complete path to the file, or supply a relative path. A complete path includes both the directory (folder) hierarchy and the name of the file. This goes slightly differently on the Windows platform on the one hand, and on the Mac and Linux platforms on the other. If your user name is Miep, and your home directory contains a folder Sounds, and this folder contains a folder Animals, and this contains the file miauw.wav, you can open that file as follows: Read from file: C:/Users/Miep/Sounds/Animals/miauw.wav ; Windows Read from file: /Users/Miep/Sounds/Animals/miauw.wav ; Mac Read from file: /home/miep/Sounds/Animals/miauw.wav ; Linux (the part before your user name may be slightly different on your computer; use your command or terminal window to find out) In these examples, C is the Windows drive letter and /Users/Miep or /home/Miep is your home directory. Both the home directory and the drive letter can be abbreviated away by using the tilde (~): Read from file: ~/Sounds/Animals/miauw.wav If your Sounds folder is not in your home directory but on your desktop, you do Read from file: ~/Desktop/Sounds/Animals/miauw.wav (this works because on all three platforms, the desktop folder is a subfolder of your home directory) If your Sounds folder is on a USB drive called PORCH, it would be something like: Read from file: G:/Sounds/Animals/miauw.wav ; Windows Read from file: /Volumes/PORCH/Sounds/Animals/miauw.wav ; Mac Read from file: /media/PORCH/Sounds/Animals/miauw.wav ; Linux Instead of all these complete path names, you can use relative path names. These are taken as relative to the directory in which your script resides, and help to make your script portable if you move the script along with your data. Thus, if your script (after you have saved it!) is in the Animals folder mentioned above, i.e. in the same folder as miauw.wav, you would simply open the file with Read from file: miauw.wav If your script is in the Sounds folder mentioned above, i.e. in the same folder as where the Animals folder is, you would open the file with Read from file: Animals/miauw.aifc If your script is in the folder Scripts that is inside the Sounds folder, i.e. if your script is a sister folder of the Animals folder, you would open the file with Read from file: ../Animals/miauw.aifc where .. is the general way on all platforms to go one folder up in the hierarchy. Note that on Windows you could use the backslash (\) instead of the forward slash (/), but with the forward slash your script will work on all three platforms. 6. How to supply arguments automatically Now you know all the ways to write the arguments of commands in a script line. If you dislike manually copying arguments from settings windows into your script, or if you are not sure whether something is a numeric or a string argument, you can use the history mechanism: choose Clear history from the Edit menu in your ScriptEditor, click your command button, edit the arguments, and click OK. The command will be executed. Then choose Paste history, and the command line, including the arguments, will appear in the ScriptEditor at the position of the text cursor. You can build whole new scripts on the basis of this mechanism. Links to this page Scripting Scripting 3. Simple language elements 
Scripting_3_1__Hello_world	Scripting 3.1. Hello world Many manuals of computer programming languages start with their answer on the following question: How do I write the text Hello world on the screen? For the Praat scripting language, there are two answers. 1. Hello world in the Info window The simplest answer is that you open the ScriptEditor window with New Praat script from the Praat menu, then type the following line into the ScriptEditor window: writeInfoLine: Hello world and finally choose Run from the Run menu. When you try this, the result should be that the Info window comes to the front, and that it shows the text Hello world: Now suppose that you to write two lines instead of just one, so you try a script with two lines: writeInfoLine: Hello world writeInfoLine: How do you do? This turns out not to do what you want: it seems to write only the text How do you do?. This happens because the writeInfoLine function first erases the Info window, then writes the line of text. So the first line of the script did write the text Hello world, but the second line wiped it out and wrote How do you do? instead. The script that does what you want is writeInfoLine: Hello world appendInfoLine: How do you do? Now the result will be This works because appendInfoLine writes a line without erasing the Info window first. Finally, try the following script: appendInfoLine: Another try appendInfoLine: Goodbye The result could be In other words, appendInfoLine writes lines into the Info window without erasing it, even if you run a script anew. This is why many Praat scripts that write into the Info window do a writeInfoLine first, and follow it with a series of appendInfoLine calls. For more information on these commands, see Scripting 6.2. Writing to the Info window. 2. Hello world in the Picture window. You can also show text in the Picture window. If you are an experienced Praat user, you have probably used the comamnd Text top... before. You can use it do draw a text at the top of the current viewport, which is the part of the Picture window where the next drawing will occur and which is marked by the pink margins. Thus, when you select the top 4×3 inches of the Picture window (with the mouse), set the font size to 12 (with the Pen menu), and run the script Text top: yes, Hello world then you'll see So this works the same as when you choose Text top... from the Margins menu by hand, with Far switched on. If you want your script to always show the same text at the same position, with nothing else in the picture, then you can make your script a bit more extensive: Erase all Times Font size: 12 Select outer viewport: 0, 4, 0, 3 Text top: yes, Hello world In this script, line 1 erases the Picture window, so that nothing besides your text can appear in the Picture window. Line 2 executes the command Times from the Font menu, so that the script will always draw the text in Times, even if you choose Helvetica in the Font menu with the mouse before you run the script (after the script has run, you'll see that Times is chosen in the Font menu). Line 3 executes the command Font size... from the Font menu, setting the font size to 12 and setting the width of the pink margins accordingly. Line 4 executes the command Select outer viewport... from the Select menu. This performs an action that you would normally do by dragging the mouse, namely selecting the part of the Picture window that runs from 0 to 4 inches horizontally and from 0 to 3 inches vertically. After running the script, the viewport is indeed [0, 4] × [0, 3], as you can clearly see from the pink margins above. Line 5 finally writes the text. For more information on these commands, see Picture window. Links to this page Scripting Scripting 3. Simple language elements 
Scripting_3_2__Numeric_variables	Scripting 3.2. Numeric variables In any general procedural programming language you can work with variables, which are places in your computer's memory where you can store a number or anything else. For instance, you could put the number 3.1 into the variable b in the following way: b = 3.1 This statement is called as assignment, i.e., you assign the value 3.1 to the variable b. We read this statement aloud as b becomes 3.1. What this means is that after this statement, the memory location b contains the numeric value (number) 3.1. You can regard a variable as a box: you put the value 3.1 into the box named b. Or you can regard a variable as a house: the house is called b and now the family 3.1 is living there. Or you can regard it as any other storage location. To see what value a variable contains (what's in the box, or who lives in the house), you can use the writeInfoLine function: b = 3.1 writeInfoLine: The value is , b, . This will put the text The value is 3.1. into the Info window, as you are invited to verify. A variable is called a variable because it is variable, i.e. its value can change. Try the script b = 3.1 b = 5.8 writeInfoLine: The value is , b, . You will see that b ends up having the value 5.8. The first line puts the value 3.1 there, but the second line replaces it with 5.8. It's like taking the 3.1 out of the box and putting the 5.8 in its stead. Or the family 3.1 moves from the house, and the family called 5.8 moves in. In an assignment, the part to the right of the becomes sign (the = sign) doesn't have to be a number; it can be any formula that evaluates to a number. For instance, the script b = 3.1 * 2 writeInfoLine: The value is , b, . puts the text The value is 6.2. into the Info window. This works because Praat handles the first line in the following way: 1. the formula 3.1 * 2 is evaluated (i.e. its value is computed), and the result is 6.2. 2. the value 6.2 is subsequently stored in the variable b. After line 1 has been executed, the variable b just contains the value 6.2, nothing more; the variable b doesn't remember that that value has been computed by multiplying 3.1 with 2. Formulas can contain more things than numbers: they can also contain other variables: b = 3.1 c = b * 2 writeInfoLine: The value of b is , b, , and the value of c is , c, . In the first line, b gets the value 3.1. In the second line, the formula b * 2 first has to be evaluated. Praat looks up the value of b (which is 3.1), so that it knows that the formula actually means 3.1 * 2. Praat evaluates this formula and stores the result (namely the value 6.2) into the variable c, which will then contain nothing else than the value 6.2. The Info window thus reports The value of b is 3.1, and the value of c is 6.2.. After these explanations, consider the following script: b = 3.1 c = b * 2 b = 5.8 writeInfoLine: The value of c is , c, . Can you figure out what the Info will report? If you think it will report The value of c is 6.2., then you are correct: after the first line, b contains the value 3.1; after the second line, the value of c is therefore 6.2, and nothing more; after line 3, the value of b has changed to 5.8, but the value of c hasn't changed and is still 6.2. If you thought that c would end up having the value 11.6, then you're thinking in terms of a non-procedural language such as Prolog; you may have thought that the thing assigned to c in the second line is the whole formula b * 2, so that c changes when b changes. But this is not the case: the thing stored in c is just the value of the formula b * 2 at that moment, which is 6.2, and c doesn't remember how it got that value. If you have trouble understanding this, consult anybody who writes programs. Links to this page Scripting Scripting 3. Simple language elements Scripting 3.4. String variables Scripting 5.1. Variables 
Scripting_3_3__Numeric_queries	Scripting 3.3. Numeric queries Now that you know how to script a menu command, and you know how variables work, you are ready to combine the two. Suppose you have selected a Sound in the object list. One of the commands available in the Query menu is Get power.... When you choose it, you will see the following settings window: When you click OK, something like the following will appear in the Info window: This is the mean power of the whole Sound. In a script, you want to use the value of this power in the script itself, not in the Info window, perhaps because you want to do computations with it or because you want to report the value with a nice text around it. This is how you do the latter: power = Get power: 0.0, 0.0 writeInfoLine: The power of this sound is , power, Pascal-squared. The first line of this script executes the menu command Get power..., but puts the value 0.1350605005239421 into the variable power instead of into the Info window (the variable can have any name you like, as long as it starts with a lower-case letter and consists of letters and digits; see Scripting 5.1. Variables). The second line then reports the value in the Info window, this time with a nice text around it: Links to this page Scripting Scripting 3. Simple language elements Scripting 3.5. String queries 
Scripting_3_4__String_variables	Scripting 3.4. String variables Just as you can store numeric variables, you can store string variables, which contain text instead of numbers. Here is an example: word1$ = Hello word2$ = world sentence$ = word1$ + + word2$ writeInfoLine: The whole sentence is: , sentence$ Yes, this is another way to get the sentence Hello world into the Info window. It's a more linguistically valid way to do it, and here is how it works: 1. In line 1, the value Hello, which is a text (as we can see by its use of quotes), is stored into the variable word1$, which is a string variable (as we can see because its name ends in a dollar sign). 2. In line 2, the text value world is stored into the string variable word2$. 3. In line 3, we have the formula word1$ + + word2$, which contains two variables, namely word1$ and word2$. 4. The values of the two variables are Hello and world, respectively, so what the formula actually says is Hello + + world. 5. The pluses in the formula mean concatenate, so we concatenate the three strings Hello, , and world, giving the longer string Hello world. 6. Still in line 3, the string value Hello world is assigned to the string variable sentence$. 7. Line 4 reports in the Info window: The whole sentence is: Hello world Links to this page Scripting Scripting 3. Simple language elements Scripting 5.1. Variables 
Scripting_3_5__String_queries	Scripting 3.5. String queries Just as you can use menu commands (usually in a Query menu) to query numbers, you can query texts as well. For instance, when you select a Textgrid, the Query menu will contain the command Get label of interval..., which takes two numeric arguments, namely Tier number and Interval number: When you click OK, and interval 3 of tier 1 happens to contain the text hello, the following appears in the Info window: In a script, you will want to put the result of the query in a string variable instead of in the Info window, because you want to manipulate it further: text$ = Get label of interval: 1, 3 writeInfoLine: The text in interval 3 of tier 1 is: , text$ The script first stores the text of the interval, i.e. hello, into the variable text$, then writes it, preceded by some informative text, into the Info window: Hey, yet another way to implement Hello world with the Praat scripting language! The difference between numeric queries and string queries A string query stores in a string variable the whole text that would appear in the Info window. For instance, the script power$ = Get power: 0.0, 0.0 writeInfoLine: power$ could give you the following result: A numeric query stores in a numeric variable only the first number that it can find in the text that would appear in the Info window. For instance, the script power = Get power: 0.0, 0.0 writeInfoLine: power could give you the following result: Links to this page Scripting Scripting 3. Simple language elements Scripting 3.6. For loops Scripting 5.2. Expressions 
Scripting_3_6___For__loops	Scripting 3.6. For loops The power of a procedural programming language is most easily illustrated with the for-loop. Take the example of the previous page, whereas you wanted to know the text in the third interval of the first tier of a selected TextGrid. It's easy to imagine that you actually want the texts of all the first five intervals. With knowledge from the previous sections, you could write it like this: writeInfoLine: The texts in the first five intervals: text$ = Get label of interval: 1, 1 appendInfoLine: Interval 1: , text$ text$ = Get label of interval: 1, 2 appendInfoLine: Interval 2: , text$ text$ = Get label of interval: 1, 3 appendInfoLine: Interval 3: , text$ text$ = Get label of interval: 1, 4 appendInfoLine: Interval 4: , text$ text$ = Get label of interval: 1, 5 appendInfoLine: Interval 5: , text$ The result will be something like This can be done more nicely. The first step is to realize that the sentences starting with text$ are similar to each other, and the sentence starting with appendInfoLine are also similar to each other. They only differ in the interval number, and can therefore be made identical by using a variable for the interval number, like this: writeInfoLine: The texts in the first five intervals: intervalNumber = 1 text$ = Get label of interval: 1, intervalNumber appendInfoLine: Interval , intervalNumber, : , text$ intervalNumber = 2 text$ = Get label of interval: 1, intervalNumber appendInfoLine: Interval , intervalNumber, : , text$ intervalNumber = 3 text$ = Get label of interval: 1, intervalNumber appendInfoLine: Interval , intervalNumber, : , text$ intervalNumber = 4 text$ = Get label of interval: 1, intervalNumber appendInfoLine: Interval , intervalNumber, : , text$ intervalNumber = 5 text$ = Get label of interval: 1, intervalNumber appendInfoLine: Interval , intervalNumber, : , text$ A new trick that you see here is that as a numeric argument (Interval number, the second argument to Get label of interval...), you can use not only a number (as in all previous examples), but also a variable (intervalNumber). The rest of the script should be known stuff by now. The script above is long, but it can be made much shorter with the use of a for-loop: writeInfoLine: The texts in the first five intervals: for intervalNumber from 1 to 5 text$ = Get label of interval: 1, intervalNumber appendInfoLine: Interval , intervalNumber, : , text$ endfor The two lines that were repeated five times in the previous version now show up with indentation between a for line and its corresponding endfor. Those two lines (the text$ and the appendInfoLine line) are executed five times: for intervalNumber equal to 1, for intervalNumber equal to 2, for intervalNumber equal to 3, for intervalNumber equal to 4, and for intervalNumber equal to 5, in that order. In the above example, using a loop does not do much more than save eight lines, at the cost of adding two new lines. But imagine the case in which you want to list all the texts in the intervals: the version without the loop is no longer possible. By contrast, the version with the loop is still possible, because we have the command Get number of intervals..., which gives us the number of intervals in the specified tier (here, tier 1). So you do: numberOfIntervals = Get number of intervals: 1 writeInfoLine: The texts in all , numberOfIntervals, intervals: for intervalNumber from 1 to numberOfIntervals text$ = Get label of interval: 1, intervalNumber appendInfoLine: Interval , intervalNumber, : , text$ endfor This may yield something like This is the first script in this tutorial that is useful in itself. On the basis of it you can create all kinds of ways to list the texts in intervals. Here is how you would also list the durations of those intervals: numberOfIntervals = Get number of intervals: 1 writeInfoLine: The durations and texts in all , numberOfIntervals, intervals: for intervalNumber from 1 to numberOfIntervals startTime = Get start point: 1, intervalNumber endTime = Get end point: 1, intervalNumber duration = endTime - startTime text$ = Get label of interval: 1, intervalNumber appendInfoLine: Interval , intervalNumber, is , duration, seconds long and contains the text: , text$ endfor Links to this page Scripting Scripting 3. Simple language elements Scripting 3.7. Layout 
Scripting_3_7__Layout	Scripting 3.7. Layout This chapter handles the way you use white space, comments, and continuation lines in a Praat script. White space Praat ignores all white space (spaces and tabs) that you put at the beginning of lines. The indentation that you saw on the previous page was therefore used solely for readability. You are advised to use indenting, though, with three or four spaces for each level, as in the following example, which loops over all tiers and intervals of a TextGrid: writeInfoLine: The texts in all tiers and intervals: numberOfTiers = Get number of tiers for tierNumber from 1 to numberOfTiers numberOfIntervals = Get number of intervals: tierNumber for intervalNumber from 1 to numberOfIntervals text$ = Get label of interval: tierNumber, intervalNumber appendInfoLine: Tier , tierNumber, , interval , intervalNumber, : , text$ endfor endfor Praat also ignores lines that are empty or consist solely of white space, so you use those to structure your script visually. Comments Comments are lines that start with # or ;. Praat ignores these lines when your script is running: # Create 1 second of a sine wave with a frequency of 100 Hertz, # sampled at 44100 Hz: Create Sound from formula: sine, 1, 0, 1, 44100, sin (2*pi*100*x) Because of its visibility, you are advised to use # for comments that structure your script, and ; perhaps only for commenting out a statement, i.e. to temporarily put it before a line that you don't want to execute. Continuation lines There is normally one line per statement, and one statement per line. But some statements are very long, such as this one on a previous page: appendInfoLine: Interval , intervalNumber, is , duration, seconds long and contains the text: , text$ By making the current window wider, you can see that I really put this whole statement on a single line. I could have distributed it over two lines in the following way, by using three dots (an ellipsis): appendInfoLine: Interval , intervalNumber, is , duration, seconds long ... and contains the text: , text$ Here is another common type of example: Create Sound from formula: windowedSine, 1, 0, 1, 44100, ... 0.5 * sin(2*pi*1000*x) * exp(-0.5*((x-0.5)/0.1)^2) You will normally want to follow such an ellipsis with a space, unless you want to concatenate the parts of a long word: Select outer viewport: 0, 10, 0, 4 Text top: yes, It's a long way to Llanfairpwllgwyngyll ...gogerychwyrndrobwllllantysiliogogogoch, ... unless you start from Tyddyn-y-felin. Links to this page Scripting Scripting 3. Simple language elements 
Scripting_3__Simple_language_elements	Scripting 3. Simple language elements The Praat scripting language doesn't only call the menu commands discussed in the first and second chapters of this tutorial, it is only a general procedural programming language that allows you to compute numbers, handle texts, and make custom analyses. This chapter focuses on the things you need most. It is designed in such a way that you can work through it even if you haven't written computer programs before. Scripting 3.1. Hello world (writeInfoLine, appendInfoLine) Scripting 3.2. Numeric variables (assignments) Scripting 3.3. Numeric queries Scripting 3.4. String variables (assignments) Scripting 3.5. String queries Scripting 3.6. For loops (for, endfor) Scripting 3.7. Layout (white space, comments, continuation lines) Links to this page Scripting 
Scripting_4_1__Selecting_objects	Scripting 4.1. Selecting objects To simulate the mouse-clicked and dragged selection in the list of objects, you have the commands selectObject, plusObject and minusObject. Suppose you start Praat and use Create Sound as tone... to create a Sound called tone. In the object list it looks like 1. Sound tone. Suppose you then do To Spectrum... from the Analyse Spectrum menu. A second object, called 2. Spectrum tone appears in the list and is selected. To select and play the Sound, you can do either selectObject: 1 Play or selectObject: Sound tone Play So you can select an object either by its unique ID (identifier: the unique number by which it appears in the list) or by name. The function selectObject works by first deselecting all objects, and then selecting the one you mention. If you don't want to deselect the existing selection, you can use plusObject or minusObject. When the Sound is selected, you can select the Spectrum as well by doing plusObject: 2 or plusObject: Spectrum tone If you then want to deselect the Sound, and keep the Spectrum selected, you can do minusObject: 1 or minusObject: Sound tone All these functions can take more than one argument. To select the Sound and the Spectrum together, you can do selectObject: 1, 2 or selectObject: Sound tone, Spectrum tone or even selectObject: 1, Spectrum tone How to refer to objects created in your script In a script, you typically don't know whether the IDs of the objects are 1 and 2, or much higher numbers. Fortunately, commands that create a new object give you the ID of the object that is created, so that you can refer to the object later on. For instance, suppose you want to generate a sine wave, play it, draw its spectrum, and then throw away both the Sound and the Spectrum. Here is how you do it: sound = Create Sound as pure tone: sine377, ... 1, 0, 1, 44100, 377, 0.2, 0.01, 0.01 ; remember the ID of the Sound Play ; the Sound is selected, so it plays To Spectrum: yes Draw: 0, 5000, 20, 80, yes ; the Spectrum is selected, so it is drawn # Remove the created Spectrum and Sound: plusObject: sound ; the Spectrum was already selected Remove You could also select the objects by name: Create Sound as pure tone: sine377, ... 1, 0, 1, 44100, 377, 0.2, 0.01, 0.01 ; no need to remember the ID of the Sound Play ; the Sound is selected, so it plays To Spectrum: yes Draw: 0, 5000, 20, 80, yes ; the Spectrum is selected, so it is drawn # Remove the created Spectrum and Sound: plusObject: Sound sine377 ; the Spectrum was already selected Remove This works even if there are multiple objects called Sound sine377, because if there are more objects with the same name, selectObject and plusObject select the most recently created one, i.e., the one nearest to the bottom of the list of objects. Links to this page Scripting Scripting 4. Object selection Scripting 4.2. Removing objects 
Scripting_4_2__Removing_objects	Scripting 4.2. Removing objects In \SS4.1 we saw that objects could be removed by selecting them first and then calling the Remove command. A faster way is the removeObject function, which can also remove unselected objects: sound = Create Sound as pure tone: sine377, ... 1, 0, 1, 44100, 377, 0.2, 0.01, 0.01 ; remember the ID of the Sound Play ; the Sound is selected, so it plays spectrum = To Spectrum: yes ; remember the ID of the Spectrum Draw: 0, 5000, 20, 80, yes ; the Spectrum is selected, so it is drawn # Remove the created Spectrum and Sound: removeObject: sound, spectrum ; remove one selected and one unselected object The removeObject function keeps the objects selected that were selected before (except of course the ones it throws away). This allows you to easily throw away objects as soon as you no longer need them: sound = Create Sound as pure tone: sine377, ... 1, 0, 1, 44100, 377, 0.2, 0.01, 0.01 ; remember the ID of the Sound Play ; the Sound is selected, so it plays spectrum = To Spectrum: yes removeObject: sound ; we no longer need the Sound, so we remove it Draw: 0, 5000, 20, 80, yes ; the Spectrum is still selected, so it is drawn removeObject: spectrum ; remove the last object created by the script Selecting and removing all objects from the list (don't) A very strange command, which you should not normally use, is select all: select all Remove This selects all objects in the list and then removes them. Please try not to use this, because it will remove even the objects that your script did not create! After all, you don't want the users of your script to lose the objects they created! So please try to remove in your script only the objects that your script created, even if the script is for your own use (because if it is a nice script, others will want to use it). Links to this page Scripting Scripting 4. Object selection 
Scripting_4_3__Querying_objects	Scripting 4.3. Querying objects You can get the name of a selected object into a string variable. For instance, the following reads the name of the second selected Sound (as counted from the top of the list of objects) into the variable name$: name$ = selected$ (Sound, 2) If the Sound was called Sound hallo, the variable name$ will contain the string hallo. To get the name of the topmost selected Sound object, you can leave out the number: name$ = selected$ (Sound) To get the full name (type + name) of the third selected object, you do: fullName$ = selected$ (3) To get the full name of the topmost selected object, you do: fullName$ = selected$ () To get the type and name out of the full name, you do: type$ = extractWord$ (fullName$, ) name$ = extractLine$ (fullName$, ) Negative numbers count from the bottom. Thus, to get the name of the bottom-most selected Sound object, you say name$ = selected$ (Sound, -1) You would use selected$ for drawing the object name in a picture: Draw: 0, 0, 0, 0, yes name$ = selected$ (Sound) Text top: no, This is sound + name$ For identifying previously selected objects, this method is not very suitable, since there may be multiple objects with the same name: # The following two lines are OK: soundName$ = selected$ (Sound, -1) pitchName$ = selected$ (Pitch) # But the following line is questionable, since it doesn't # necessarily select the previously selected Pitch again: selectObject: Pitch + pitchName$ Instead of this error-prone approach, you should get the object's unique ID. The correct version of our example becomes: sound = selected (Sound, -1) pitch = selected (Pitch) # Correct: selectObject: pitch To get the number of selected Sound objects into a variable, use numberOfSelectedSounds = numberOfSelected (Sound) To get the number of selected objects into a variable, use numberOfSelectedObjects = numberOfSelected () Example: doing something to every selected Sound n = numberOfSelected (Sound) for i to n sound [i] = selected (Sound, i) endfor # Median pitches of all selected sounds: for i to n selectObject: sound [i] To Pitch: 0.0, 75, 600 f0 = Get quantile: 0, 0, 0.50, Hertz appendInfoLine: f0 Remove endfor # Restore selection: selectObject ( ) ; deselect all objects for i from 1 to n plusObject: sound [i] endfor Links to this page Scripting Scripting 4. Object selection 
Scripting_4__Object_selection	Scripting 4. Object selection This chapter is about how to select objects from your script, and how to find out what objects are currently selected. Scripting 4.1. Selecting objects Scripting 4.2. Removing objects Scripting 4.3. Querying objects Links to this page Scripting What was new in 4.5? 
Scripting_5_1__Variables	Scripting 5.1. Variables A variable is a location in your computer's memory that has a name and where you can store something, as explained in \SS3.2 and \SS3.4. In a Praat script, you can store numbers and texts, i.e. you can use numeric variables and string variables. Numeric variables Numeric variables can hold integer numbers between -1,000,000,000,000,000 and +1,000,000,000,000,000 or real numbers between -10308 and +10308. The smallest numbers lie near -10-308 and +10-308. You use numeric variables in your script like this: length = 10 Draw line: 0, length, 1, 1 This draws a line in the Picture window from position (0, 10) to position (1, 1). In the first line, you assign the value 10 to the variable called length, and in the second line you use the value of length as the second argument to the command Draw line.... Names of numeric variables must start with a lower-case letter, optionally followed by a sequence of letters, digits, and underscores. String variables You use string variables, which contain text, as follows: title$ = Dutch nasal place assimilation Text top: yes, title$ This writes the text Dutch nasal place assimilation As in the programming language Basic, the names of string variables end in a dollar sign. Making numeric variables visible You can write the content of numeric variables directly to the info window: x = 2.0 root = sqrt (x) writeInfoLine: The square root of , x, is , root, . This will write the following text to the Info window: The square root of 2 is 1.4142135623730951. You can fix the number of digits after the decimal point by use of the fixed$ function: x = 2.0 root = sqrt (x) writeInfoLine: The square root of , fixed$ (x, 3), is approximately , fixed$ (root, 3), . This will write the following text to the Info window: The square root of 2.000 is approximately 1.414. By using 0 decimal digits, you round to whole values: root = sqrt (2) writeInfoLine: The square root of 2 is very approximately , fixed$ (root, 0), . This will write the following text to the Info window: The square root of 2 is very approximately 1. By using the percent$ function, you give the result in a percent format: jitter = 0.0156789 writeInfoLine: The jitter is , percent$ (jitter, 3), . This will write the following text to the Info window: The jitter is 1.568%. The number 0, however, will always be written as 0, and for small numbers the number of significant digits will never be less than 1: jitter = 0.000000156789 writeInfoLine: The jitter is , percent$ (jitter, 3), . This will write the following text to the Info window: The jitter is 0.00002%. Predefined variables All of the variables you saw earlier in this tutorial were defined at the first moment a value was assigned to them. Some variables, however, are already defined implicitly at the start of your script. Some predefined numeric variables are macintosh, windows, and unix, which are 1 if the script is running on a Macintosh, Windows, or Unix platform (respectively), and which are otherwise zero. Another one is praatVersion, which is e.g. 5400 for the current version of Praat. Some predefined string variables are newline$, tab$, and shellDirectory$. The last one specifies the directory that was the default directory when Praat started up; you can use it in scripts that run from the Unix or Windows command line. Likewise, there exist the predefined string variables homeDirectory$, preferencesDirectory$, and temporaryDirectory$. These three refer to your home directory (which is where you log in), the Praat preferences directory, and a directory for saving temporary files; if you want to know what they are on your computer, try to write them into a script window. The variable defaultDirectory$ is available for formulas in scripts; it is the directory that contains the script file. Finally, we have praatVersion$, which is 5.4 for the current version of Praat. Functions that handle variables To check whether a variable exists, you can use the function variableExists (variableName$) Links to this page Scripting Scripting 3.3. Numeric queries Scripting 5. Language elements reference 
Scripting_5_2__Expressions	Scripting 5.2. Expressions In a Praat script, you can use numeric expressions as well as string expressions. Numeric expressions You can use a large variety of Formulas in your script: length = 10 height = length/2 area = length * height writeInfoLine: The area is , area, . You can use numeric variables and formulas in numeric arguments to commands: Draw line: 0, 0, length / 2, 2 * height You can use numeric expressions in assignments (as above), or after if, elsif, while, until, and twice after for. String expressions You can use a large variety of Formulas in your script: addressee$ = Silke greeting$ = Hi + addressee$ + ! writeInfoLine: The greeting is: , greeting$ You can use string variables and formulas in numeric arguments to commands: Draw line: 0, length (greeting$), 0, 100 Draw line: 0, if answer$ = yes then 20 else 30 fi, 0, 100 You can use numeric and string variables and formulas in string arguments to commands: Text top: yes, Hi + addressee$ + ! Text top: yes, left$ (fileName$, index (fileName$, .) - 1) The two examples from the end of \SS3.5 could be abbreviated as the one-liners writeInfoLine: do$ (Get power..., 0.0, 0.0) and writeInfoLine: do (Get power..., 0.0, 0.0) Assignments from query commands On how to get information from commands that normally write to the Info window, see Scripting 6.3. Query commands. Links to this page Scripting Scripting 5. Language elements reference 
Scripting_5_3__Jumps	Scripting 5.3. Jumps You can use conditional jumps in your script: if expression elsif expression if the expression evaluates to zero or false, the execution of the script jumps to the next elsif or after the next else or endif at the same depth. The following script computes the preferred length of a bed for a person 'age' years of age: if age <= 3 length = 1.20 elsif age <= 8 length = 1.60 else length = 2.00 endif A variant spelling for elsif is elif. Links to this page Scripting Scripting 5. Language elements reference 
Scripting_5_4__Loops	Scripting 5.4. Loops For loops for variable from expression1 to expression2 for variable to expression the statements between the for line and the matching endfor will be executed while a variable takes on values between two expressions, with an increment (raise) of 1 on each turn of the loop. If there is no from, the loop variable starts at 1. The following script plays nine sine waves, with frequencies of 200, 300, ..., 1000 Hz: for i from 2 to 10 Create Sound as pure tone: tone, 1, 0, 0.3, 44100, i * 100, 0.2, 0.01, 0.01 Play Remove endfor The stop value of the for loop is evaluated on each turn. If the second expression is already less than the first expression to begin with, the statements between for and endfor are not executed even once. Repeat loops until expression the statements between the matching preceding repeat and the until line will be executed again if the expression evaluates to zero or false. The following script measures the number of trials it takes me to throw 12 with two dice: throws = 0 repeat eyes = randomInteger (1, 6) + randomInteger (1, 6) throws = throws + 1 until eyes = 12 writeInfoLine: It took me , throws, trials to throw 12 with two dice. The statements in the repeat/until loop are executed at least once. While loops while expression if the expression evaluates to zero or false, the execution of the script jumps after the matching endwhile. endwhile execution jumps back to the matching preceding while line, which is then evaluated again. The following script forces the number x into the range [0; 2π): while x < 0 x = x + 2 * pi endwhile while x >= 2 * pi x = x - 2 * pi endwhile If the expression evaluates to zero or false to begin with, the statements between while and endwhile are not executed even once. Links to this page Scripting Scripting 5. Language elements reference Scripting 5.5. Procedures 
Scripting_5_5__Procedures	Scripting 5.5. Procedures Sometimes in a Praat script, you will want to perform the same thing more than once. In \SS5.4 we saw how loops can help there. In this section we will see how procedures (also called subroutines) can help us. Imagine that you want to play a musical note with a frequency of 440 Hz (an A) followed by a note that is one ocatve higher, i.e. has a frequency of 880 Hz (an a). You could achieve this with the following script: Create Sound as pure tone: note, 1, 0, 0.3, 44100, 440, 0.2, 0.01, 0.01 Play Remove Create Sound as pure tone: note, 1, 0, 0.3, 44100, 880, 0.2, 0.01, 0.01 Play Remove This script creates a sound with a sine wave with an amplitude of 0.4 and a frequency of 440 Hz, then plays this sound, then changes the sound into a sine wave with a frequency of 880 Hz, then plays this changed sound, and then removes the Sound object from the object list. This script is perfect if all you want to do is to play those two notes and nothing more. But now imagine that you want to play such an octave jump not only for a note of 440 Hz, but also for a note of 400 Hz and for a note of 500 Hz. You could use the following script: Create Sound as pure tone: note, 1, 0, 0.3, 44100, 440, 0.2, 0.01, 0.01 Play Remove Create Sound as pure tone: note, 1, 0, 0.3, 44100, 880, 0.2, 0.01, 0.01 Play Remove Create Sound as pure tone: note, 1, 0, 0.3, 44100, 400, 0.2, 0.01, 0.01 Play Remove Create Sound as pure tone: note, 1, 0, 0.3, 44100, 800, 0.2, 0.01, 0.01 Play Remove Create Sound as pure tone: note, 1, 0, 0.3, 44100, 500, 0.2, 0.01, 0.01 Play Remove Create Sound as pure tone: note, 1, 0, 0.3, 44100, 1000, 0.2, 0.01, 0.01 Play Remove This script works but is no longer perfect. It contains many similar lines, and is difficult to read. Here is where procedures come in handy. With procedures, you can re-use similar pieces of code. To make the three parts of the above script more similar, I'll rewrite it using two variables (frequency and octaveHigher): frequency = 440 Create Sound as pure tone: note, 1, 0, 0.3, 44100, frequency, 0.2, 0.01, 0.01 Play Remove octaveHigher = 2 * frequency Create Sound as pure tone: note, 1, 0, 0.3, 44100, octaveHigher, 0.2, 0.01, 0.01 Play Remove frequency = 400 Create Sound as pure tone: note, 1, 0, 0.3, 44100, frequency, 0.2, 0.01, 0.01 Play Remove octaveHigher = 2 * frequency Create Sound as pure tone: note, 1, 0, 0.3, 44100, octaveHigher, 0.2, 0.01, 0.01 Play Remove frequency = 500 Create Sound as pure tone: note, 1, 0, 0.3, 44100, frequency, 0.2, 0.01, 0.01 Play Remove octaveHigher = 2 * frequency Create Sound as pure tone: note, 1, 0, 0.3, 44100, octaveHigher, 0.2, 0.01, 0.01 Play Remove You can now see that seven lines of the script appear identically three times. I'll put those seven lines into a procedure that I name playOctave: procedure playOctave Create Sound as pure tone: note, 1, 0, 0.3, 44100, frequency, 0.2, 0.01, 0.01 Play Remove octaveHigher = 2 * frequency Create Sound as pure tone: note, 1, 0, 0.3, 44100, octaveHigher, 0.2, 0.01, 0.01 Play Remove endproc As you see, a procedure definition in Praat consists of three parts: 1. a line with the word procedure, followed by the name of the procedure, followed by a pair of parentheses; 2. the body of the procedure (here: seven lines); 3. a line with the word endproc. You can put a procedure definition anywhere in your script; the beginning or end of the script are common places. The bodies of procedures are executed only if you call the procedure explicitly, which you can do anywhere in the rest of your script: frequency = 440 @playOctave frequency = 400 @playOctave frequency = 500 @playOctave procedure playOctave Create Sound as pure tone: note, 1, 0, 0.3, 44100, frequency, 0.2, 0.01, 0.01 Play Remove octaveHigher = 2 * frequency Create Sound as pure tone: note, 1, 0, 0.3, 44100, octaveHigher, 0.2, 0.01, 0.01 Play Remove endproc This script works as follows. First, the number 440 is assigned to the variable frequency in line 1. Then, execution of the script arrives at the @ (call) statement of line 2. Praat then knows that it has to jump to the procedure called playOctave, which is found on line 7. The execution of the script then proceeds with the first line of the procedure body, where a Sound is created. Then, the other lines of the procedure body are also executed, ending with the removal of the Sound. Then, the execution of the script arrives at the endproc statement. Here, Praat knows that it has to jump back to the line after the line that the procedure was called from; since the procedure was called from line 2, the execution proceeds at line 3 of the script. There, the number 400 is assigned to the variable frequency. In line 4, execution will jump to the procedure again, and with the next endproc the execution will jump back to line 5. There, 500 is assigned to frequency, followed by the third jump to the procedure. the third endproc jumps back to the line after the third @, i.e. to line 7. Here the execution of the script will stop, because there are no more executable commands (the procedure definition at the end is not executed again). Arguments The above example contains something awkward. The procedure playOctave requires that the variable frequency is set to an appropriate value, so before calling playOctave you always have to insert a line like frequency = 440 This can be improved upon. In the following version of the script, the procedure playOctave requires an explicit argument: @playOctave: 440 @playOctave: 400 @playOctave: 500 procedure playOctave: frequency Create Sound as pure tone: note, 1, 0, 0.3, 44100, frequency, 0.2, 0.01, 0.01 Play Remove octaveHigher = 2 * frequency Create Sound as pure tone: note, 1, 0, 0.3, 44100, octaveHigher, 0.2, 0.01, 0.01 Play Remove endproc This works as follows. The first line of the procedure now not only contains the name (playOctave), but also a list of variables (here only one: frequency). In the first line of the script, the procedure playOctave is called with the argument 440. Execution then jumps to the procedure, where the argument 440 is assigned to the variable frequency, which is then used in the body of the procedure. Encapsulation and local variables Although the size of the script has now been reduced to 12 lines, which cannot be further improved upon, there is still something wrong with it. Imagine the following script: frequency = 300 @playOctave: 440 @playOctave: 400 @playOctave: 500 writeInfoLine: frequency procedure playOctave: frequency Create Sound from formula: note, 1, 0, 0.3, 44100, frequency, 0.2, 0.01, 0.01 Play Remove octaveHigher = 2 * frequency Create Sound from formula: note, 1, 0, 0.3, 44100, octaveHigher, 0.2, 0.01, 0.01 Play Remove endproc You might have thought that this script will write 300 to the Info window, because that is what you expect if you look at the first five lines. However, the procedure will assign the values 440, 400, and 500 to the variable frequency, so that the script will actually write 500 to the Info window, because 500 is the last (fourth!) value that was assigned to the variable frequency. What you would want is that variables that are used inside procedures, such as frequency and octaveHigher here, could somehow be made not to clash with variable names used outside the procedure. A trick that works would be to include the procedure name into the names of these variables: frequency = 300 @playOctave: 440 @playOctave: 400 @playOctave: 500 writeInfoLine: frequency procedure playOctave: playOctave.frequency Create Sound as pure tone: note, 1, 0, 0.3, 44100, playOctave.frequency, 0.2, 0.01, 0.01 Play Remove playOctave.octaveHigher = 2 * playOctave.frequency Create Sound as pure tone: note, 1, 0, 0.3, 44100, playOctave.octaveHigher, 0.2, 0.01, 0.01 Play Remove endproc This works. The six tones will be played, and 300 will be written to the Info window. But the formulation is a bit wordy, isn't it? Fortunately, Praat allows an abbreviated version of these long names: just leave playOctave off from the names of the variables, but keep the period (.): frequency = 300 @playOctave: 440 @playOctave: 400 @playOctave: 500 writeInfoLine: frequency procedure playOctave: .frequency Create Sound as pure tone: note, 1, 0, 0.3, 44100, .frequency, 0.2, 0.01, 0.01 Play Remove .octaveHigher = 2 * .frequency Create Sound as pure tone: note, 1, 0, 0.3, 44100, .octaveHigher, 0.2, 0.01, 0.01 Play Remove endproc This is the final version of the script. It works because Praat knows that you are using the variable names .frequency and .octaveHigher in the context of the procedure playOctave, so that Praat knows that by these variable names you actually mean to refer to playOctave.frequency and playOctave.octaveHigher. It is advisable that you use such local variable names for all parameters of a procedure, i.e. for the variables listed after the procedure word (e.g. .frequency), as well as for all variables that you create in the procedure body (e.g. .octaveHigher). In this way, you make sure that you don't inadvertently use a variable name that is also used outside the procedure and thereby perhaps inadvertently change the value of a variable that you expect to be constant across a procedure call. A list of numeric and string arguments You can use multiple arguments, separated by commas, and string arguments (with a dollar sign in the variable name): @listSpeaker: Bart, 38 @listSpeaker: Katja, 24 procedure listSpeaker: .name$, .age appendInfoLine: Speaker , .name$, is , .age, years old. endproc or @conjugateVerb: be, I am, you are, she is procedure conjugateVerb: .verb$, .first$, .second$, .third$ writeInfoLine: Conjugation of 'to , .verb$, ': appendInfoLine: 1sg , .first$ appendInfoLine: 2sg , .second$ appendInfoLine: 3sg , .third$ endproc For the arguments you can use expressions: @playOctave: 400 + 100 As with all string literals, the double quotes in literal string arguments should be doubled: procedure texts: .top$, .bottom$ Text top: yes, .top$ Text bottom: yes, .bottom$ endproc @texts: hello at the top, goodbye at the bottom Functions The Praat scripting language does not have the concept of a function like some other scripting languages do. A function is a procedure that returns a number or a string. For instance, you can imagine the function squareNumber which takes a number (e.g. 5) as an argument and returns the square of that number (e.g. 25). Here is an example of how you can do that, using the global availability of local variables: @squareNumber: 5 writeInfoLine: The square of 5 is , squareNumber.result, . procedure squareNumber: .number .result = .number ^ 2 endproc Another way to emulate functions is to use a variable name as an argument: @squareNumber: 5, square5 writeInfoLine: The square of 5 is , square5, . procedure squareNumber: .number, .squareVariableName$ '.squareVariableName$' = .number ^ 2 endproc However, this uses variable substitution, a trick better avoided. Links to this page Scripting Scripting 5. Language elements reference 
Scripting_5_6__Arrays	Scripting 5.6. Arrays You can use arrays of numeric and string variables: for i from 1 to 5 square [i] = i * i text$ [i] = mid$ (hello, i) endfor After this, the variables square[1], square[2], square[3], square[4], square[5], text$[1], text$[2], text$[3], text$[4], and text$[5] contain the values 1, 4, 9, 16, 25, h, e, l, l, and o, respectively: writeInfoLine: Some squares: for i from 1 to 5 appendInfoLine: The square of , i, is , square [i] endfor You can use any number of variables in a script, but you can also use Matrix or Sound objects for arrays. Links to this page Scripting Scripting 5. Language elements reference What was new in 5.3? 
Scripting_5_7__Including_other_scripts	Scripting 5.7. Including other scripts You can include other scripts within your script: a = 5 include square.praat writeInfoLine: a The Info window will show the result 25 if the file square.praat contains the following: a = a * a The inclusion is done before any other part of the script is considered, so you can use the form statement and all variables in it. Usually, however, you will put some procedure definitions in the include file, that is what it seems to be most useful for. Watch out, however, for using variable names in the include file: the example above shows that there is no such thing as a separate name space. Note that you do not put quotes around the name of the include file. This is because the name of the include file has to be given explicitly; you cannot put it into a variable, for instance. You can use full or relative file names. For instance, the file square.praat is expected to be in the same directory as the script that says include square.praat. If you use the ScriptEditor, you will first have to save the script that you are editing before any relative file names become meaningful (this is the same as with other uses of relative file names in scripts). You can nest include files, i.e., included scripts can include other scripts. However, relative file names are always evaluated relative to the directory of the outermost script. The include statement can only be at the start of a line: you cannot put any spaces in front of it. Links to this page Scripting Scripting 5. Language elements reference What was new in 4.1? 
Scripting_5_8__Quitting	Scripting 5.8. Quitting Usually, the execution of your script ends when the interpreter has executed the last line that is not within a procedure definition. However, you can also explicitly stop the script: exitScript ( ) stops the execution of the script in the normal way, i.e. without any messages to the user. Any settings window is removed from the screen. exitScript: error-message stops the execution of the script while sending an error message to the user. You can use the same argument list as with writeInfoLine. Any settings window will stay on the screen. For an example, see Scripting 6.8. Messages to the user. Links to this page Scripting Scripting 5. Language elements reference 
Scripting_5__Language_elements_reference	Scripting 5. Language elements reference In a Praat script, you can use variables, expressions, and functions, of numeric as well as string type, and most of the control structures known from other procedural computer languages. The way the distinction between numbers and strings is made, may remind you of the programming language Basic. Scripting 5.1. Variables (numeric, string) Scripting 5.2. Expressions (numeric, string) Scripting 5.3. Jumps (if, then, elsif, else, endif) Scripting 5.4. Loops (for/endfor, while/endwhile, repeat/until) Scripting 5.5. Procedures (@, procedure) Scripting 5.6. Arrays Scripting 5.7. Including other scripts Scripting 5.8. Quitting (exit) Links to this page Scripting 
Scripting_6_1__Arguments_to_the_script	Scripting 6.1. Arguments to the script You can cause a Praat script to prompt for arguments. The file playSine.praat may contain the following: form Play a sine wave positive Sine_frequency_(Hz) 377 positive Gain_(0..1) 0.3 (= not too loud) endform Create Sound as pure tone: sine + string$ (sine_frequency), 1, 0, 1, 44100, sine_frequency, gain, 0.01, 0.01 Play Remove When running this script, the interpreter puts a settings window (form) on your screen, entitled Play a sine wave, with two fields, titled Sine frequency (Hz) and Gain, that have been provided with the standard values 377 and 0.3 (= not too loud), which you can change before clicking OK. As you see, the underscores have been replaced with spaces: that looks better in the form. Inside the script, the field names can be accessed as variables: these do contain the underscores, since they must not contain spaces, but the parentheses (Hz) have been chopped off. Note that the first letter of these variables is converted to lower case, so that you can assign to them in your script. Inside the script, the value 0.3 (= not too loud) will be known as 0.3, because this is a numeric field. You can use the following field types in your forms: real variable initialValue for real numbers. positive variable initialValue for positive real numbers: the form issues an error message if the number that you enter is negative or zero; further on in the script, the number may take on any value. integer variable initialValue for whole numbers: the form reads the number as an integer; further on in the script, the number may take on any real value. natural variable initialValue for positive whole numbers: the form issues an error message if the number that you enter is negative or zero; further on in the script, the number may take on any real value. word variable initialValue for a string without spaces: the form only reads up to the first space (oh yes becomes oh); further on in the script, the string may contain spaces. sentence variable initialValue for any short string. text variable initialValue for any possibly long string (the variable name will not be shown in the form). boolean variable initialValue a check box will be shown; the value is 0 if off, 1 if on. choice variable initialValue a radio box will be shown; the value is 1 or higher. This is followed by a series of: button text a button in a radio box. comment text a line with any text. Inside the script, strings are known as string variables, numbers as numeric variables. Consider the following form: form Sink it sentence Name_of_the_ship Titanic real Distance_to_the_iceberg_(m) 500.0 natural Number_of_people 1800 natural Number_of_boats 10 endform In the script following this form, the variables will be known as name_of_the_ship$, distance_to_the_iceberg, number_of_people, and number_of_boats. The variable associated with a radio box will get a numeric as well as a string value: form Fill attributes comment Choose any colour and texture for your paintings choice Colour: 5 button Dark red button Sea green button Navy blue button Canary yellow button Black button White choice Texture: 1 button Smooth button Rough button With holes endform writeInfoLine: You chose the colour , colour$, and the texture , texture$, . This shows two radio boxes. In the Colour box, the fifth button (Black) is the standard value here. If you click on Navy blue and then OK, the variable colour will have the value 3, and the variable colour$ will have the value Navy blue. Note that the trailing colon is chopped off, and that the button and comment texts may contain spaces. So you can test the value of the Colour box in either of the following ways: if colour = 4 or if colour$ = Canary yellow The field types optionmenu and option are completely analogous to choice and button, but use up much less space on the screen: form Fill attributes comment Choose any colour and texture for your paintings optionmenu Colour: 5 option Dark red option Sea green option Navy blue option Canary yellow option Black option White optionmenu Texture: 1 option Smooth option Rough option With holes endform writeInfoLine: You chose the colour , colour$, and the texture , texture$, . You can combine two short fields into one by using left and right: form Get duration natural left_Year_range 1940 natural right_Year_range 1945 endform duration = right_Year_range - left_Year_range writeInfoLine: The duration is , duration, years. The interpreter will only show the single text Year range, followed by two small text fields. Calling a script from another script Scripts can be nested: the file doremi.praat may contain the following: runScript: playSine.praat, 550, 0.9 runScript: playSine.praat, 615, 0.9 runScript: playSine.praat, 687, 0.9 With runScript, Praat will not display a form window, but simply execute the script with the two arguments that you supply on the same line (e.g. 550 and 0.9). Values for choice must be passed as strings: runScript: fill attributes.praat, Navy blue, With holes You can pass values for boolean either as yes and no or as 1 and 0. Links to this page Scripting Scripting 6. Communication outside the script Scripting 6.6. Controlling the user Scripting 6.9. Calling from the command line 
Scripting_6_2__Writing_to_the_Info_window	Scripting 6.2. Writing to the Info window With the Info button and several commands in the Query menus, you write to the Info window (if your program is run from the command line, the text goes to the console window or to stdout instead; see \SS6.9). The commands writeInfo, writeInfoLine, appendInfo and appendInfoLine allow you to write to the Info window from a script. Those with write in their name clear the Info window before they write to it, those with append in their name do not. Those with Line in their name make sure that a following appendInfo or appendInfoLine will write on the next line. These four functions take a variable number of numeric and/or string arguments, separated by commas. The following script builds a table with statistics about a pitch contour: writeInfoLine: Minimum Maximum Create Sound as pure tone: sine, 1, 0, 0.1, 44100, 377, 0.2, 0.01, 0.01 To Pitch: 0.01, 75, 600 minimum = Get minimum: 0, 0, Hertz, Parabolic appendInfo: minimum appendInfo: tab$ maximum = Get maximum: 0, 0, Hertz, Parabolic appendInfo: maximum appendInfoLine: You could combine the last four print statements into: appendInfoLine: minimum, tab$, maximum which is the same as: appendInfo: minimum, tab$, maximum, newline$ The little string tab$ is a tab character; it allows you to create table files that can be read by some spreadsheet programs. The little string newline$ is a newline character; it moves the following text to the next line. To clear the Info window, you can do writeInfo: or clearinfo Links to this page Scripting Scripting 3.1. Hello world Scripting 6. Communication outside the script 
Scripting_6_3__Query_commands	Scripting 6.3. Query commands If you click the Get mean... command for a Pitch object, the Info window will contain a text like 150 Hz as a result. In a script, you would rather have this result in a variable instead of in the Info window. The solution is simple: mean = Get mean: 0, 0, Hertz, Parabolic The numeric variable mean now contains the number 150. When assigning to a numeric variable, the interpreter converts the part of the text before the first space into a number. You can also assign to string variables: mean$ = Get mean: 0, 0, Hertz, Parabolic The string variable mean$ now contains the entire string 150 Hz. This works for every command that would otherwise write into the Info window. Links to this page Query Scripting Scripting 5.2. Expressions Scripting 6. Communication outside the script 
Scripting_6_4__Files	Scripting 6.4. Files You can read from and write to text files from a Praat script. Reading a file You can check the availability of a file for reading with the function fileReadable (fileName$) which returns 1 (true) if the file exists and can be read, and 0 (false) otherwise. Note that fileName$ is taken relatively to the directory where the script is saved; for instance, if your script is in the directory Paolo/project1, then the file name hello.wav refers to Paolo/project1/hello.wav, the file name yesterday/hello.wav refers to Paolo/project1/yesterday/hello.wav, and the file name ../project2/hello.wav refers to Paolo/project2/hello.wav (.. goes one directory up). You can also use full path names such as C:/Documents and Settings/Paolo/project1/hello.wav on Windows and /Users/Paolo/project1/hello.wav on the Mac. To read the contents of an existing text file into a string variable or into a numeric variable, you use text$ = readFile$ (myFile.txt) or number = readFile (myFile.txt) If the file does not exist, the script terminates with an error message. Example: reading a settings file Suppose that the file height.inf may contain an appropriate value for a numeric variable called height, which we need to use in our script. We would like to read it with height = readFile (height.inf) However, this script will fail if the file height.inf does not exist. To guard against this situation, we could check the existence of the file, and supply a default value in case the file does not exist: fileName$ = height.inf if fileReadable (fileName$) height = readFile (fileName$) else height = 180 endif Writing a file You write into a new text file just as you write into the Info window: writeFileLine: myFile.txt, The present year is , 2000 + 13, . and likewise you use writeFile if you don't want a newline symbol at the end of the file. If the file cannot be created, the script terminates with an error message. To append text at the end of an existing file, you use appendFileLine: myFile.txt, Next year it will be , 2000 + 14, . With appendFileLine (and appendFile, which does not add the newline), we follow the rule that if the file does not yet exist, it is created first. You can create a directory with createDirectory: directoryName$ where, as with file names, directoryName$ can be relative to the directory of the script (e.g. data, or yesterday/data, or ../project2/yesterday/data) or an absolute path (e.g. C:/Documents and Settings/Paolo/project1/yesterday/data on Windows or /Users/Paolo/project1/yesterday/data on the Mac). If the directory already exists, this command does nothing. You can delete an existing file with the function deleteFile: fileName$ If the file does not exist, this command does nothing. Example: writing a table of squares Suppose that we want to create a file with the following text: The square of 1 is 1 The square of 2 is 4 The square of 3 is 9 ... The square of 100 is 10000 We can do this by appending 100 lines: deleteFile: squares.txt for i to 100 appendFileLine: squares.txt, The square of , i, is , i * i endfor Note that we delete the file before appending to it, in order that we do not append to an already existing file. You can append the contents of the Info window to a file with appendFile: out.txt, info$ ( ) Directory listings To get the names of the files if a certain type in a certain directory, use Create Strings as file list.... Alternative syntax If, on the basis of the syntax of commands and functions in earlier sections you expected that text$ = readFile$ (myFile.txt) number = readFile (myFile.txt) could be written as text$ = readFile$: myFile.txt number = readFile: myFile.txt then you are right. The syntax with the colon is equivalent to the syntax with the two parentheses. Conversely, instead of deleteFile: fileName$ you can also write deleteFile (fileName$) Links to this page Scripting Scripting 6. Communication outside the script 
Scripting_6_5__Calling_system_commands	Scripting 6.5. Calling system commands From a Praat script you can call system commands. These are the same commands that you would normally type into a terminal window or into the Window command line prompt. system command executes a system command. Some system commands are identical on all platforms (Macintosh, Windows, Unix): system mkdir sounds which creates a new directory sounds in the directory of the script. Some other system commands are different on different platforms. For instance, to throw away all WAV files in the script's directory, you would write system del *.wav on Windows, but system rm *.wav on Macintosh and Unix. The script will stop running if a system command returns an error. For instance, system mkdir sounds will stop the script if the directory sounds already exists. In order to prevent this, you can tell Praat to ignore the return value of the system command: system_nocheck command executes a system command, ignoring any errors. Thus, to make sure that the directory sounds exists, you would write system_nocheck mkdir sounds environment$ (symbol-string) returns the value of an environment variable, e.g. homeDirectory$ = environment$ (HOME) stopwatch returns the time that has elapsed since the previous stopwatch. Here is a Praat script that measures how long it takes to do a million assignments: stopwatch for i to 1000000 a = 1.23456789e123 endfor time = stopwatch writeInfoLine: a, , fixed$ (time, 3) Links to this page Scripting Scripting 6. Communication outside the script 
Scripting_6_6__Controlling_the_user	Scripting 6.6. Controlling the user You can temporarily halt a Praat script: pauseScript: message suspends execution of the script, and allows the user to interrupt it. A message window will appear with the message (you can use the same argument list as with writeInfoLine) and the buttons Stop and Continue: pauseScript: The next file will be , fileName$ The pauseScript function is useful if you want to send a simple message to the user, and you only want to ask the user whether she wants to proceed or not. More interesting interactions between your script and the user are possible with the pause window. In a pause window you can include the same kinds of arguments as in a form. Here is an extensive example: writeInfoLine: script compression = 1 number_of_channels = 2 worth = 3 for i to 5 beginPause: Hi comment: Type a lot of nonsense below. natural: Number of people, 10 real: Worth, worth + 1 positive: Sampling frequency (Hz), 44100.0 (= CD quality) word: hi, hhh sentence: lo, two words text: ko, jkgkjhkj g gdfg dfg boolean: You like it?, 1 if worth < 6 choice: Compression, compression option: lossless (FLAC) option: MP3 option: Ogg endif optionMenu: Number of channels, number_of_channels option: mono option: stereo option: quadro comment: Then click Stop or one of the continuation buttons. clicked = endPause: Continue, Next, Proceed, 2 appendInfoLine: number_of_people, , worth, , sampling_frequency, , clicked appendInfoLine: Compression: , compression, (, compression$ appendInfoLine: Number of channels: , number_of_channels$ endfor This example uses several tricks. A useful one is seen with number_of_channels: this is at the same time the value that is passed to optionMenu (and therefore determines the setting of the Number of channels menu when the window appears) and the name of the variable in which the user's chosen value of Number of channels is stored (because number_of_channels is what you get by replacing the spaces in Number of channels with underscores and turning its first letter to lower case. Your own pause windows are not likely to be as rich as the above example. For instance, the example has three continuation buttons (the second of these is the default button, i.e. the button that you can click by pressing the Enter or Return key). You will often use only one continuation button, for instance endPause: Continue, 1 or endPause: Finish, 1 or endPause: OK, 1 If your script shows multiple different pause windows, then it is in fact a wizard, and it becomes useful to have endPause: Next, 1 for most of them, and endPause: Finish, 1 for the last one. The possibility of multiple continuation buttons can save the user a mouse click. The following script, for instance, requires two mouse clicks per sound: for i to 20 Read from file: sound + string$ (i) + .wav Play Remove beginPause: Rate the quality comment: How good is the sound on a scale from 1 to 7? choice: Quality, 4 option: 1 option: 2 option: 3 option: 4 option: 5 option: 6 option: 7 endPause: if i = 20 then Finish else Next fi, 1 appendInfoLine: quality endfor The following script works faster: for i to 20 Read from file: sound + string$ (i) + .wav Play Remove beginPause: Rate the quality comment: How good is the sound on a scale from 1 to 7? quality = endPause: 1, 2, 3, 4, 5, 6, 7, 0 appendInfoLine: quality endfor In this example, the 0 at the end of endPause means that there is no default button. File selection If you want the user to choose a file name for reading (opening), do fileName$ = chooseReadFile$: Open a table file if fileName$ <> table = Read Table from tab-separated file: fileName$ endif A file selector window will appear, with (in this example) Open a table file as the title. If the user clicks OK, the variable fileName$ will contain the name of the file that the user selected; if the user clicks Cancel, the variable fileName$ will contain the empty string (). If you want the user to choose a file name for writing (saving), do selectObject: mySound fileName$ = chooseWriteFile$: Save as a WAV file, mySound.wav if fileName$ <> Save as WAV file: fileName$ endif A file selector window will appear, with (in this example) Save as a WAV file as the title and mySound.wav as the suggested file name (which the user can change). If the user clicks OK, the form will ask for confirmation if the file name that the user typed already exists. If the user clicks OK with a new file name, or clicks OK in the confirmation window, the variable fileName$ will contain the file name that the user typed; if the user clicks Cancel at any point, the variable fileName$ will contain the empty string (). If you want the user to choose a directory (folder) name, do directoryName$ = chooseDirectory$: Choose a directory to save all the new files in if directoryName$ <> for i to numberOfSelectedSounds selectObject: sound [i] Save as WAV file: directoryName$ + /sound + string$ (i) + .wav endfor endif A directory selector window will appear, with (in this example) Choose a directory to save all the new files in as the title. If the user clicks OK, the variable directoryName$ will contain the name of the directory that the user selected; if the user clicks Cancel, the variable directoryName$ will contain the empty string (). A non-pausing pause window without a Stop button Especially if you use the pause window within the Demo window, you may not want to give the user the capability of ending the script by hitting Stop or closing the pause window. In that case, you can add an extra argument to endPause that denotes the cancel button: beginPause: Learning settings positive: Learning rate, 0.01 choice: Directions, 3 option: Forward option: Backward option: Bidirectional clicked = endPause: Cancel, OK, 2, 1 if clicked = 2 learningRate = learning_rate includeForward = directions = 1 or directions = 3 includeBackward = directions = 2 or directions = 3 endif In this example, the default button is 2 (i.e. OK), and the cancel button is 1 (i.e. Cancel). The form will now contain no Stop button, and if the user closes the window, this will be the same as clicking Cancel, namely that clicked will be 1 (because the Cancel button is the first button) and the variables learning_rate, directions and directions$ will not be changed (i.e. they might remain undefined). Links to this page Scripting Scripting 6. Communication outside the script What was new in 5.1? What was new in 5.2? What was new in 5.3? 
Scripting_6_7__Sending_a_message_to_another_program	Scripting 6.7. Sending a message to another program To send messages to running programs that use the Praat shell, use sendpraat (see Scripting 8. Controlling Praat from another program). To send a message to another running program that listens to a socket, you can use the sendsocket directive. This works on Unix and Windows only. Example Suppose we are in the Praat-shell program Praat, which is a system for doing phonetics by computer. From this program, we can send a message to the non-Praat-shell program MovieEdit, which does know how to display a sound file: Save as file: hallo.wav sendsocket fonsg19.hum.uva.nl:6667 display hallo.wav In this example, fonsg19.hum.uva.nl is the computer on which MovieEdit is running; you can specify any valid Internet address instead, as long as that computer allows you to send messages to it. If MovieEdit is running on the same computer as Praat, you can specify localhost instead of the full Internet address. The number 6667 is the port number on which MovieEdit is listening. Other programs will use different port numbers. Links to this page Scripting Scripting 6. Communication outside the script What was new in 3.9? 
Scripting_6_8__Messages_to_the_user	Scripting 6.8. Messages to the user If the user makes a mistake (e.g. types conflicting settings into your form window), you can use the exitScript function (\SS5.8) to stop the execution of the script with an error message: form My analysis real Starting_time_(s) 0.0 real Finishing_time_(s) 1.0 endform if finishing_time <= starting_time exitScript: The finishing time should exceed , starting_time, seconds. endif # Proceed with the analysis... For things that should not normally go wrong, you can use the assert directive: power = Get power assert power > 0 This is the same as: if (power > 0) = undefined exitScript: Assertion failed in line , lineNumber, (undefined): power > 0 elsif not (power > 0) exitScript: Assertion failed in line , lineNumber, (false): power > 0 endif You can prevent Praat from issuing warning messages: nowarn Save as WAV file: hello.wav This prevents warning messages about clipped samples, for instance. You can also prevent Praat from showing a progress window: noprogress To Pitch: 0, 75, 500 This prevents the progress window from popping up during lengthy operations. Use this only if you want to prevent the user from stopping the execution of the script. Finally, you can make Praat ignore error messages: nocheck Remove This would cause the script to continue even if there is nothing to remove. Links to this page Scripting Scripting 6. Communication outside the script 
Scripting_6_9__Calling_from_the_command_line	Scripting 6.9. Calling from the command line Previous sections of this tutorial have shown you how to run a Praat script from the Script window. However, you can also call a Praat script from the command line (text console) instead. Information that would normally show up in the Info window, then goes to stdout, and error messages go to stderr. You cannot use commands like View & Edit. Command lines on Unix and Macintosh On Unix or MacOS X, you call Praat scripts from the command line like this: > /people/mietta/praat doit.praat 50 hallo or > /Applications/Praat.app/Contents/MacOS/Praat doit.praat 50 hallo This opens Praat, runs the script doit.praat with arguments 50 and hallo, and closes Praat. You also have the possibility of running the program interactively from the command line: > /people/mietta/praat - You can then type in any of the fixed and dynamic commands, and commands that handle object selection, like select. This method also works in pipes: > echo Statistics... | /people/mietta/praat - Command lines on Windows On Windows, you call Praat scripts from the command line like this: e:\praatcon.exe e:\doit.praat 50 hallo Note that you use the program praatcon.exe instead of praat.exe. The script will write to the console output in UTF-16 Little Endian encoding. If you want to use ISO Latin-1 encoding instead, or if you want to use praatcon's output in a pipe or redirect it to a file, use praatcon -a instead. How to get arguments into the script In the above example, the script doit.praat requires two arguments. In the script doit.praat, you use form and endform to receive these arguments. See Scripting 6.1. Arguments to the script. As with runScript, Praat will not present a form window, but simply run the script with the arguments given on the command line. The example given in Scripting 6.1. Arguments to the script will be called in the following way: > /people/mietta/praat playSine.praat 550 0.9 or e:\praatcon.exe playSine.praat 550 0.9 Links to this page Scripting Scripting 6. Communication outside the script Scripting 6.2. Writing to the Info window Scripting 8.1. The sendpraat subroutine 
Scripting_6__Communication_outside_the_script	Scripting 6. Communication outside the script Scripting 6.1. Arguments to the script (form/endform, runScript) Scripting 6.2. Writing to the Info window (writeInfoLine, appendInfoLine, appendInfo, tab$) Scripting 6.3. Query commands (Get, Count) Scripting 6.4. Files (fileReadable, readFile, writeFile, deleteFile, createDirectory) Scripting 6.5. Calling system commands (system, environment$, stopwatch) Scripting 6.6. Controlling the user (pause, beginPause/endPause, chooseReadFile$) Scripting 6.7. Sending a message to another program (sendsocket) Scripting 6.8. Messages to the user (exitScript, assert, nowarn, nocheck) Scripting 6.9. Calling from the command line Links to this page Scripting 
Scripting_7_1__Scripting_an_editor_from_a_shell_script	Scripting 7.1. Scripting an editor from a shell script From a Praat shell script, you can switch to an editor and back again: sound$ = hallo start = 0.3 finish = 0.7 sound = Read from file: sound$ + .aifc View & Edit editor: sound Zoom: start, finish endeditor Play This script reads a sound file from disk, pops up an editor for the resulting object, makes this editor zoom in on the part between 0.3 and 0.7 seconds, and returns to the Praat shell to play the entire sound. After editor you can either give the unique id of the object, as above, or its name: editor: Sound + sound$ Links to this page FAQ: Scripts Scripting Scripting 7. Scripting the editors 
Scripting_7_2__Scripting_an_editor_from_within	Scripting 7.2. Scripting an editor from within This section will show how you can permanently extend the functionality of an editor. As an example, consider the following problem: you want to see a graphic representation of the spectrum of the sound around the cursor position in the SoundEditor. To achieve this, follow these steps: 1. Create a Sound. 2. View it in a SoundEditor by clicking View & Edit. 3. Choose New editor script from the File menu in the SoundEditor. The resulting ScriptEditor will have a name like untitled script [Sound hallo]. 4. Type the following lines into the ScriptEditor: cursor = Get cursor Select: cursor - 0.02, cursor + 0.02 Extract selected sound (windowed): slice, Kaiser2, 2, no endeditor To Spectrum: yes View & Edit If you choose Run from the Run menu in the ScriptEditor, a region of 40 milliseconds around the current cursor position in the SoundEditor will become selected. This piece will be copied to the list of objects, after applying a double Kaiser window (total length 80 ms). Thus, a Sound named slice will appear in the list. Subsequently, a Spectrum object also called slice will appear in the list, and a SpectrumEditor titled Spectrum slice will finally appear on your screen. 5. Save the script to disk, e.g. as /us/miep/spectrum.praat. The title of the ScriptEditor will change accordingly. 6. Since you will want this script to be available in all future SoundEditors, you choose Add to menu... from the File menu. For the Window, you specify SoundEditor (this is preset). For the Menu, you may want to choose Spectrum instead of the preset value (File). For the name of the Command, you type something like Show spectrum at cursor (instead of Do it...). Then you click OK. The command will be visible in every SoundEditor that you create from now on. To see this, close the one visible SoundEditor, select the original Sound, choose View & Edit again, and inspect the Spectrum menu. You can now view the spectrum around the cursor just by choosing this menu command. After you leave Praat and start it again, the command will continue to appear in the SoundEditor. If you don't like the command any longer, you can remove it with the ButtonEditor, which you can start by choosing Buttons from the Preferences submenu of the Praat menu. Improving your script The above spectrum-viewing example has a number of disadvantages. It clutters the object list with a number of indiscriminable Sounds and Spectra called slice, and the spectrum is shown up to the Nyquist frequency while we may just be interested in the lower 5000 Hz. Furthermore, the original selection in the SoundEditor is lost. To improve the script, we open it again with Open editor script... from the File menu in the SoundEditor. After every change, we can run it with Run from the Run menu again; alternatively, we could save it (with Save from the File menu) and choose our new Show spectrum at cursor button (this button will always run the version on disk, never the one viewed in a ScriptEditor). To zoom in on the first 5000 Hz, we add the following code at the end of our script: editor: Spectrum slice Zoom: 0, 5000 To get rid of the Sound slice, we can add: endeditor removeObject: Sound slice Note that endeditor is needed to change from the environment of a SpectrumEditor to the environment of the object & picture windows. If you now choose the Show spectrum at cursor button for several cursor positions, you will notice that all those editors have the same name. To remedy the ambiguity of the line editor Spectrum slice, we give each slice a better name. For example, if the cursor was at 635 milliseconds, the slice could be named 635ms. We can achieve this by changing the extraction in the following way: milliseconds = round (cursor*1000) Extract selection sound (windowed): string$ (milliseconds) + ms, Kaiser2, 2, no The names of the Sound and Spectrum objects will now have more chance of being unique. Two lines will have to be edited trivially. Finally, we will reset the selection to the original. At the top of the script, we add two lines to remember the positions of the selection markers: start = Get start of selection end = Get end of selection At the bottom, we reset the selection: editor Select: start, end Note that the editor directive if not followed by the name of an editor, returns the script to the original environment. The complete script is: start = Get start of selection end = Get end of selection cursor = Get cursor Select: cursor - 0.02, cursor + 0.02 # Create a name. E.g. 670ms means at 670 milliseconds. milliseconds = round (cursor*1000) Extract windowed selection: string$ (milliseconds) + ms, Kaiser2, 2, no endeditor To Spectrum: yes View & Edit editor: Spectrum + string$ (milliseconds) + ms Zoom: 0, 5000 endeditor removeObject: Sound + string$ (milliseconds) + ms editor Select: start, end This script is useful as it stands. It is good enough for safe use. For instance, if the created Sound object has the same name as an already existing Sound object, it will be the newly created Sound object that will be removed by removeObject, because in case of ambiguity removeObject always removes the most recently created object of that name. Links to this page Scripting Scripting 7. Scripting the editors 
Scripting_7__Scripting_the_editors	Scripting 7. Scripting the editors With a Praat script, you can automatize your work in the editors. Warning: if the purpose of your script is to get information about analyses (pitch, formants, intensity, spectrogram) from the Sound, we do not advise to script the Sound editor window. It is much simpler, faster, and more reproducible to create the analyses with the commands of the dynamic menu, then use the Query commands of the dynamic menu to extract information from the analyses. This also applies if you want to use a TextGrid to determine the times at which you want to query the analyses. See Scripting examples. Scripting 7.1. Scripting an editor from a shell script (editor/endeditor) Scripting 7.2. Scripting an editor from within Links to this page Scripting 
Scripting_8_1__The_sendpraat_subroutine	Scripting 8.1. The sendpraat subroutine A subroutine for sending messages to a running Praat. Also a Unix, MacOS, or DOS console program with the same purpose. Syntax sendpraat (void *display, const char *program, long timeOut, char *text); Arguments display the display pointer if the subroutine is called from a running X program; if NULL, sendpraat will open the display by itself. On Windows and Macintosh, this argument is ignored. program the name of a running program that uses the Praat shell, e.g. Praat or ALS. The first letter may be specified as lower or upper case; it will be converted to lower case for Unix and to upper case for Macintosh and Windows. timeOut (Unix and Macintosh only) the number of seconds that sendpraat will wait for an answer before writing an error message. A timeOut of 0 means that the message will be sent asynchronously, i.e., that sendpraat will return immediately without issuing any error message. text the script text to be sent. Sendpraat may alter this text! Example 1: killing a program char message [100], *errorMessage; strcpy (message, Quit); errorMessage = sendpraat (NULL, praat, 0, message); if (errorMessage != NULL) fprintf (stderr, %s, errorMessage); This causes the program Praat to quit (gracefully), because Quit is a fixed command in one of the menus of that program. On Unix and Macintosh, sendpraat returns immediately; on Windows, the timeOut argument is ignored. The return value errorMessage is a statically allocated string internal to sendpraat, and is overwritten by the next call to sendpraat. Example 2: playing a sound file in reverse Suppose you have a sound file whose name is in the variable fileName, and you want the program Praat, which can play sounds, to play this sound backwards. char message [1000], *errorMessage; sprintf (message, Read from file... %s\nPlay reverse\nRemove, fileName); errorMessage = sendpraat (NULL, praat, 1000, message); This will work because Play reverse is an action command that becomes available in the dynamic menu when a Sound is selected. On Unix, sendpraat will allow Praat at most 1000 seconds to perform this. Example 3: executing a large script file Sometimes, it may be unpractical to send a large script directly to sendpraat. Fortunately, the receiving program knows runScript: char message [100], *errorMessage; strcpy (message, runScript: \doAll.praat\, 20); errorMessage = sendpraat (NULL, praat, 0, message); This causes the program Praat to run the script doAll.praat with an argument of 20. How to download You can download the source code of the sendpraat subroutine and program via www.praat.org or from http://www.fon.hum.uva.nl/praat/sendpraat.html. Instead Instead of using sendpraat, you can also just take the following simple steps in your program: 1. on Linux, write the script that you want to run, and save it as ~/.praat-dir/message; 2. get Praat's process id from ~/.praat-dir/pid; 3. if Praat's process id is e.g. 1178, send it a SIGUSR1 signal: kill -USR1 1178 If the first line of your script is the comment # 999, where 999 stands for the process id of your program, Praat will send your program a SIGUSR2 signal back when it finishes handling the script. See also To start a program from the command line instead and sending it a message, you would not use sendpraat, but instead run the program with a script file as an argument. See Scripting 6.9. Calling from the command line. Links to this page Scripting Scripting 8. Controlling Praat from another program Scripting 8.2. The sendpraat program Scripting 8.3. The sendpraat directive 
Scripting_8_2__The_sendpraat_program	Scripting 8.2. The sendpraat program A Unix or DOS console program for sending messages to a running Praat program. Syntax sendpraat [timeOut] program message... For the meaning of the arguments, see the sendpraat subroutine. Example 1: killing a program sendpraat 0 praat Quit Causes the program Praat to quit (gracefully), because Quit is a fixed command in one of its menus. On Unix, sendpraat returns immediately; on Windows, you leave out the timeOut argument. Example 2: playing a sound file in reverse sendpraat 1000 praat Read from file... hello.wav Play reverse Remove This works because Play reverse is an action command that becomes available in the dynamic menu of the Praat program when a Sound is selected. On Unix, sendpraat will allow Praat at most 1000 seconds to perform this. Each line is a separate argument. Lines that contain spaces should be put inside double quotes. Example 3: drawing sendpraat als for i from 1 to 5 Draw circle: 0.5, 0.5, i endfor This causes the program Als to draw five concentric circles into the Picture window. Example 4: running a large script sendpraat praat runScript: \doAll.praat\, 20 This causes the program Praat to execute the script doAll.praat with an argument of 20. Links to this page Scripting Scripting 8. Controlling Praat from another program Scripting 8.3. The sendpraat directive 
Scripting_8_3__The_sendpraat_directive	Scripting 8.3. The sendpraat directive Besides being a subroutine (Scripting 8.1. The sendpraat subroutine) and a program (Scripting 8.2. The sendpraat program), sendpraat can also be called from within a Praat script. Example 1: killing a program Suppose we are in the Praat-shell program Als, which is a browser for dictionaries, and we want to kill the Praat-shell program Praat, which is a program for phonetics research: beginSendpraat: Praat Quit endSendpraat Example 2: playing a sound Suppose we are in the Praat-shell program Als, which is a browser for dictionaries, and has no idea of what a sound is. From this program, we can play a sound file by sending a message to the Praat-shell program Praat, which does know about sounds: fileName$ = chooseReadFile$: Play a sound file beginSendpraat: Praat, fileName$ Read from file: fileName$ Play Remove endSendpraat After beginSendpraat, you first mention the name of the receiving program (here Praat), then the names of the variables you want the receiving program to know about. To have the receiving program return information to you, specify the variables that are to be handed back: fileName$ = chooseReadFile$: Measure a sound file beginSendpraat: Praat, fileName$ Read from file: fileName$ duration = Get total duration Remove endSendpraat: duration writeInfoLine: That sound file lasts , duration, seconds. Links to this page Scripting Scripting 8. Controlling Praat from another program 
Scripting_8__Controlling_Praat_from_another_program	Scripting 8. Controlling Praat from another program Scripting 8.1. The sendpraat subroutine Scripting 8.2. The sendpraat program Scripting 8.3. The sendpraat directive Links to this page Scripting Scripting 6.7. Sending a message to another program sendpraat 
Scripting_9_1__Turning_a_script_into_a_stand-alone_prog	Scripting 9.1. Turning a script into a stand-alone program You can turn your script into a double-clickable stand-alone program by including it into Praat's main procedure. If you want to try this, you should already know how to compile and link the Praat program on your computer. These stand-alone programs do not show the Objects window and the Picture window; therefore, you will usually want to use Demo window commands in your script. Here is an example: #include praat.h const wchar_t myScript [ ] = L demo Text: 0.5, \centre\, 0.5, \half\, \Hello world\\n demoWaitForInput ( )\n ; int main (int argc, char *argv [ ]) { praat_setStandAloneScriptText (myScript); praat_init (Hello, argc, argv); INCLUDE_LIBRARY (praat_uvafon_init) praat_run (); return 0; } The script in this example raises the Demo window, writes Hello world in the middle of the window, waits until the user clicks the mouse or presses a key, and then closes. Note that Praat is distributed under the General Public License (GPL). This means that if you distribute a Praat-based stand-alone program, you have to make it open source under the GPL as well. See also Programming with Praat. Details Your program can save its preferences in a directory of its choice, e.g. in 'preferencesDirectory$'/../GuineaPigAnalyzer if your program is called GuineaPigAnalyzer. If you want to be less conspicuous and like to use the Praat preferences directory instead, please use the apps subdirectory, in this way: createDirectory: preferencesDirectory$ + /apps createDirectory: preferencesDirectory$ + /apps/GuineaPigAnalyzer Links to this page Scripting What was new in 5.2? 
Scripting_9_2__Old_functions	Scripting 9.2. Old functions The Praat scripting language improves and changes, but old scripts should continue to work correctly. Here are some examples of what you can see in old scripts, and what they mean: The meaning of echo Hello, my name is 'name$' and I am 'age' years old. is writeInfoLine: Hello, my name is , name$, and I am , age, years old. The meaning of Draw... 0 0 0 0 yes Curve is Draw: 0, 0, 0, 0, yes, Curve The meaning of Read from file... 'fileName$' is Read from file: fileName$ Links to this page Scripting 
Scripting_examples	Scripting examples Here is a number of examples of how to use scripting in the Praat program. Refer to the scripting tutorial when necessary. Script for listing time\--F0 pairs Script for listing time\--F0\--intensity Script for listing F0 statistics Script for creating a frequency sweep Script for onset detection Script for TextGrid boundary drawing Script for analysing pitch with a TextGrid Links to this page Scripting 7. Scripting the editors 
Segmentation	Segmentation See Intro 7. Annotation. 
Select_inner_viewport___	Select inner viewport... One of the commands in the Select menu of the Picture window. Purpose To determine where your next drawing will occur. The viewport The viewport is the part of the Picture window where your next drawing will occur. You can set the colour of its margins with System Preferences → Appearance → Highlight Colour. The inner viewport does not include the margins, the outer viewport does (see Select outer viewport...). Normally, you select the viewport by dragging your mouse across the Picture window. However, you would use this explicit command: from a script; if you want a viewport that cannot be expressed in halves of an inch. Links to this page Demo window 
Select_outer_viewport___	Select outer viewport... One of the commands in the Select menu of the Picture window. Purpose To determine where your next drawing will occur. The viewport The viewport is the part of the Picture window where your next drawing will occur. You can set the colour of its margins with System Preferences → Appearance → Highlight Colour. The outer viewport includes the margins, the inner viewport does not (see Select inner viewport...). Normally, you select the viewport by dragging your mouse across the Picture window. However, you would use this explicit command: from a script; if you want a viewport that cannot be expressed in halves of an inch. Links to this page Demo window Scripting 3.1. Hello world 
sendpraat	sendpraat See Scripting 8. Controlling Praat from another program. Links to this page Scripting 8.3. The sendpraat directive What was new in 3.6? What was new in 3.8? What was new in 3.9? What was new in 4.6? What was new in 5.2? 
Sesam_LVS_files	Sesam/LVS files A way for storing a Sound object on disk. File format The sound files used by the SESAM and LVS programs. Each sample is normally quantized into 12 bits. Reading To read a Sound from a Sesam file on disk, use Read from file.... The file name is expected to end in .sdf or .SDF. The 12-bit sample values are divided by 2048 so that the amplitude of the resulting Sound is between -1.0 and +1.0. The resulting Sound will appear in the List of Objects; its name will be equal to the file name, without extension. If the sound was encoded in 16 bits per sample, you should divide by 16 after reading (with Formula: self/16) Saving With Save as Sesam file.... Praat then asks you for a file name. After you click OK, the samples of the Sound are multiplied by 2048 and quantized between -2048 and 2047; the result is written to the file in 12-bit LVS and Sesam format. To avoid clipping, keep the absolute amplitude below 1.000. If the maximum sound pressure level is 91 dB (top = 2047), the quantization threshold is (top = 1/2) 19 dB. If you prefer 16-bit encoding, you should multiply by 16 before saving (with Formula: self*16) 
Shepard__1964_	Shepard (1964) R.N. Shepard (1964): Circularity in judgments of relative pitch. Journal of the Acoustical Society of America 36: 2346–2353. Links to this page Create Sound from Shepard tone... 
Shift-click	Shift-click One of the ways to control Editors. How to Shift-click 1. Position the mouse above the object that you want to Shift-click. 2. Press a Shift key. 3. Press and release the (left) mouse button. Usage in the Praat program Whereas plain clicking is used for selecting only one object while deselecting all previously selected objects, Shift-click is used for selecting a mark, target, or boundary, without deselecting the previously selected objects: PitchTierEditor PointEditor 
Shift-drag	Shift-drag Shift-dragging is one of the ways to control Editors. How to Shift-drag 1. Position the mouse above any of the objects that you want to drag (the objects were probably selected first). 2. Press a Shift key. 3. Press the (left) mouse button. 4. Keeping the mouse button pressed, move the mouse across the window. A shadow of the objects will follow. 5. Release the mouse button when it is above the location where you want your objects to be moved. If this drop site makes any sense, the objects will move there. Usage in the Praat program While plain dragging is used for moving objects that were selected first by clicking, Shift-dragging is used for manipulating the times and values of more marks, targets, or boundaries simultaneously: TextGridEditor 
Show_formant	Show formant One of the commands in the Formant menu of the SoundEditor and the TextGridEditor. See Intro 5. Formant analysis. Links to this page Intro 5.1. Viewing formant contours 
Show_intensity	Show intensity One of the commands in the Intensity menu of the SoundEditor and the TextGridEditor. See Intro 6. Intensity analysis. 
Show_pitch	Show pitch One of the commands in the Pitch menu of the SoundEditor and the TextGridEditor. See Intro 4. Pitch analysis. Links to this page Intro 4.1. Viewing a pitch contour 
Show_pulses	Show pulses One of the commands in the Pulses menu of the SoundEditor and the TextGridEditor. See Voice. Links to this page Voice 2. Jitter Voice 3. Shimmer 
Show_spectrogram	Show spectrogram One of the commands in the Spectrogram menu of the SoundEditor and the TextGridEditor. See Intro 3. Spectral analysis. Links to this page Intro 3.1. Viewing a spectrogram 
Similarity	Similarity One of the types of objects in PRAAT. An object of type Similarity represent a one-way table of similarities between objects. Commands Creation Confusion: To Similarity... Drawing Draw as numbers... Draw as squares... Query Get column mean (index)... Get column mean (label)... Get column stdev (index)... Get column stdev (label)... Modification Formula... Remove column (index)... Insert column (index)... Set row label (index)... Set row label (label)... Set column label (index)... Set column label (label)... Analysis Similarity: To Dissimilarity... Links to this page Configuration: To Similarity (cc) 
Similarity__To_Dissimilarity___	Similarity: To Dissimilarity... A command that creates a Dissimilarity from every selected Similarity. Setting Maximum dissimilarity determines the maximum dissimilarity possible. When the default value, 0.0, is chchosenmaximumDissimilarity is calculated as the maximum element in the Similarity object. Algorithm To obtain dissimilarities we 'reverse' similarities: dissimilarityij = maximumDissimilarity – similarityij In this way the order of dissimilarities is the reverse of the order of the similarities. 
singular_value_decomposition	singular value decomposition The singular value decomposition (SVD) is a matrix factorization algorithm. For m > n, the singular value decomposition of a real m × n matrix A is the factorization A = U Σ V′, The matrices in this factorization have the following properties: U [m × n] and V [n × n] are orthogonal matrices. The columns ui of U =[u1, ..., un] are the left singular vectors, and the columns vi of V [v1, ..., vn] are the right singular vectors. Σ [n × n] = diag (σ1, ..., σn) is a real, nonnegative, and diagonal matrix. Its diagonal contains the so called singular values σi, where σ1 ≥ ... ≥ σn ≥ 0. If m < n, the decomposition results in U [m × m] and V [n × m]. Links to this page PCA & PCA: Get angle between pc1-pc2 planes Principal component analysis TableOfReal: Draw biplot... TableOfReal: To CCA... TableOfReal: To Covariance 
Slaney__1993_	Slaney (1993) M. Slaney (1993): An efficient implementation of the Patterson-Holdsworth auditory filterbank. Apple Computer Technical Report 35, 41 pages. Links to this page Sound: Filter (gammatone)... 
smacof	smacof Scaling by Majorizing a Complicated Function, the iterative algorithm to find an optimal Configuration. 1. Initialize 1.a. Get initial Configuration Z 1.b. Set stress σn[0] to a very large value. 1.c. Set iteration counter k = 0 2. Increase iteration counter by one: k = k + 1 3. Calculate distances dij(Z). 4. Transform dissimilarities δij into disparities d′ij. 5. Standardize the disparities so that ηd′2 = n(n–1)/2. 6. Compute the Guttman transform X[k] of Z. 7. Compute new distances dij(X[k]). 8. Compute normalized stress σn (d′, X[k]) 9. If |σn[k] – σn[k–1]| / σn[k–1] < ε or k > maximumNumberOfIterations, then stop 10. Set Z = X[k], and go to 2. This algorithm goes back to De Leeuw (1977). 
Smolensky__1986_	Smolensky (1986) Paul Smolensky (1986): Information processing in dynamical systems: foundations of Harmony Theory. In Rumelhart & McClelland (1986), pp. 194–281. Links to this page OT learning 1. Kinds of grammars 
Smolensky___Legendre__2006_	Smolensky & Legendre (2006) Paul Smolensky & Géraldine Legendre (2006): The harmonic mind. MIT Press. These two books contain all material on connectionism by Smolensky and colleagues from the late eighties on, with extensive editing to make it into a coherent work, plus much new material. This book can be seen in many respects as the predecessor of Prince & Smolensky (1993). If you want to read a single chapter, I recommend Soderstrom, Mathis & Smolensky (2006). Links to this page OT learning 1. Kinds of grammars OT learning 2.6. Variable output 
Soderstrom__Mathis___Smolensky__2006_	Soderstrom, Mathis & Smolensky (2006) Melanie Soderstrom, Donald Mathis & Paul Smolensky (2006): Abstract genomic encoding of Universal Grammar in Optimality Theory. In Smolensky & Legendre (2006), pp. 403–471. Links to this page OT learning 1. Kinds of grammars OT learning 4. Learning an ordinal grammar 
Sound	Sound One of the types of objects in Praat. For tutorial information, see all of the Intro. Commands Creation: Record mono Sound... (from microphone or line input, with the SoundRecorder) Record stereo Sound... Create Sound from formula... Create Sound from tone complex... Create Sound from gammatone... Create Sound from Shepard tone... Opening and saving: Sound files You can also use the text and binary (real-valued) formats for Sounds, like for any other class: Save as text file... Save as binary file... Playing: Sound: Play PointProcess: Hum PointProcess: Play Viewing and editing: SoundEditor, ManipulationEditor, TextGridEditor, PointEditor, PitchTierEditor, SpectrumEditor Queries: structure: • time domain • Get number of samples • Get sampling period • Get sampling frequency • Get time from sample number... • Get sample number from time... content: • Sound: Get value at time... • Sound: Get value at sample number... shape: • Sound: Get minimum... • Sound: Get time of minimum... • Sound: Get maximum... • Sound: Get time of maximum... • Sound: Get absolute extremum... • Sound: Get nearest zero crossing... statistics: • Sound: Get mean... • Sound: Get root-mean-square... • Sound: Get standard deviation... energy: • Sound: Get energy... • Sound: Get power... in air: • Sound: Get energy in air • Sound: Get power in air • Sound: Get intensity (dB) Modification: Matrix: Formula... Sound: Set value at sample number... Sound: Filter with one formant (in-line)... Sound: Pre-emphasize (in-line)... Sound: De-emphasize (in-line)... Annotation (see Intro 7. Annotation): Sound: To TextGrid... Periodicity analysis: Sound: To Pitch... Sound: To Pitch (ac)... Sound: To Pitch (cc)... Sound: To Pitch (shs)... Sound: To Harmonicity (ac)... Sound: To Harmonicity (cc)... Sound: To PointProcess (periodic, cc)... Sound: To PointProcess (periodic, peaks)... Sound & Pitch: To PointProcess (cc) Sound & Pitch: To PointProcess (peaks)... Sound: To Intensity... Spectral analysis: Sound: To Spectrum... Sound: To Spectrogram... Sound: To Formant (burg)... Sound: To Formant (sl)... Sound: LPC analysis Sound: To LPC (autocorrelation)... Sound: To LPC (covariance)... Sound: To LPC (burg)... Sound: To LPC (marple)... Filtering (see Filtering tutorial): Sound: Filter (pass Hann band)... Sound: Filter (stop Hann band)... Sound: Filter (formula)... Sound: Filter (one formant)... Sound: Filter (pre-emphasis)... Sound: Filter (de-emphasis)... LPC & Sound: Filter... LPC & Sound: Filter (inverse) Sound & Formant: Filter Sound & FormantGrid: Filter Conversion: Sound: Resample... Enhancement: Sound: Lengthen (overlap-add)...: lengthen by a constant factor Sound: Deepen band modulation...: strenghten intensity modulations in each critical band Combination: Sounds: Convolve... Sounds: Cross-correlate... Sound: Autocorrelate... Sounds: Concatenate Synthesis Source-filter synthesis tutorial Manipulation (overlap-add etc.) Spectrum: To Sound Pitch: To Sound... PointProcess: To Sound (pulse train)... PointProcess: To Sound (hum)... Pitch & PointProcess: To Sound... Articulatory synthesis tutorial Artword & Speaker: To Sound... Inside a Sound With Inspect, you will see that a Sound contains the following data: xmin start time, in seconds. xmax > xmin end time, in seconds. nx the number of samples (≥ 1). dx sample period, in seconds. The inverse of the sampling frequency (in Hz). x1 the time associated with the first sample (in seconds). This will normally be in the range [xmin, xmax]. The time associated with the last sample (i.e., x1 + (nx – 1) dx)) will also normally be in that range. Mostly, the sound starts at t = 0 seconds and x1 = dx / 2. Also, usually, xmax = nx dx. z [1] [1..nx] the amplitude of the sound (stored as single-precision floating-point numbers). For the most common applications (playing and file I-O), Praat assumes that the amplitude is greater than -1 and less than +1. For some applications (modelling of the inner ear; articulatory synthesis), Praat assumes that the amplitude is expressed in Pascal units. If these interpretations are combined, we see that the maximum peak amplitude of a calibrated sound is 1 Pascal; for a sine wave, this means 91 dB SPL. Limitations Since the Sound object completely resides in memory, its size is limited to the amount of RAM in your computer. For sounds longer than a few minutes, you could use the LongSound object instead, which you can view in the LongSoundEditor. Links to this page AIFF and AIFC files Band filtering in the frequency domain Combine to stereo DTW & Sounds: Draw warp (x)... DTW & Sounds: Draw... Extract one channel... FLAC files Formants & LPC menu Formulas 1.7. Formulas for creation Formulas 1.8. Formulas for modification Formulas 7. Attributes of objects How to concatenate sound files Intro 1.2. Reading a sound from disk Intro 2. What to do with a sound Intro 2.1. Saving a sound to disk Intro 2.2. Viewing and editing a sound Intro 3.1. Viewing a spectrogram Intro 3.8. The Spectrum object Intro 4.1. Viewing a pitch contour Intro 4.5. The Pitch object Intro 5.1. Viewing formant contours Intro 5.4. The Formant object Intro 6.1. Viewing an intensity contour Intro 8.1. Manipulation of pitch Intro 8.2. Manipulation of duration Intro 8.3. Manipulation of intensity LPC & Sound: Filter (inverse) with filter at time... LPC & Sound: Filter with filter at time... Macintosh sound files Manipulation: Extract original sound Manipulation: Replace original sound NIST files Periodicity menu Play PointProcess: To Sound (phonation)... Read separate channels from sound file... sampling frequency sampling period Save as AIFC file... Save as AIFF file... Save as FLAC file... Save as NeXT/Sun file... Save as NIST file... Save as WAV file... Sesam/LVS files Sound & Formant: Filter (no scale) Sound & FormantGrid: Filter (no scale) Sound & IntensityTier: Multiply Sound & Pitch: Change gender... Sound & Pitch: Change speaker... Sound & Pitch: To FormantFilter... Sound files 3. Files that Praat can read Sound: Change gender... Sound: Change speaker... Sound: Draw where... Sound: Fade in... Sound: Fade out... Sound: Formula... Sound: Paint where... Sound: Play as frequency shifted... Sound: Remove noise... Sound: Scale intensity... Sound: Scale peak... Sound: To BarkFilter... Sound: To Covariance (channels)... Sound: To CrossCorrelationTable... Sound: To Formant (keep all)... Sound: To Formant (robust)... Sound: To FormantFilter... Sound: To KlattGrid (simple)... Sound: To Ltas (pitch-corrected)... Sound: To MelFilter... Sound: To MFCC... Sound: To Polygon... Sound: To PowerCepstrogram... Sound: To Sound (whiten channels)... Sound: To TextGrid (silences)... Sound: Trim silences... Sounds: Concatenate with overlap... Sounds: Paint enclosed... Source-filter synthesis 1. Creating a source from pitch targets Source-filter synthesis 4. Using existing sounds SpellingChecker stereo TextGrid VowelEditor What was new in 3.6? What was new in 3.7? 
Sound___Formant__Filter	Sound & Formant: Filter A command to create a new Sound from the selected Sound and Formant objects. For examples, see Source-filter synthesis. The resulting Sound is scaled so that its maximum absolute amplitude is 0.99. If you don't want this, use Sound & Formant: Filter (no scale) instead. Links to this page Filtering Sound: To Formant (keep all)... Source-filter synthesis 4. Using existing sounds 
Sound___Formant__Filter__no_scale_	Sound & Formant: Filter (no scale) A command to create a new Sound from the selected Sound and Formant objects. For examples, see Source-filter synthesis. Unlike what happens in Sound & Formant: Filter, the resulting Sound is not scaled. This allows generation of a series of signals with controlled relative intensities. 
Sound___FormantGrid__Filter	Sound & FormantGrid: Filter A command to create a new Sound from the selected Sound and FormantGrid objects. For examples, see Source-filter synthesis. The resulting Sound is scaled so that its maximum absolute amplitude is 0.99. If you don't want this, use Sound & FormantGrid: Filter (no scale) instead. Links to this page Filtering Source-filter synthesis 2. Filtering a source Source-filter synthesis 4. Using existing sounds 
Sound___FormantGrid__Filter__no_scale_	Sound & FormantGrid: Filter (no scale) A command to create a new Sound from the selected Sound and FormantGrid objects. For examples, see Source-filter synthesis. Unlike what happens in Sound & FormantGrid: Filter, the resulting Sound is not scaled. This allows generation of a series of signals with controlled relative intensities. 
Sound___IntensityTier__Multiply	Sound & IntensityTier: Multiply A command to create a new Sound from the selected Sound and Intensity objects. The resulting Sound equals the original sound, multiplied by a linear interpolation of the intensity. Afterwards, the resulting Sound is scaled so that its maximum absolute amplitude is 0.9. Links to this page IntensityTier Intro 8.3. Manipulation of intensity What was new in 3.7? 
Sound___KlattGrid__Filter_by_vocal_tract___	Sound & KlattGrid: Filter by vocal tract... Filters the selected sound with the vocal tract part of the selected KlattGrid. During this filtering the delta formants and bandwidths are not used. 
Sound___Pitch__Change_gender___	Sound & Pitch: Change gender... A command to create a new Sound object with manipulated characteristics from the selected Sound and Pitch. With this command you can have finer grained control over the pitch than with the Sound: Change gender... command. Accurate pitch measurement determines the quality of the overlap-add synthesis. Settings The settings are described in Sound: Change gender.... 
Sound___Pitch__Change_speaker___	Sound & Pitch: Change speaker... A command to create a new Sound object with manipulated characteristics from the selected Sound and Pitch. With this command you can have finer grained control over the pitch than with the Sound: Change speaker... command. Accurate pitch measurement determines the quality of the overlap-add synthesis. Settings The settings are described in Sound: Change speaker.... 
Sound___Pitch__To_FormantFilter___	Sound & Pitch: To FormantFilter... A command that creates a FormantFilter object from the selected Sound and Pitch objects by band filtering in the frequency domain with a bank of filters whose bandwidths depend on the Pitch. The filter functions used are: H(f, F0) = 1 / (((fc2 - f2) /f·B(F0)))2 + 1), where fc is the central (resonance) frequency of the filter. B(F0) is the bandwidth in Hz and determined as B(F0) = relativeBandwidth·F0, where F0 is the fundamental frequency as determined from the Pitch object. Whenever the value of F0 is undefined, a value of 100 Hz is taken. Links to this page Sound: To FormantFilter... 
Sound___Pitch__To_PointProcess__cc_	Sound & Pitch: To PointProcess (cc) A command to create a PointProcess from the selected Sound and Pitch objects. Purpose to interpret an acoustic periodicity contour as the frequency of an underlying point process (such as the sequence of glottal closures in vocal-fold vibration). Algorithm The voiced intervals are determined on the basis of the voiced/unvoiced decisions in the Pitch object. For every voiced interval, a number of points (or glottal pulses) is found as follows: 1. The first point t1 is the absolute extremum of the amplitude of the Sound, between tmid – T0 / 2 and tmid + T0 / 2, where tmid is the midpoint of the interval, and T0 is the period at tmid, as can be interpolated from the Pitch contour. 2. From this point, we recursively search for points ti to the left until we reach the left edge of the interval. These points must be located between ti–1 – 1.2 T0(ti–1) and ti–1 – 0.8 T0(ti–1), and the cross-correlation of the amplitude in its environment [ti – T0(ti) / 2; ti + T0(ti) / 2] with the amplitude of the environment of the existing point ti–1 must be maximal (we use parabolic interpolation between samples of the correlation function). 3. The same is done to the right of t1. 4. Though the voiced/unvoiced decision is initially taken by the Pitch contour, points are removed if their correlation value is less than 0.3; furthermore, one extra point may be added at the edge of the voiced interval if its correlation value is greater than 0.7. Links to this page Manipulation Sound & Pitch: To PointProcess (peaks)... Sound: To PointProcess (periodic, cc)... Voice 6. Automating voice analysis with a script 
Sound___Pitch__To_PointProcess__peaks____	Sound & Pitch: To PointProcess (peaks)... A command to create a PointProcess from the selected Sound and Pitch objects. Purpose to interpret an acoustic periodicity contour as the frequency of an underlying point process (such as the sequence of glottal closures in vocal-fold vibration). Algorithm The voiced intervals are determined on the basis of the voiced/unvoiced decisions in the Pitch object. For every voiced interval, a number of points (or glottal pulses) is found as follows: 1. The first point t1 is the absolute extremum (or the maximum, or the minimum, depending on your Include maxima and Include minima settings) of the amplitude of the Sound, between tmid – T0 / 2 and tmid + T0 / 2, where tmid is the midpoint of the interval, and T0 is the period at tmid, as can be interpolated from the Pitch contour. 2. From this point, we recursively search for points ti to the left until we reach the left edge of the interval. These points are the absolute extrema (or the maxima, or the minima) between the times ti–1 – 1.2 T0(ti–1) and ti–1 – 0.8 T0(ti–1). 3. The same is done to the right of t1. The periods that are found in this way are much more variable than those found by Sound & Pitch: To PointProcess (cc), and therefore less useful for analysis and subsequent overlap-add synthesis. Links to this page Sound: To PointProcess (periodic, peaks)... 
Sound__Autocorrelate___	Sound: Autocorrelate... A command available in the Periodicity menu when you select one or more Sound objects. This command autocorrelates the selected Sound object. As a result, a new Sound will appear in the list of objects; this new Sound is the autocorrelation of the original Sound. Settings Amplitude scaling Here you can choose between the `principled' options integral, sum, and normalize, which are explained in 1, 2 and 3 below. There is also a `pragmatic' option, namely peak 0.99, which scales the resulting sound in such a way that its absolute peak becomes 0.99, so that the sound tends to be clearly audible without distortion when you play it (see Sound: Scale peak...). Signal outside time domain is... Here you can choose whether outside its time domain the sound is considered to be zero (the standard value), or similar to the sound within the time domain. This is explained in 4 below. 1. Autocorrelation as an integral The autocorrelation of a continuous time signal f(t) is a function of the lag time τ, and defined as the integral Rf (τ) ≡ ∫ f(t) f(t+τ) dt If f is a sampled signal (as Sounds are in Praat), with sampling period Δt, the definition is discretized as Rf [τ] ≡ ∑t f[t] f[t+τ] Δt where τ and t+τ are the discrete times at which f is defined. The autocorrelation is symmetric: Rf (-τ) = Rf (τ). 2. Autocorrelation as a sum You can see in the formula above that if the input Sound is expressed in units of Pa, the resulting Sound should ideally be expressed in Pa2s. Nevertheless, Praat will express it in Pa, because Sounds cannot be expressed otherwise. This basically means that it is impossible to get the amplitude of the resulting Sound correct for all purposes. For this reason, Praat considers a different definition of autocorrelation as well, namely as the sum Rf [τ] ≡ ∑t f[t] g[t+τ] The difference between the integral and sum definitions is that in the sum definition the resulting sound is divided by Δt. 3. Normalized autocorrelation The normalized autocorrelation is defined as norm-autocorr (f) (τ) ≡ ∫ f(t) f(t+τ) dt / ∫ f2(t) dt 4. Shape scaling The boundaries of the integral in 1 are -∞ and +∞. However, f is a Sound object in Praat and therefore has a finite time domain. If f runs from t1 to t2 and is assumed to be zero before t1 and after t2, then the autocorrelation will be zero before t1 - t2 and after t2 - t1, while between t1 - t2 and t2 - t1 it is Rf (τ) = ∫t1t2 f(t) f(t+τ) dt In this formula, the argument of the first f runs from t1 to t2, but the argument of the second f runs from t1 + (t1 - t2) to t2 + (t2 - t1), i.e. from t1 - (t2 - t1) to t2 + (t2 - t1). This means that the integration is performed over two equal stretches of time during which f must be taken zero, namely a time stretch before t1 and a time stretch after t2, both of duration t2 - t1. If you consider the sound outside its time domains as similar to what it is within its time domain, instead of zero, the discretized formula in 1 should be based on the average over the jointly defined values of f[τ] and f[t-τ], without counting any multiplications of values outside the time domain. Suppose that f is defined on the time domain [0, 1.2] with the value of 1 everywhere. Its autocorrelation under the assumption that it is zero elsewhere is then but under the assumption that the sound is similar (i.e. 1) elsewhere, its autocorrelation should be i.e. a constant value of 1.2. This is what you get by choosing the similar option; the autocorrelation will be divided by a triangular function to compensate for the fact that the autocorrelation has been computed over fewer values closer to the edges; this procedure is followed in all autocorrelation-based pitch computations in Praat (see Sound: To Pitch...). For examples, see Boersma (1993). 5. Behaviour The start time of the resulting Sound will be the start time of f minus the end time of f, the end time of the resulting Sound will be the end time of f minus the start time of f, the time of the first sample of the resulting Sound will be the first sample of f minus the last sample of f, the time of the last sample of the resulting Sound will be the last sample of f minus the first sample of f, and the number of samples in the resulting Sound will be twice the number of samples of f, minus 1. 6. Behaviour for stereo and other multi-channel sounds If the selected Sound has more than one channel, each channel of the resulting Sound is computed as the cross-correlation of the corresponding channel of the original Sound. For instance, if you autocorrelate a 10-channel sound, the resulting sound will again have 10 channels, and its 9th channel will be the autocorrelation of the 9th channel of the original sound. The amplitude scaling factor will be the same for all channels, so that the relative amplitude of the channels will be preserved in the resulting sound. For the normalize scaling, for instance, the squared norm of f in the formula above is taken over all channels of f. For the peak 0.99 scaling, the resulting sound will typically have an absolute peak of 0.99 in only one channel, and lower absolute peaks in the other channels. Algorithm The autocorrelation is calculated as the cross-correlation of a sound with itself. Links to this page What was new in 5.2? 
Sound__Change_gender___	Sound: Change gender... A command to create a new Sound with manipulated characteristics. Settings The quality of the manipulation depends on the pitch measurement. The arguments that control the pitch measurement are: Minimum pitch (Hz) (standard value: 75 Hz) pitch candidates below this frequency will not be considered. Maximum pitch (Hz) (standard value: 600 Hz) pitch candidates above this frequency will be ignored. The arguments that control the manipulation are: Formant shift ratio determines the frequencies of the formants in the newly created Sound. If this ratio equals 1 no frequency shift will occur and the formant frequencies will not change. A ratio of 1.1 will change a male voice to a voice with approximate female formant characteristics. A ratio of 1/1.1 will change a female voice to a voice with approximate male formant characteristics. New pitch median (Hz) (standard value: 0.0 Hz, i.e. same as original) determines what the median pitch of the new Sound will be. The pitch values in the newly created Sound will be calculated from the pitch values in the selected Sound by multiplying them by a factor newPitchMedian / oldPitchMedian. This factor equals 1.0 if the default value for the new pitch median (0.0) is chosen. Pitch range factor (standard value: 1.0) determines an extra scaling of the new pitch values around the new pitch median. A factor of 1.0 means that no additional pitch modification will occur (except the obvious one described above). A factor of 0.0 monotonizes the new sound to the new pitch median. Duration factor (standard value: 1.0) The factor with which the sound will be lengthened. The default is 1.0. If you take a value less than 1.0, the resulting sound will be shorter than the original. A value larger than 3.0 will not work. If you want more control over the synthesis you can supply your own Pitch object and use the Sound & Pitch: Change gender... command. Algorithm The shifting of frequencies is done via manipulation of the sampling frequency. Pitch and duration changes are generated with overlap-add synthesis. The new pitch values are calculated in a two step process. We first multiply all the pitches with the factor newPitchMedian / oldPitchMedian according to: newPitch = pitch * newPitchMedian / oldPitchMedian. It follows that if the newPitchMedian equals the oldPitchMedian no change in pitch values will occur in the first step. Subsequently, the pitch range scale factor determines the final pitch values in the following linear manner: finalPitch = newPitchMedian + (newPitch – newPitchMedian) * pitchRangeScaleFactor Hence, it follows that no further scaling occurs if pitchRangeScaleFactor equals 1.0. Links to this page What was new in 4.1? What was new in 4.6? What was new in 5.2? What's new? 
Sound__Change_speaker___	Sound: Change speaker... A command to create a new Sound with manipulated characteristics. Settings The quality of the manipulation depends on the pitch measurement. The arguments that control the pitch measurement are: Pitch floor (Hz) (standard value: 75 Hz) pitch candidates below this frequency will not be considered. Pitch ceiling (Hz) (standard value: 600 Hz) pitch candidates above this frequency will be ignored. The arguments that control the manipulation are: Multiply formants by determines the formant frequencies of the newly created sound. The formant frequency of the new sound will equal the formant frequencies of the selected sound multiplied by this number. If this number equals 1, formant frequencies will not change. A number of 1.1 will change a male voice to a voice with approximate female formant characteristics. A ratio of 1/1.1 will change a female voice to a voice with approximate male formant characteristics. Multiply pitch by determines what the pitch of the new Sound will be. The pitch values of the new sound will equal the pitch values of the selected sound multiplied by this number. A value of 1.8 will approximately change a male's pitch to a female's pitch. Multiply pitch range by (standard value: 1.0) determines the pitch range of the newly created sound. A factor of 1.0 means that no additional pitch modification will occur (except the obvious one described above). A factor of 0.0 monotonizes the new sound to the new pitch median. A negative number inverses the pitch range with respect to the median. Multiply duration by (standard value: 1.0) determines how to modify the duration of the newly created sound. A value of 1.0 means that the new sound will have the same duration as the selected sound. A value less than 1.0 will result in a shortened new sound. A value larger than 2.5 will not work. If you want more control over the synthesis you can supply your own Pitch object and use the Sound & Pitch: Change speaker... command. Algorithm The shifting of formant frequencies is done via manipulation of the sampling frequency. To multiply all formants by a factor of 1.10 (i.e. raising them by 10 percent), a sampling frequency of 44100 Hz is first raised to 48510 Hz (without changing the samples). After this, the sound is lengthened by a factor of 1.10 and the pitch is lowered by a factor of 1.10, so that the original duration and pitch are restored. After this, the sound is resampled to 44100 Hz (by sinc interpolation).Pitch and duration changes are generated with overlap-add synthesis. 
Sound__De-emphasize__in-line____	Sound: De-emphasize (in-line)... A command to change the spectral slope of every selected Sound object. The reverse of Sound: Pre-emphasize (in-line).... For an example, see Source-filter synthesis. This is the in-line version of Sound: Filter (de-emphasis)..., i.e., it does not create a new Sound object but modifies an existing object. Setting From frequency (Hz) the frequency F above which the spectral slope will decrease by 6 dB/octave. Algorithm The de-emphasis factor α is computed as α = exp (-2 π F Δt) where Δt is the sampling period of the sound. Every sample xi of the sound, except x1, is then changed, going up from the second sample: xi = xi + α xi-1 Links to this page Filtering 
Sound__Deepen_band_modulation___	Sound: Deepen band modulation... A command to enhance the fast spectral changes, like F2 movements, in each selected Sound object. Settings Enhancement (dB) the maximum increase in the level within each critical band. The standard value is 20 dB. From frequency (Hz) the lowest frequency that shall be manipulated. The bottom frequency of the first critical band that is to be enhanced. The standard value is 300 Hertz. To frequency (Hz) the highest frequency that shall be manipulated (the last critical band may be narrower than the others). The standard value is 8000 Hz. Slow modulation (Hz) the frequency fslow below which the intensity modulations in the bands should not be expanded. The standard value is 3 Hz. Fast modulation (Hz) the frequency ffast above which the intensity modulations in the bands should not be expanded. The standard value is 30 Hz. Band smoothing (Hz) the degree of overlap of each band into its adjacent bands. Prevents ringing. The standard value is 100 Hz. Algorithm This algorithm was inspired by Nagarajan, Wang, Merzenich, Schreiner, Johnston, Jenkins, Miller & Tallal (1998), but not identical to it. Now follows the description. Suppose the settings have their standard values. The resulting sound will composed of the unfiltered part of the original sound, plus all manipulated bands. First, the resulting sound becomes the original sound, stop-band filtered between 300 and 8000 Hz: after a forward Fourier transform, all values in the Spectrum at frequencies between 0 and 200 Hz and between 8100 Hz and the Nyquist frequency of the sound are retained unchanged. The spectral values at frequencies between 400 and 7900 Hz are set to zero. Between 200 and 400 Hz and between 7900 and 8100 Hz, the values are multiplied by a raised sine, so as to give a smooth transition without ringing in the time domain (the raised sine also allows us to view the spectrum as a sum of spectral bands). Finally, a backward Fourier transform gives us the filtered sound. The remaining part of the spectrum is divided into critical bands, i.e. frequency bands one Bark wide. For instance, the first critical band run from 300 to 406 Hz, the second from 406 to 520 Hz, and so on. Each critical band is converted to a pass-band filtered sound by means of the backward Fourier transform. Each filtered sound will be manipulated, and the resulting manipulated sounds are added to the stop-band filtered sound we created earlier. If the manipulation is the identity transformation, the resulting sound will be equal to the original sound. But, of course, the manipulation does something different. Here are the steps. First, we compute the local intensity of the filtered sound x (t): intensity (t) = 10 log10 (x2 (t) + 10-6) This intensity is subjected to a forward Fourier transform. In the frequency domain, we administer a band filter. We want to enhance the intensity modulation in the range between 3 and 30 Hz. We can achieve this by comparing the very smooth intensity contour, low-pass filtered at fslow = 3 Hz, with the intensity contour that has enough temporal resolution to see the place-discriminating F2 movements, which is low-pass filtered at ffast = 30 Hz. In the frequency domain, the filter is H (f) = exp (- (αf / ffast)2) - exp (- (αf / fslow)2) where α equals √ln 2 ≈ 1 / 1.2011224, so that H (f) has its -6 dB points at fslow and ffast: Now, why do we use such a flat filter? Because a steep filter would show ringing effects in the time domain, dividing the sound into 30-ms chunks. If our filter is a sum of exponentials in the frequency domain, it will also be a sum of exponentials in the time domain. The backward Fourier transform of the frequency response H (f) is the impulse response h (t). It is given by h (t) = 2π√π ffast/α exp (-(πtffast/α)2) - 2π√π fslow/α exp (-(πtfslow/α)2) This impulse response behaves well: We see that any short intensity peak will be enhanced, and that this enhancement will suppress the intensity around 30 milliseconds from the peak. Non-Gaussian frequency-domain filters would have given several maxima and minima in the impulse response, clearly an undesirable phenomenon. After the filtered band is subjected to a backward Fourier transform, we convert it into power again: power (t) = 10filtered / 2 The relative enhancement has a maximum that is smoothly related to the basilar place: ceiling = 1 + (10enhancement / 20 - 1) · (1/2 - 1/2 cos (π fmidbark / 13)) where fmidbark is the mid frequency of the band. Clipping is implemented as factor (t) = 1 / (1 / power (t) + 1 / ceiling) Finally, the original filtered sound x (t), multiplied by this factor, is added to the output. Links to this page What was new in 3.7? 
Sound__Draw_where___	Sound: Draw where... A command to draw only those parts of a Sound where a condition holds. Settings Time range (s) selects the time domain for the drawing. Vertical range defines the vertical limits; larger amplitudes will be clipped. Draw only those parts where the following condition holds determines the part of the sound that will be drawn. All parts where the formula evaluates to true will be drawn. This formula may not contain references to the sampling of the sound, i.e. don't use 'col', 'x1', 'dx' and 'ncol' in it. Example 1 The following script draws all amplitudes larger than one in red. Create Sound from formula: s, Mono, 0, 1, 2000, 1.8*sin(2*pi*5*x)+randomGauss(0,0.1) Colour: Red Draw where: 0, 0, -2, 2, no, Curve, abs(self)>1 Colour: Black Draw where: 0, 0, -2, 2, yes, Curve, not (abs(self)>1) Example 2 Draw the second half of a sound: Draw where: 0, 0, -1, 1, no, Curve, x > xmin + (xmax - xmin) / 2 Example 3 Draw only positive amplitudes: Draw where: 0, 0, -1, 1, no, Curve, self>0 Example 4 Draw parts where pitch is larger than 300 Hz in red: s = selected (Sound) p = To Pitch: 0, 75, 600 pt = Down to PitchTier selectObject: s Colour: Red Draw where: 0, 0, -1, 1, yes, Curve, Object_'pt'(x) > 300 Colour: Black Draw where: 0, 0, -1, 1, yes, Curve, not (Object_'pt'(x) > 300) Links to this page What was new in 5.2? 
Sound__Fade_in___	Sound: Fade in... A command to gradually increase the amplitude of a selected Sound. Settings Channel determines whether you want to fade all channels or only a selected channel. Time (s) determines where the fade-in will take place. If time is earlier than the start time of the sound, the start time of the sound wil be used. Fade time (s) determines the start point and the endpoint of the fade-in with respect to the time argument. Depending on the sign of fadeTime, time is either the start or the end position of the fade-in. If fadeTime is positive, fade-in will take place between time and time+fadeTime. If fadeTime is negative, fade-in wil take place between time+fadeTime and time. Silent from start when on, makes the sound silent before the fade-in starts. When off, the sound before the fade-in starts will not be changed. Algorithm Multiplication with the first half period of a (1-cos(x))/2 function. Cross-fading two sounds The following script cross-fades two sounds s1 and s2 at time 1 second and leaves the result in s2. crossFTime = 0.5 t = 1 Create Sound from formula: s1, 1, 0, 2, 44100, sin(2*pi*500*x) Fade out: 0, t-crossFTime/2, crossFTime, yes Create Sound from formula: s2, 1, 0, 2, 44100, sin(2*pi*1000*x) Fade in.: 0, t-crossFTime/2, crossFTime, yes Formula: self+Sound_s1[] 
Sound__Fade_out___	Sound: Fade out... A command to gradually decrease the amplitude of a selected Sound. Settings Channel determines whether you want to fade all channels or only a selected channel. Time (s) determines where the fade-out will take place. If time is later than the end time of the sound, the end time of the sound wil be used. Fade time (s) determines the start point and the endpoint of the fade-out with respect to the time argument. Depending on the sign of fadeTime, time is either the start or the end position of the fade-out. If fadeTime is positive, fade-out will take place between time and time+fadeTime. If fadeTime is negative, fade-out wil take place between time+fadeTime and time. Silent to end Make the sound silent after the fade-out finishes. Algorithm Multiplication with the first half period of a (1+cos(x))/2 function. 
Sound__Filter__de-emphasis____	Sound: Filter (de-emphasis)... A command to filter every selected Sound object. The resulting Sound object has a lower spectral slope. The reverse of Sound: Filter (pre-emphasis).... For an example, see Source-filter synthesis. Setting From frequency (Hz) the frequency F above which the spectral slope will decrease by 6 dB/octave. Algorithm The de-emphasis factor α is computed as α = exp (-2 π F Δt) where Δt is the sampling period of the sound. The new sound y is then computed recursively as: y1 = x1 yi = xi + α yi-1 Links to this page Filtering Sound: De-emphasize (in-line)... 
Sound__Filter__formula____	Sound: Filter (formula)... A command to convert every selected Sound object into a filtered sound. The filtering is done in the frequency domain. This command is equivalent to the following sequence: 1. Sound: To Spectrum... yes 2. Matrix: Formula... 3. Spectrum: To Sound For a comparative discussion of various filtering methods, see the Filtering tutorial. The example formula is the following: if x<500 or x>1000 then 0 else self fi; rectangular band This formula represents a rectangular pass band between 500 Hz and 1000 Hz (x is the frequency). Rectangular bands are not recommended, since they may lead to an appreciable amount of ringing in the time domain. The transition between stop and pass band should be smooth, as e.g. in Sound: Filter (pass Hann band).... 
Sound__Filter__gammatone____	Sound: Filter (gammatone)... A command to filter a Sound by a fourth order gammatone bandpass filter. Settings Centre frequency (Hz), Bandwidth (Hz) determine the passband of the filter. Algorithm The impulse response of the filter is a 4-th order gammatone. This filter is implemented as a simple 8-th order recursive digital filter with 4 zeros and 8 poles (these 8 poles consist of one conjugate pole pair to the 4-th power). In the Z-domain its formula is: H (z) = (1 + ∑i=1..4 aiz–i) / (1 + ∑j=1..8 bjz–j) The derivation of the filter coefficients ai and bj is according to Slaney (1993). The gain of the filter is scaled to unity at the centre frequency. 
Sound__Filter__one_formant____	Sound: Filter (one formant)... A command to filter every selected Sound object, with a single formant of a specified frequency and bandwidth. Algorithm Two recursive filter coefficients are computed as follows: p = –2 exp (–π bandwidth dt) cos (2π frequency dt) q = exp (–2π bandwidth dt) where dt is the sample period. The new signal y is then computed from the old signal x and itself as y1 := x1 y2 := x2 – p y1 ∀n ≥ 3: yn := xn – p yn-1 – q yn-2 After filtering, the sound y is scaled so that its absolute extremum is 0.9. For a comparative discussion of various filtering methods, see the Filtering tutorial. This filter has an in-line version: Sound: Filter with one formant (in-line).... 
Sound__Filter__pass_Hann_band____	Sound: Filter (pass Hann band)... A command to convert every selected Sound object into a filtered sound. The filtering is done in the frequency domain. This command is equivalent to the following sequence: 1. Sound: To Spectrum... 2. Spectrum: Filter (pass Hann band)... 3. Spectrum: To Sound For a comparative discussion of various filtering methods, see the Filtering tutorial. For a complementary filter, see Sound: Filter (stop Hann band).... Links to this page Sound: Filter (formula)... Sound: Remove noise... 
Sound__Filter__pre-emphasis____	Sound: Filter (pre-emphasis)... A command to filter each selected Sound object. The resulting Sound object has a higher spectral slope. The reverse of Sound: Filter (de-emphasis).... Setting From frequency (Hz) the frequency F above which the spectral slope will increase by 6 dB/octave. Algorithm The pre-emphasis factor α is computed as α = exp (-2 π F Δt) where Δt is the sampling period of the sound. The new sound y is then computed as: yi = xi - α xi-1 Links to this page Filtering Sound: Pre-emphasize (in-line)... 
Sound__Filter__stop_Hann_band____	Sound: Filter (stop Hann band)... A command to convert every selected Sound object into a filtered sound. The filtering is done in the frequency domain. This command is equivalent to the following sequence: 1. Sound: To Spectrum... 2. Spectrum: Filter (stop Hann band)... 3. Spectrum: To Sound For a comparative discussion of various filtering methods, see the Filtering tutorial. For a complementary filter, see Sound: Filter (pass Hann band).... 
Sound__Filter_with_one_formant__in-line____	Sound: Filter with one formant (in-line)... A command to filter every selected Sound object in-line, with a single formant of a specified frequency and bandwidth. This is the in-line version of Sound: Filter (one formant)..., i.e. it does not create a new Sound object but modifies the selected object. Links to this page Filtering 
Sound__Formula___	Sound: Formula... A command for changing the data in all selected Sound objects. See the Formulas tutorial for examples and explanations. Links to this page Source-filter synthesis 2. Filtering a source 
Sound__Get_absolute_extremum___	Sound: Get absolute extremum... A query to the selected Sound object. Return value the absolute extremum (in Pascal) within a specified time window. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored. If t1 is not less than t2, the entire time domain of the sound is considered. Interpolation the interpolation method (None, Parabolic, Sinc) of the vector peak interpolation. The standard is Sinc70 because a Sound object is normally a sampled band-limited signal, which can be seen as a sum of sinc functions. 
Sound__Get_energy___	Sound: Get energy... A query to the selected Sound object. Return value the energy. If the unit of sound amplitude is Pa (Pascal), the unit of energy will be Pa2·s. Setting Time range (s) the time range (t1, t2). Values outside this range are ignored. If t1 is not less than t2, the entire time domain of the sound is considered. Algorithm The energy is defined as ∫t1t2 x2(t) dt where x(t) is the amplitude of the sound. For stereo sounds, it is ∫t1t2 (x12(t) + x22(t))/2 dt where x1(t) and x2(t) are the two channels; this definition ensures that if you convert a mono sound to a stereo sound, the energy will stay the same. See also For an interpretation of the energy as the sound energy in air, see Sound: Get energy in air. For the power, see Sound: Get power.... Links to this page Sound: Get intensity (dB) Sound: Get power in air Sound: Get root-mean-square... 
Sound__Get_energy_in_air	Sound: Get energy in air A query to the selected Sound object. Return value The energy in air, expressed in Joule/m2. Algorithm The energy of a sound in air is defined as 1 / (ρc) ∫ x2(t) dt where x(t) is the sound pressure in units of Pa (Pascal), ρ is the air density (apx. 1.14 kg/m3), and c is the velocity of sound in air (apx. 353 m/s). For how stereo sounds are handled, see Sound: Get energy.... See also For an air-independent interpretation of the energy, see Sound: Get energy.... For the power, see Sound: Get power in air. 
Sound__Get_intensity__dB_	Sound: Get intensity (dB) A query to the selected Sound object. Return value the intensity in air, expressed in dB relative to the auditory threshold. Algorithm The intensity of a sound in air is defined as 10 log10 { 1 / (T P02) ∫dt x2(t) } where x(t) is the sound pressure in units of Pa (Pascal), T is the duration of the sound, and P0 = 2·10-5 Pa is the auditory threshold pressure. For how stereo sounds are handled, see Sound: Get energy.... See also For the intensity in Watt/m2, see Sound: Get power in air. For an auditory intensity, see Excitation: Get loudness. 
Sound__Get_maximum___	Sound: Get maximum... A command available in the Query menu if you select a Sound object. The Info window will show the maximum amplitude (sound pressure in Pascal) within a specified time window. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored, except for purposes of interpolation. If t1 is not less than t2, the entire time domain of the sound is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is Sinc70 because a Sound object is normally a sampled band-limited signal, which can be seen as a sum of sinc functions. 
Sound__Get_mean___	Sound: Get mean... A command available in the Query menu if you select a Sound object. The Info window will show the mean amplitude (sound pressure in Pascal) within a specified time range. Setting Time range (s) the time range (t1, t2). Values outside this range are ignored. If t1 is not less than t2, the entire time domain of the sound is considered. Mathematical definition The mean amplitude between the times t1 and t2 is defined as 1/(t2 - t1) ∫t1t2 x(t) dt where x(t) is the amplitude of the sound in Pa. 
Sound__Get_minimum___	Sound: Get minimum... A command available in the Query menu if you select a Sound object. The Info window will show the minimum amplitude (sound pressure in Pascal) within a specified time window. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored, except for purposes of interpolation. If t1 is not less than t2, the entire time domain of the sound is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is Sinc70 because a Sound object is normally a sampled band-limited signal, which can be seen as a sum of sinc functions. 
Sound__Get_nearest_zero_crossing___	Sound: Get nearest zero crossing... A command available in the Query menu if you select a Sound object. The Info window will show the time associated with the zero crossing nearest to a specified time point. It is undefined if there are no zero crossings or if the specified time is outside the time domain of the sound. Linear interpolation is used between sample points. Setting Time (s) the time for which you want to get the time of the nearest zero crossing. Links to this page What was new in 3.8? 
Sound__Get_power___	Sound: Get power... A command available in the Query menu if you select a Sound object. The Info window will show the power within a specified time window. If the unit of sound amplitude is Pa (Pascal), the unit of power will be Pa2. Setting Time range (s) the time range (t1, t2). Values outside this range are ignored. If t1 is not less than t2, the entire time domain of the sound is considered. Mathematical definition The power is defined as 1/(t2-t1) ∫t1t2 x2(t) dt where x(t) is the amplitude of the sound. For how stereo sounds are handled, see Sound: Get energy.... See also For an interpretation of the power as the sound power in air, see Sound: Get power in air. For the total energy, see Sound: Get energy.... 
Sound__Get_power_in_air	Sound: Get power in air A command available in the Query menu if you select a Sound object. The Info window will show the power in air, expressed in Watt/m2. Mathematical definition The power of a sound in air is defined as 1 / (ρcT) ∫ x2(t) dt where x(t) is the sound pressure in units of Pa (Pascal), ρ is the air density (apx. 1.14 kg/m3), c is the velocity of sound in air (apx. 353 m/s), and T is the duration of the sound. For how stereo sounds are handled, see Sound: Get energy.... For an air-independent interpretation of the power, see Sound: Get power.... For the energy, see Sound: Get energy in air. For the intensity in dB, see Sound: Get intensity (dB). 
Sound__Get_root-mean-square___	Sound: Get root-mean-square... A command available in the Query menu if you select a Sound object. The Info window will show the root-mean-square (rms) value of the sound pressure, expressed in Pascal. Setting Time range (s) the time range (t1, t2). Values outside this range are ignored. If t1 is not less than t2, the entire time domain of the sound is considered. Mathematical definition The root-mean-square value is defined as √ { 1/(t2-t1) ∫t1t2 x2(t) dt } where x(t) is the amplitude of the sound. For how stereo sounds are handled, see Sound: Get energy.... 
Sound__Get_standard_deviation___	Sound: Get standard deviation... A command available in the Query menu if you select a Sound object. The Info window will show the standard deviation (in Pascal) of the sound pressure within a specified window. If the sound contains less than 2 samples, the value is undefined. Setting Time range (s) the time range (t1, t2). Values outside this range are ignored. If t1 is not less than t2, the entire time domain of the sound is considered. Mathematical definition The standard deviation is defined as 1/(t2-t1) ∫t1t2 (x(t) - μ)2 dt where x(t) is the amplitude of the sound, and μ is its mean. For our discrete Sound object, the standard deviation is approximated by 1/(n-1) ∑i=m..m+n-1 (xi - μ)2 where n is the number of sample centres between t1 and t2. Note the minus 1. 
Sound__Get_time_of_maximum___	Sound: Get time of maximum... A command available in the Query menu if you select a Sound object. The Info window will show the time (in seconds) associated with the maximum pressure in a specified time range. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored, except for purposes of interpolation. If t1 is not less than t2, the entire time domain of the sound is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is Sinc70 because a Sound object is normally a sampled band-limited signal, which can be seen as a sum of sinc functions. 
Sound__Get_time_of_minimum___	Sound: Get time of minimum... A command available in the Query menu if you select a Sound object. The Info window will show the time (in seconds) associated with the minimum pressure in a specified time range. Settings Time range (s) the time range (t1, t2). Values outside this range are ignored, except for purposes of interpolation. If t1 is not less than t2, the entire time domain of the sound is considered. Interpolation the interpolation method (None, Parabolic, Cubic, Sinc) of the vector peak interpolation. The standard is Sinc70 because a Sound object is normally a sampled band-limited signal, which can be seen as a sum of sinc functions. 
Sound__Get_value_at_sample_number___	Sound: Get value at sample number... A command available in the Query menu if you select a Sound object. The Info window will show the amplitude (sound pressure in Pascal) at a specified sample number. If the sample number is less than 1 or greater than the number of samples, the result is undefined. Setting Sample number the sample number at which the value is to be evaluated. 
Sound__Get_value_at_time___	Sound: Get value at time... A command available in the Query menu if you select a Sound object. The Info window will show an estimate of the amplitude (sound pressure in Pascal) at a specified time. If that time is outside the samples of the Sound, the result is equal to the value of the nearest sample; otherwise, the result is an interpolated value. Settings Time (s) the time at which the value is to be evaluated. Interpolation the interpolation method, see vector value interpolation. The standard is Sinc70 because a Sound object is normally a sampled band-limited signal, which can be seen as a sum of sinc functions. 
Sound__Lengthen__overlap-add____	Sound: Lengthen (overlap-add)... A command to convert each selected Sound object into a longer new Sound object. Settings Minimum frequency (Hz) the minimum pitch used in the periodicity analysis. The standard value is 75 Hz. For the voice of a young child, set this to 150 Hz.The shortest voiceless interval in the decomposition is taken as 1.5 divided by minimum frequency. Maximum frequency (Hz) the maximum pitch used in the periodicity analysis. The standard value is 600 Hz. For an adult male voice, set this to 300 Hz. Factor the factor with which the sound will be lengthened. The standard value is 1.5. If you take a value less than 1, the resulting sound will be shorter than the original. A value larger than 3 will not work. Algorithm overlap-add. Links to this page What was new in 3.7? What was new in 3.8? 
Sound__LPC_analysis	Sound: LPC analysis You can perform this analysis by selecting one or more Sound objects and choosing the appropriate command to generate an LPC. The acronym LPC stands for Linear Predictive Coding. In the LPC analysis one tries to predict xn on the basis of the p previous samples, x′n = ∑ ak xn-k then {a1, a2, ..., ap} can be chosen to minimize the prediction power Qp where Qp = E[ |xn - x′n|2]. Several different algorithms exist for minimizing Qp: To LPC (autocorrelation)... To LPC (covariance)... To LPC (burg)... To LPC (marple)... Links to this page Source-filter synthesis 4. Using existing sounds 
Sound__Paint_where___	Sound: Paint where... A command to paint only those parts of a Sound where a condition holds. The painted area is the area between the Sound and a horizontal line at a certain level. Settings Colour defines the colour of the paint. Time range (s) selects the time domain for the drawing. Vertical range defines the vertical limits; larger amplitudes will be clipped. Fill from level defines the level of the horizontal line. Formula determines the part of the sound that will be painted. All parts where the formula evaluates to true will be painted. This formula may not contain references to the sampling of the sound, i.e. don't use 'col', 'x1', 'dx' and 'ncol' in it. Example 1 The following script paints the area under a sine curve in red and the area above in green.For the first paint the horizontal line is at y=-1, for the second paint the line is at y=+1. The formula always evaluates to true. s = Create Sound from formula: s, 1, 0, 1, 10000, 0.5*sin(2*pi*5*x) Paint where: Red, 0, 0, -1, 1, -1, yes, 1 Paint where: Green, 0, 0, -1, 1, 1, no, 1 Example 2 The following script paints the area below zero in red and the area above in green.The horizontal line is now always at y=0 and we use the formula to differentiate the areas. s = Create Sound from formula: s, 1, 0, 1, 10000, 0.5*sin(2*pi*5*x) Paint where: Red, 0, 0, -1, 1, 0, no, self>0 Paint where: Green, 0, 0, -1, 1, 0, yes, self<0 Example 3 To give an indication that the area under a 1/x curve between the points a and b and the area between c and d are equal if b/a = d/c. For example, for a=1, b=2, c=4 and d=8: Create Sound from formula: 1dx, Mono, 0, 20, 100, 1/x Draw: 0, 20, 0, 1.5, yes, Curve Paint where: Grey, 0, 20, 0, 1.5, 0, yes, (x >= 1 and x <2) or (x>=4 and x<8) One mark bottom: 1, yes, yes, no, One mark bottom: 2, yes, yes, no, One mark bottom: 4, yes, yes, no, One mark bottom: 8, yes, yes, no, 
Sound__Play	Sound: Play A command to play Sound objects. Availability You can choose this command after selecting one or more Sounds. Purpose To play the selected Sounds through the internal or external loudspeakers, the headphones, or the analog or digital outputs of your computer. Behaviour All of the Sounds selected are played, in the order in which they appear in the list. If the sampling frequency of the Sound does not match any of the system's sampling frequencies, a fast but inaccurate conversion is performed via linear interpolation. Usage The output level and the choice of the output device(s) depend on the settings in your audio control panel. 
Sound__Play_as_frequency_shifted___	Sound: Play as frequency shifted... Plays the selected Sound with all frequencies shifted by the same amount. This trick can be used to make audible those sounds that are normally not audible at all by human beings, like for example ultrasounds or infrasounds. Settings Shift by (Hz) the amount by which frequencies are shifted. A positive number shifts frequencies up, a negative number shifts frequencies down. Example Rodents produce sounds with frequencies far outside the human audible range. Some meaningfull sqeeks of these animals are present in the frequency range from 54 kHz up to sometimes 100kHz. By choosing a shift value of -54000 Hz and a sampling frequency of 44100 Hz, all frequencies between 54000 Hz and (54000+22050=) 76050 Hz will be shifted down by 54000 Hz. The rodents frequencies in the interval from 54000 Hz to 76050 Hz will theredore be mapped to the frequency interval between 0 and 22050 Hz. 
Sound__Pre-emphasize__in-line____	Sound: Pre-emphasize (in-line)... A command to change the spectral slope of every selected Sound object. The reverse of Sound: De-emphasize (in-line).... This is the in-line version of Sound: Filter (pre-emphasis)..., i.e., it does not create a new Sound object but modifies an existing object. Algorithm The pre-emphasis factor α is computed as α = exp (-2 π F Δt) where Δt is the sampling period of the sound. Every sample xi of the sound, except x1, is then changed, going down from the last sample: xi = xi - α xi-1 Links to this page Filtering Sound: To Formant (burg)... What was new in 3.7? 
Sound__Remove_noise___	Sound: Remove noise... A command to suppress noise in the selected Sound. Settings Noise time range (s) the start and end time of a noise part in the sound whose characteristics will be used in the denoising. If the end time is chosen before the start time, the noise fragment will be chosen automatically around a position where the intensity is minimal. For good noise suppression it is important that the noise fragment's duration is chosen several times the length of the window. Window length (s) denoising takes place in (overlapping) windows of this length. Filter frequency range (Hz) before denoising the sound will be band-pass filtered. Noise reduction method The method of spectral subtraction was defined in Boll (1979). The variant implemented is modeled after a script by Ton Wempe. 
Sound__Resample___	Sound: Resample... A command that creates new Sound objects from the selected Sounds. Purpose High-precision resampling from any sampling frequency to any other sampling frequency. Settings Sampling frequency (Hz) the new sampling frequency, in hertz. Precision the depth of the interpolation, in samples (standard is 50). This determines the quality of the interpolation used in resampling. Algorithm If Precision is 1, the method is linear interpolation, which is inaccurate but fast. If Precision is greater than 1, the method is sin(x)/x (sinc) interpolation, with a depth equal to Precision. For higher Precision, the algorithm is slower but more accurate. If Sampling frequency is less than the sampling frequency of the selected sound, an anti-aliasing low-pass filtering is performed prior to resampling. Behaviour A new Sound will appear in the list of objects, bearing the same name as the original Sound, followed by the sampling frequency. For instance, the Sound hallo will give a new Sound hallo_10000. Links to this page Sound: To Formant (burg)... Sound: To LPC (autocorrelation)... Sound: To LPC (burg)... Sound: To LPC (covariance)... Sound: To LPC (marple)... Source-filter synthesis 4. Using existing sounds 
Sound__Scale_intensity___	Sound: Scale intensity... A command available in the Modify menu when you select one or more Sound objects. With this command you multiply the amplitude of each Sound in such a way that its average (i.e. root-mean-square) intensity becomes the new average intensity that you specify (see Settings). Settings New average intensity (dB SPL) the new average intensity of the Sound. The standard value is 70 dB SPL. This means that the root-mean-square amplitude of the sound will come to lie 70 dB above the assumed auditory threshold of 0.00002 Pa. Please check whether as a result a peak in the sound does not get below -1 Pa or above +1 Pa. If that happens, the sound will be clipped when played, which will be audible as distortion; in thast case you may want to set this number to 60 dB or even lower. 
Sound__Scale_peak___	Sound: Scale peak... A command available in the Modify menu when you select one or more Sound objects. With this command you multiply the amplitude of each Sound in such a way that its absolute peak becomes the new absolute peak that you specify (see Settings). Settings New absolute peak the new absolute peak of the Sound. The standard value is 0.99: this maximizes the audibility of the Sound (sounds with lower amplitude are weaker) without distorting it (sounds with absolute peaks above 1 are clipped when they are played). Examples The absolute peak of the following sound is 0.033: This sound will play rather weakly. To make it louder, you can do Scale peak... with a new absolute peak of 0.99. Praat will then multiply the waveform by 30, changing the sound to the following: The absolute peak is now 0.99, and the sound will play loudly. The reverse is also possible. The absolute peak of the following sound is 19.8: This sound will not play correctly: all samples with an amplitude outside the [-1;+1] range will be clipped to -1 or +1. To make this sound nicer to play, you can again do Scale peak... with a new absolute peak of 0.99. Praat will then divide the waveform by 20, changing the sound to the following: The absolute peak is now 0.99, and the sound will play without distortion. Links to this page Sound: Autocorrelate... Sounds: Convolve... Sounds: Cross-correlate... 
Sound__Set_value_at_sample_number___	Sound: Set value at sample number... A command to change a specified sample of the selected Sound object. Settings Sample number the sample whose value is to be changed. Specify any value between 1 and the number of samples in the Sound. If you specify a value outside that range, you will get an error message. New value the value that is to be put into the specified sample. Scripting Example: selectObject: Sound hallo Set value at sample number: 100, 1/2 This sets the value of the 100th sample to 0.5. 
Sound__To_BarkFilter___	Sound: To BarkFilter... A command that creates a BarkFilter object from every selected Sound object by band filtering in the frequency domain with a bank of filters. The filter functions used are: 10 log H(z) = 7 - 7.5 * (zc - z - 0.215) - 17.5 * √ (0.196 + (zc - z - 0.215)2) where zc is the central (resonance) frequency of the filter in Bark. The bandwidths of these filters are constant and equal 1 Bark. 
Sound__To_Covariance__channels____	Sound: To Covariance (channels)... Detemines the covariances between the channels of a selected Sound. The covariance of a sound is determined by calculating the CrossCorrelationTable of a multichannel sound for a lag time equal to zero. Links to this page Sound: To Sound (whiten channels)... 
Sound__To_CrossCorrelationTable___	Sound: To CrossCorrelationTable... A command that creates a CrossCorrelationTable form every selected Sound object. Settings Time range (s), determines the time range over which the table is calculated. Lag time (s), determines the lag time. Algorithm The cross-correlation between channel i and channel j for lag time τ is defined as the discretized integral cross-corr (ci, cj) [τ] ≡ ∑t ci[t] cj[t+τ] Δt, where t and t+τ are discrete times and Δt is the sampling period. 
Sound__To_Formant__burg____	Sound: To Formant (burg)... A command that creates a Formant object from every selected Sound object. It performs a short-term spectral analysis, approximating the spectrum of each analysis frame by a number of formants. Settings Time step (s) the time between the centres of consecutive analysis frames. If the sound is 2 seconds long, and the time step is 0.01 seconds, there will be approximately 200 analysis frames. The actual number is somewhat lower (usually 195), because we cannot measure very well near the edges. If you set the time step to 0.0 (the standard), Praat will use a time step that is equal to 25 percent of the analysis window length (see below). Maximum number of formants for most analyses of human speech, you will want to extract 5 formants per frame. This, in combination with the Maximum formant setting, is the only way in which this procedure will give you results compatible with how people tend to interpret formants for vowels, i.e. in terms of vowel height (F1) and vowel place (F2). Otherwise, the Maximum number of formants can be any multiple of 0.5, you can choose 4, 4.5, 5, 5.5, 6, and so on (see below). Maximum formant (Hz) the ceiling of the formant search range, in hertz. It is crucial that you set this to a value suitable for your speaker. The standard value of 5500 Hz is suitable for an average adult female. For a male, use 5000 Hz; if you use 5500 Hz for an adult male, you may end up with too few formants in the low frequency region, e.g. analysing an [u] as having a single formant near 500 Hz whereas you want two formants at 300 and 600 Hz. For a young child, use a value much higher than 5500 Hz, for instance 8000 Hz (experiment with it on steady vowels). Window length (s) the effective duration of the analysis window, in seconds. The actual length is twice this value, because Praat uses a Gaussian-like analysis window with sidelobes below -120 dB. For instance, if the Window length is 0.025 seconds, the actual Gaussian window duration is 0.050 seconds. This window has values below 4% outside the central 0.025 seconds, and its frequency resolution (-3 dB point) is 1.298 / (0.025 s) = 51.9 Hz, as computed with the formula given at Sound: To Spectrogram.... This is comparable to the bandwidth of a Hamming window of 0.025 seconds, which is 1.303 / (0.025 s) = 52.1 Hz, but that window (which is the window most often used in other analysis programs) has three spectral lobes of about -42 dB on each side. Pre-emphasis from (Hz) the +3 dB point for an inverted low-pass filter with a slope of +6 dB/octave. If this value is 50 Hz, then frequencies below 50 Hz are not enhanced, frequencies around 100 Hz are amplified by 6 dB, frequencies around 200 Hz are amplified by 12 dB, and so forth. The point of this is that vowel spectra tend to fall by 6 dB per octave; the pre-emphasis creates a flatter spectrum, which is better for formant analysis because we want our formants to match the local peaks, not the global spectral slope. See the source-filter synthesis tutorial for a technical explanation, and Sound: Pre-emphasize (in-line)... for the algorithm. Algorithm The sound will be resampled to a sampling frequency of twice the value of Maximum formant, with the algorithm described at Sound: Resample.... After this, pre-emphasis is applied with the algorithm described at Sound: Pre-emphasize (in-line).... For each analysis window, Praat applies a Gaussian-like window, and computes the LPC coefficients with the algorithm by Burg, as given by Childers (1978) and Press et al. (1992). The number of poles that this algorithm computes is twice the Maximum number of formants; that's why you can set the Maximum number of formants to any multiple of 0.5). The algorithm will initially find Maximum number of formants formants in the whole range between 0 Hz and Maximum formant. The initially found formants can therefore sometimes have very low frequencies (near 0 Hz) or very high frequencies (near Maximum formant). Such low or high formants tend to be artefacts of the LPC algorithm, i.e., the algorithm tends to use them to match the spectral slope if that slope differs from the 6 dB/octave assumption. Therefore, such low or high formants cannot usually be associated with the vocal tract resonances that you are looking for. In order for you to be able to identify the traditional F1 and F2, all formants below 50 Hz and all formants above Maximum formant minus 50 Hz, are therefore removed. If you don't want this removal, you may experiment with Sound: To Formant (keep all)... instead. If you prefer an algorithm that always yields the requested number of formants, nicely distributed across the frequency domain, you may try the otherwise rather unreliable Split-Levinson procedure Sound: To Formant (sl).... Links to this page FAQ: Formant analysis Formant: Track... Formants & LPC menu Intro 5.2. Configuring the formant contours Intro 5.4. The Formant object Sound: To Formant (robust)... Sound: To KlattGrid (simple)... Sound: To LPC (autocorrelation)... Sound: To LPC (burg)... Sound: To LPC (covariance)... Sound: To LPC (marple)... Source-filter synthesis 4. Using existing sounds Time step settings... 
Sound__To_Formant__keep_all____	Sound: To Formant (keep all)... A command that creates a Formant object from every selected Sound object. Not recommended for general use. Purpose to perform a short-term spectral analysis, approximating the spectrum of each frame by a number of formants. Settings The same as with Sound: To Formant (burg).... Algorithm The same as with Sound: To Formant (burg).... In contrast with that command, however, all formant values are kept, even those below 50 Hz and those above Maximum formant minus 50 Hz. Although this makes the identification of the traditional F1 and F2 more difficult, this might give better results in resynthesis (see Sound & Formant: Filter), but it usually generates funny values instead. Links to this page Formants & LPC menu 
Sound__To_Formant__robust____	Sound: To Formant (robust)... A command that creates a Formant object from every selected Sound. Settings The settings for Time step (s), Maximum number of formants, Maximum formant (Hz), Window length (s) and Pre emphasis from (Hz) are as in Sound: To Formant (burg).... The following settings determine aspects of the iterative formant frequency refinement. Number of std. dev., determines the number of standard deviation from where selective weighing of samples starts. Maximum number of iterations, determines the maximum number of iterations allowed in the refinement step. Tolerance, detemines another stop ctriterion for the refinement step. If the relative change in variance between successive iterations is less then this value, iteration stops. Iteration stops whenever one of the two defined stop criteria is reached. Algorithm First the sound is downsampled to twice the maximum formant frequency. Next the LPC coefficients are determined by the autocorrelation method. Finally, in an iterative procedure as described by Lee (1988) the formant frequencies and bandwidths are refined by selectively weighting of samples values. 
Sound__To_Formant__sl____	Sound: To Formant (sl)... A command that creates a Formant object from every selected Sound object. Not recommended for general use. Purpose to perform a short-term spectral analysis, approximating the spectrum of each frame by a number of formants. Settings The same as with Sound: To Formant (burg).... Algorithm The algorithm is based on the implementation of the `Split Levinson' algorithm by Willems (1986). This algorithm will always find the requested number of formants in every frame, even if they do not exist. The standard routine (Sound: To Formant (burg)...) yields much more reliable formant values, though it is more sensitive to the Maximum formant argument. Because of the general funny behaviour of the Split-Levinson algorithm, we did not bother to implement an analysis of the bandwidths. They are all set arbitrarily to 50 Hz. Links to this page Formants & LPC menu 
Sound__To_FormantFilter___	Sound: To FormantFilter... A command that creates a FormantFilter object from every selected Sound object by band filtering in the frequency domain with a bank of filters whose bandwidths depend on the pitch of the signal. The analysis proceeds in two steps: 1. We perform a pitch analysis (see Sound: To Pitch... for details). 2. We perform a filter bank analysis on a linear frequency scale. The bandwidth of the filters depends on the measured pitch (see Sound & Pitch: To FormantFilter... for details). 
Sound__To_Harmonicity__ac____	Sound: To Harmonicity (ac)... A command that creates a Harmonicity object from every selected Sound object. Purpose to perform a short-term HNR analysis. Algorithm The algorithm performs an acoustic periodicity detection on the basis of an accurate autocorrelation method, as described in Boersma (1993). Settings Time step (standard value: 0.01 s) the measurement interval (frame duration), in seconds. Minimum pitch (standard value: 75 Hz) determines the length of the analysis window. Silence threshold (standard value: 0.1) frames that do not contain amplitudes above this threshold (relative to the global maximum amplitude), are considered silent. Number of periods per window (standard value: 4.5) 4.5 is best for speech: HNR values up to 37 dB are guaranteed to be detected reliably; 6 periods per window raises this figure to more than 60 dB, but the algorithm becomes more sensitive to dynamic changes in the signal. Usage You will normally use Sound: To Harmonicity (cc)... instead of this command, because that has a much better time resolution (though its sensitivity is 60, not 80 dB). Links to this page Periodicity menu Voice 4. Additive noise 
Sound__To_Harmonicity__cc____	Sound: To Harmonicity (cc)... A command that creates a Harmonicity object from every selected Sound object. Purpose to perform a short-term HNR analysis. Algorithm The algorithm performs an acoustic periodicity detection on the basis of a forward cross-correlation analysis. For information on the settings, see Sound: To Harmonicity (ac).... Links to this page Periodicity menu Voice 4. Additive noise 
Sound__To_Intensity___	Sound: To Intensity... A command to create an Intensity object from every selected Sound. Settings Minimum pitch (Hz) the minimum periodicity frequency in your signal. If you set it too high, you will end up with a pitch-synchronous intensity modulation. If you set it too low, your intensity contour may appear smeared, so you should set it as high as allowed by the signal if you want a sharp contour. Time step (s) the time step of the resulting intensity contour. If you set it to zero, the time step is computed as one quarter of the effective window length, i.e. as 0.8 / (minimum_pitch). Subtract mean See Intro 6.2. Configuring the intensity contour. Algorithm The values in the sound are first squared, then convolved with a Gaussian analysis window (Kaiser-20; sidelobes below -190 dB). The effective duration of this analysis window is 3.2 / (minimum_pitch), which will guarantee that a periodic signal is analysed as having a pitch-synchronous intensity ripple not greater than 0.00001 dB. Links to this page Intensity: Get mean... Intensity: To TextGrid (silences)... Intro 6.4. The Intensity object Script for listing time\--F0\--intensity Sound: To KlattGrid (simple)... Sound: To TextGrid (silences)... Sound: Trim silences... Time step settings... 
Sound__To_KlattGrid__simple____	Sound: To KlattGrid (simple)... Create a KlattGrid from a Sound. Algorithm Oral formants are determined by the Sound: To Formant (burg)... method and transformed to a FormantGrid. Pitch is determined by the Sound: To Pitch... method and transformed to a PitchTier. With Sound: To Intensity... we determine intensity and convert it to an IntensityTier. Next a KlattGrid is created whose time domain conforms to the sound. Its pitch tier, normal formant grid and its voicing amplitude are replaced by the results from the analyses. 
Sound__To_LPC__autocorrelation____	Sound: To LPC (autocorrelation)... With this command you create a new LPC from every selected Sound, using the autocorrelation method. Warning You are advised not to use this command for formant analysis. For formant analysis, instead use Sound: To Formant (burg)..., which also works via LPC (linear predictive coding). This is because Sound: To Formant (burg)... lets you specify a maximum frequency, whereas the To LPC commands automatically use the Nyquist frequency as their maximum frequency. If you do use one of the To LPC commands for formant analysis, you may therefore want to downsample the sound first. For instance, if you want five formants below 5500 Hz but your Sound has a sampling frequency of 44100 Hz, you have to downsample the sound to 11000 Hz with the Sound: Resample... command. After that, you can use the To LPC commands, with a prediction order of 10 or 11. Settings Prediction order the number of linear prediction coefficients, also called the number of poles. Choose this number at least twice as large as the number of spectral peaks that you want to detect. Analysis window duration (s) the effective duration of each analysis frame, in seconds. Time step (s) the time step between two consecutive analysis frames. Pre-emphasis frequency (Hz) a +6dB / octave filtering will be applied above this frequency. A pre-emphasis frequency of 48.47 Hz for a signal with a sampling frequency of 10 kHz approximately corresponds to a value of a = 0.97 for the filter yn = xn - a · xn-1. The relation between a and the pre-emphasis frequency is: a = exp (–2·π·preemphasisFrequency/samplingFrequency). If you do not want pre-emphasis, choose a frequency greater than the Nyquist frequency. Algorithm The autocorrelation algorithm is decribed in Markel & Gray (1976). Links to this page Formants & LPC menu Sound: LPC analysis 
Sound__To_LPC__burg____	Sound: To LPC (burg)... With this command you create a new LPC from every selected Sound, using Burg's method. Warning You are advised not to use this command for formant analysis. For formant analysis, instead use Sound: To Formant (burg)..., which also works via LPC (linear predictive coding). This is because Sound: To Formant (burg)... lets you specify a maximum frequency, whereas the To LPC commands automatically use the Nyquist frequency as their maximum frequency. If you do use one of the To LPC commands for formant analysis, you may therefore want to downsample the sound first. For instance, if you want five formants below 5500 Hz but your Sound has a sampling frequency of 44100 Hz, you have to downsample the sound to 11000 Hz with the Sound: Resample... command. After that, you can use the To LPC commands, with a prediction order of 10 or 11. Settings Prediction order the number of linear prediction coefficients, also called the number of poles. Choose this number at least twice as large as the number of spectral peaks that you want to detect. Analysis window duration (s) the effective duration of each analysis frame, in seconds. Time step (s) the time step between two consecutive analysis frames. Pre-emphasis frequency (Hz) a +6dB / octave filtering will be applied above this frequency. A pre-emphasis frequency of 48.47 Hz for a signal with a sampling frequency of 10 kHz approximately corresponds to a value of a = 0.97 for the filter yn = xn - a · xn-1. The relation between a and the pre-emphasis frequency is: a = exp (–2·π·preemphasisFrequency/samplingFrequency). If you do not want pre-emphasis, choose a frequency greater than the Nyquist frequency. Algorithm Burg's algorithm is described in Anderson (1978) Links to this page Formants & LPC menu Sound: LPC analysis Source-filter synthesis 4. Using existing sounds 
Sound__To_LPC__covariance____	Sound: To LPC (covariance)... With this command you create a new LPC from every selected Sound, using the covariance method. Warning You are advised not to use this command for formant analysis. For formant analysis, instead use Sound: To Formant (burg)..., which also works via LPC (linear predictive coding). This is because Sound: To Formant (burg)... lets you specify a maximum frequency, whereas the To LPC commands automatically use the Nyquist frequency as their maximum frequency. If you do use one of the To LPC commands for formant analysis, you may therefore want to downsample the sound first. For instance, if you want five formants below 5500 Hz but your Sound has a sampling frequency of 44100 Hz, you have to downsample the sound to 11000 Hz with the Sound: Resample... command. After that, you can use the To LPC commands, with a prediction order of 10 or 11. Settings Prediction order the number of linear prediction coefficients, also called the number of poles. Choose this number at least twice as large as the number of spectral peaks that you want to detect. Analysis window duration (s) the effective duration of each analysis frame, in seconds. Time step (s) the time step between two consecutive analysis frames. Pre-emphasis frequency (Hz) a +6dB / octave filtering will be applied above this frequency. A pre-emphasis frequency of 48.47 Hz for a signal with a sampling frequency of 10 kHz approximately corresponds to a value of a = 0.97 for the filter yn = xn - a · xn-1. The relation between a and the pre-emphasis frequency is: a = exp (–2·π·preemphasisFrequency/samplingFrequency). If you do not want pre-emphasis, choose a frequency greater than the Nyquist frequency. Algorithm The covariance algorithm is decribed in Markel & Gray (1976). Links to this page Formants & LPC menu Sound: LPC analysis 
Sound__To_LPC__marple____	Sound: To LPC (marple)... With this command you create a new LPC from every selected Sound, using Marple's method. Warning You are advised not to use this command for formant analysis. For formant analysis, instead use Sound: To Formant (burg)..., which also works via LPC (linear predictive coding). This is because Sound: To Formant (burg)... lets you specify a maximum frequency, whereas the To LPC commands automatically use the Nyquist frequency as their maximum frequency. If you do use one of the To LPC commands for formant analysis, you may therefore want to downsample the sound first. For instance, if you want five formants below 5500 Hz but your Sound has a sampling frequency of 44100 Hz, you have to downsample the sound to 11000 Hz with the Sound: Resample... command. After that, you can use the To LPC commands, with a prediction order of 10 or 11. Settings Prediction order the number of linear prediction coefficients, also called the number of poles. Choose this number at least twice as large as the number of spectral peaks that you want to detect. Analysis window duration (s) the effective duration of each analysis frame, in seconds. Time step (s) the time step between two consecutive analysis frames. Pre-emphasis frequency (Hz) a +6dB / octave filtering will be applied above this frequency. A pre-emphasis frequency of 48.47 Hz for a signal with a sampling frequency of 10 kHz approximately corresponds to a value of a = 0.97 for the filter yn = xn - a · xn-1. The relation between a and the pre-emphasis frequency is: a = exp (–2·π·preemphasisFrequency/samplingFrequency). If you do not want pre-emphasis, choose a frequency greater than the Nyquist frequency. Tolerance 1 stop the iteration when E(m) / E(0) < Tolerance 1, where E(m) is the prediction error for order m. Tolerance 2 stop the iteration when (E(m) - E(m-1)) / E(m-1) < Tolerance 2. Algorithm The algorithm is described in Marple (1980). Links to this page Formants & LPC menu Sound: LPC analysis 
Sound__To_Ltas__pitch-corrected____	Sound: To Ltas (pitch-corrected)... A command available in the Spectrum menu if you select one or more Sound objects. It tries to compute an Ltas of the spectral envelope of the voiced parts, correcting away the influence of F0 in a way that does not sacrifice frequency selectivity. The resulting Ltas is meant to reflect only the resonances (formants) in the vocal tract and the envelope of the glottal source spectrum. The analysis method is described in Boersma & Kovacic (2006). Links to this page What was new in 4.4? 
Sound__To_MelFilter___	Sound: To MelFilter... A command that creates a MelFilter object from every selected Sound object by band filtering in the frequency domain with a bank of filters. The filter functions used are triangular in shape on a linear frequency scale. The filter function depends on three parameters, the lower frequency fl, the central frequency fc and the higher frequency fh. On a mel scale, the distances fc-fl and fh-fc are the same for each filter and are equal to the distance between the fc's of successive filters. The filter function is: H(f) = 0 for f ≤ fl and f ≥ fh H(f) = (f - fl) / (fc - fl) for fl ≤ f ≤ fc H(f) = (fh - f) / (fh - fc) for fc ≤ f ≤ fh Links to this page Sound: To MFCC... 
Sound__To_MFCC___	Sound: To MFCC... A command that creates a MFCC object from every selected Sound object. The analysis proceeds in two steps: 1. We perform a filter bank analysis on a mel frequency scale (see Sound: To MelFilter... for details). 2. We convert the filter values to mel frequency cepstral coefficients (see MelFilter: To MFCC... for details). Links to this page Formants & LPC menu 
Sound__To_Pitch___	Sound: To Pitch... A command that creates a Pitch object from every selected Sound object. Purpose to perform a pitch analysis, optimized for speech. Settings The settings that control the recruitment of the candidates are: Time step (s) (standard value: 0.0) the measurement interval (frame duration), in seconds. If you supply 0, Praat will use a time step of 0.75 / (pitch floor), e.g. 0.01 seconds if the pitch floor is 75 Hz; in this example, Praat computes 100 pitch values per second. Pitch floor (Hz) (standard value: 75 Hz) candidates below this frequency will not be recruited. This parameter determines the length of the analysis window: it will be 3 longest periods long, i.e., if the pitch floor is 75 Hz, the window will be 3/75 = 0.04 seconds long. Note that if you set the time step to zero, the analysis windows for consecutive measurements will overlap appreciably: Praat will always compute 4 pitch values within one window length, i.e., the degree of oversampling is 4. A post-processing algorithm seeks the cheapest path through the candidates. The argument that determines the cheapest path is: Pitch ceiling (Hz) (standard value: 600 Hz) candidates above this frequency will be ignored. Algorithm This is the algorithm described at Sound: To Pitch (ac)..., with all the parameters not mentioned above set to their standard values. Links to this page FAQ: Pitch analysis Intro 4.5. The Pitch object Manipulation Periodicity menu Script for listing F0 statistics Script for listing time\--F0\--intensity Sound: Autocorrelate... Sound: To FormantFilter... Sound: To KlattGrid (simple)... Sound: To Pitch (cc)... Time step settings... Voice 6. Automating voice analysis with a script 
Sound__To_Pitch__ac____	Sound: To Pitch (ac)... A command that creates a Pitch object from every selected Sound object. Purpose to perform a pitch analysis based on an autocorrelation method. Usage Normally, you will instead use Sound: To Pitch..., which uses the same method. The command described here is mainly for experimenting with the parameters, or for the analysis of non-speech signals, which may require different standard settings of the parameters. Algorithm The algorithm performs an acoustic periodicity detection on the basis of an accurate autocorrelation method, as described in Boersma (1993). This method is more accurate, noise-resistant, and robust, than methods based on cepstrum or combs, or the original autocorrelation methods. The reason why other methods were invented, was the failure to recognize the fact that if you want to estimate a signal's short-term autocorrelation function on the basis of a windowed signal, you should divide the autocorrelation function of the windowed signal by the autocorrelation function of the window: rx (τ) ≈ rxw (τ) / rw (τ) Settings The settings that control the recruitment of the candidates are: Time step (s) (standard value: 0.0) the measurement interval (frame duration), in seconds. If you supply 0, Praat will use a time step of 0.75 / (pitch floor), e.g. 0.01 seconds if the pitch floor is 75 Hz; in this example, Praat computes 100 pitch values per second. Pitch floor (Hz) (standard value: 75 Hz) candidates below this frequency will not be recruited. This parameter determines the effective length of the analysis window: it will be 3 longest periods long, i.e., if the pitch floor is 75 Hz, the window will be effectively 3/75 = 0.04 seconds long. Note that if you set the time step to zero, the analysis windows for consecutive measurements will overlap appreciably: Praat will always compute 4 pitch values within one window length, i.e., the degree of oversampling is 4. Very accurate (standard value: off) if off, the window is a Hanning window with a physical length of 3 / (pitch floor). If on, the window is a Gaussian window with a physical length of 6 / (pitch floor), i.e. twice the effective length. A post-processing algorithm seeks the cheapest path through the candidates. The settings that determine the cheapest path are: Pitch ceiling (Hz) (standard value: 600 Hz) candidates above this frequency will be ignored. Silence threshold (standard value: 0.03) frames that do not contain amplitudes above this threshold (relative to the global maximum amplitude), are probably silent. Voicing threshold (standard value: 0.45) the strength of the unvoiced candidate, relative to the maximum possible autocorrelation. To increase the number of unvoiced decisions, increase this value. Octave cost (standard value: 0.01 per octave) degree of favouring of high-frequency candidates, relative to the maximum possible autocorrelation. This is necessary because even (or: especially) in the case of a perfectly periodic signal, all undertones of F0 are equally strong candidates as F0 itself. To more strongly favour recruitment of high-frequency candidates, increase this value. Octave-jump cost (standard value: 0.35) degree of disfavouring of pitch changes, relative to the maximum possible autocorrelation. To decrease the number of large frequency jumps, increase this value. In contrast with what is described in the article, this value will be corrected for the time step: multiply by 0.01 s / TimeStep to get the value in the way it is used in the formulas in the article. Voiced / unvoiced cost (standard value: 0.14) degree of disfavouring of voiced/unvoiced transitions, relative to the maximum possible autocorrelation. To decrease the number of voiced/unvoiced transitions, increase this value. In contrast with what is described in the article, this value will be corrected for the time step: multiply by 0.01 s / TimeStep to get the value in the way it is used in the formulas in the article. Links to this page Advanced pitch settings... FAQ: Pitch analysis Fast Fourier Transform Periodicity menu PitchEditor Sound: To Pitch (cc)... Sound: To PointProcess (periodic, cc)... Sound: To PointProcess (periodic, peaks)... Voice 6. Automating voice analysis with a script What was new in 3.5? What was new in 4.0? 
Sound__To_Pitch__cc____	Sound: To Pitch (cc)... A command that creates a Pitch object from every selected Sound object. Purpose to perform a pitch analysis based on a cross-correlation method. Algorithm The algorithm performs an acoustic periodicity detection on the basis of a forward cross-correlation analysis. Settings Time step (s) (standard value: 0.0) the measurement interval (frame duration), in seconds. If you supply 0, Praat will use a time step of 0.25 / (pitch floor), e.g. 0.00333333 seconds if the pitch floor is 75 Hz; in this example, Praat computes 300 pitch values per second. Pitch floor (Hz) (standard value: 75 Hz) candidates below this frequency will not be recruited. This parameter determines the length of the analysis window: it will be 1 longest period long, i.e., if the pitch floor is 75 Hz, the window will be 1/75 = 0.01333333 seconds long. Note that if you set the time step to zero, the analysis windows for consecutive measurements will overlap appreciably: Praat will always compute 4 pitch values within one window length, i.e., the degree of oversampling is 4. The other settings are the same as for Sound: To Pitch (ac).... Usage The preferred method for speech is Sound: To Pitch.... The command described here is mainly for experimenting, or for applications where you need short time windows. Links to this page Periodicity menu Voice 6. Automating voice analysis with a script 
Sound__To_Pitch__shs____	Sound: To Pitch (shs)... A command that creates a Pitch object from every selected Sound object. Purpose to perform a pitch analysis based on a spectral compression model. The concept of this model is that each spectral component not only activates those elements of the central pitch processor that are most sensitive to the component's frequency, but also elements that have a lower harmonic relation with this component. Therefore, when a specific element of the central pitch processor is most sensitive at a frequency f0, it receives contributions from spectral components in the signal at integral multiples of f0. Algorithm The spectral compression consists of the summation of a sequence of harmonically compressed spectra. The abscissa of these spectra is compressed by an integral factor, the rank of the compression. The maximum of the resulting sum spectrum is the estimate of the pitch. Details of the algorithm can be found in Hermes (1988) Settings Time step (s) (standard value: 0.01 s) the measurement interval (frame duration), in seconds. Minimum pitch (Hz) (standard value: 50 Hz) candidates below this frequency will not be recruited. This parameter determines the length of the analysis window. Max. number of candidates (standard value: 15) The maximum number of candidates that will be recruited. Maximum frequency (Hz) (standard value: 1250 Hz) higher frequencies will not be considered. Max. number of subharmonics (standard value: 15) the maximum number of harmonics that add up to the pitch. Compression factor (standard value: 0.84) the factor by which successive compressed spectra are multiplied before the summation. Number of points per octave (standard value: 48) determines the sampling of the logarithmic frequency scale. Ceiling (Hz) (standard value: 500 Hz) candidates above this frequency will be ignored. 
Sound__To_PointProcess__periodic__cc____	Sound: To PointProcess (periodic, cc)... A command that analyses the selected Sound objects, and creates PointProcess objects. This command combines the actions of Sound: To Pitch (ac)... and Sound & Pitch: To PointProcess (cc). Links to this page Voice 6. Automating voice analysis with a script 
Sound__To_PointProcess__periodic__peaks____	Sound: To PointProcess (periodic, peaks)... A command that analyses the selected Sound objects, and creates PointProcess objects. This command combines the actions of Sound: To Pitch (ac)... and Sound & Pitch: To PointProcess (peaks).... Links to this page What was new in 4.1? 
Sound__To_Polygon___	Sound: To Polygon... A command that creates a Polygon from a selected Sound, where the Polygon's points are defined by the (time, amplitude) pairs of the sound. Settings Channel defines which channel of the sound is used. Time range (s) defines the part of the sound whose (time, amplitude) pairs have to be included. Vertical range defines the vertical limits, larger amplitudes will be clipped. Connection y-value defines the y-value of the first and last point of the Polygon. This gives the opportunity to draw a closed Polygon with the horizontal connection line at any position you like. Example The following script paints the area under a sound curve in red and the area above in green. s = Create Sound from formula: s, 1, 0, 1, 10000, 0.5*sin(2*pi*5*x) #Connection y-value is at amplitude -1: area under the curve. p1 = To Polygon: 1, 0, 0, -1, 1, -1 Paint: {1,0,0}, 0, 0, -1, 1 selectObject: s #Connection y-value is now at amplitude 1: area above the curve. p2 = To Polygon: 1, 0, 0, -1, 1, 1 Paint: {0,1,0}, 0, 0, -1, 1 
Sound__To_PowerCepstrogram___	Sound: To PowerCepstrogram... A command that creates a PowerCepstrogram from every selected Sound. Settings Pitch floor (Hz) determines the effective length of the analysis window: it will be 3 longest periods long, i.e. if the pitch floor is 60 Hz, the window will be 3/60 = 0.05 seconds long. Time step (s) Maximum frequency (Hz) Pre-emphasis from (Hz) 
Sound__To_Sound__blind_source_separation____	Sound: To Sound (blind source separation)... Analyze the selected multi-channel sound into its independent components by an iterative method. The blind source separation method to find the independent components tries to simultaneously diagonalize a number of CrossCorrelationTables that are calculated from the multi-channel sound at different lag times. Settings Time range (s) defines the time range over which the CrossCorrelationTables of the sound will be calculated. Number of cross-correlations defines the number of CrossCorrelationTables to be calculated. Lag times defines the lag time τ0 for the CrossCorrelationTables. These tables are calculated at lag times τk=(k - 1)τ0, where k runs from 1 to numberOfCrosscorrelations. Maximum number of iterations defines a stopping criterion for the iteration. The iteration will stops when this number is reached. Tolerance defines another stopping criterion that depends on the method used. Diagonalization method defines the method to determine the independent components. Algorithm This method tries to decompose the sound according to the instantaneous mixing model Y=A·X. In this model Y is a matrix with the selected multi-channel sound, A is a so-called mixing matrix and X is a matrix with the independent components. Essentially the model says that each channel in the multi-channel sound is a linear combination of the independent sound components in X. If we would know the mixing matrix A we could easily solve the model above for X by standard means. However, if we don't know A and we don't know X, the decomposition of Y is underdetermined. This means there are an infinite number of possible combinations of A and X that result in the same Y. One approach to solve the equation above is to make assumptions about the statistical properties of the components in the matrix X: it turns out that a sufficient assumption is to assume that the components in X at each time instant are statistically independent. This is not an unrealistic assumption in many cases, although in practice it need not be exactly the case. Another assumption is that the mixing matrix is constant, which means that the mixing conditions did not change during the recoding of the sound. The theory says that statistically independent signals are not correlated (although the reverse is not always true: signals that are not correlated don't have to be statistically independent). The methods implemented here all follow this lead as follows. If we calculate the CrossCorrelationTable for the left and the right side signals of the equation above, then, for the multi-channel sound Y this will result in a cross-correlation matrix C. For the right side we obtain A·D·A′, where D is a diagonal matrix because all the cross-correlations between different independent components are zero by definition. This results in the following identity: C(τ)=A·D(τ)·A′, for all values of the lag time τ. This equation says that, given the model, the cross-correlation matrix can be diagonalized for all values of the lag time by the same transformation matrix A. If we calculate the cross-correlation matrices for a number of different lag times, say 20, we then have to obtain the matrix A that diagonalizes them all. Unfortunately there is no closed form solution that diagonalizes more than two matrices at the same time and we have to resort to iterative algorithms for joint diagonalization. Two of these algorithms are the qdiag method as described in Vollgraf & Obermayer (2006) and the ffdiag method as described in Ziehe et al. (2004). Unfortunately the convergence criteria of these two algorithms cannot easily be compared as the criterion for the ffdiag algorithm is the relative change of the square root of the sum of the squared off-diagonal elements of the transformed cross-correlation matrices and the criterion for qdiag is the largest change in the eigenvectors norm during an iteration. Example We start by creating a speech synthesizer that need to create two sounds. We will mix the two sounds and finally our blind source separation software will try to undo our mixing by extracting the two original sounds as well as possible from the two mixtures. synth = Create SpeechSynthesizer: English, default s1 = To Sound: This is some text, no The first speech sound was created from the text This is some text at a speed of 175 words per minute. selectObject: synth Set speech output settings: 44100, 0.01, 80, 50, 145, no, IPA s2 = To Sound.: Abracadabra, abra, 0.01, 80, 50, 145, yes, no, no, yes The second sound Abracadabra, abra was synthesized at 145 words per minute with a somewhat larger pitch excursion (80) than the previous sound (50). plusObject: s1 stereo = Combine to stereo We combine the two separate sounds into one stereo sound because our blind source separation works on multichannel sounds only. mm = Create simple MixingMatrix: mm, 2, 2, 1.0 2.0 2.0 1.0 A two by two MixingMatrix is created. plusObject: stereo Mix The last command, Mix, creates a new two-channel sound where each channel is a linear mixture of the two channels in the stereo sound, i.e. channel 1 is the sum of s1 and s2 with mixture strengths of 1 and 2, respectively. The second channel is also the sum of s1 and s2 but now with mixture strengths 2 and 1, respectively. To Sound (blind source separation): 0.1, 1, 20, 0.0002, 100, 0.001, ffdiag The two channels in the new sound that results from this command contain a reasonable approximation of the two originating sounds. In the top panel the two speech sounds This is some text and abracadabra, abra. The middle panel shows the two mixed sounds while the lower panel shows the two sounds after unmixing. The first two panels will not change between different sessions of praat. The last panel, which shows the result of the blind source separation, i.e. unmixing, will not always be the same because of two things. In the first place the unmixing always starts with an initialisation with random values of the parameters that we have to determine for the blind source separation. Therefore the iteration sequence will never be the same and the final outcomes might differ. In the second place, as was explained in the blind source separation manual, the unmixing is only unique up to a scale factor and a permutation. Therefore the channels in the unmixed sound do not necessarily correspond to the corresponding channel in our original stereo sound. 
Sound__To_Sound__whiten_channels____	Sound: To Sound (whiten channels)... Transforms the channels of the selected Sound linearly to make them white, i.e. the new channels will be uncorrelated and their variances equal unity. Settings Variance fraction to keep, determines, indirectly, how many channels the final sound will have. Algorithm We start by determining the covariance of the selected sound. Next a principal component analysis determines the eigenvalues and eigenvectors of the covariance matrix. The settings of the variance fraction to keep determines how many eigenvalues and eigenvectors we use for the whitening. This number, p, will also be equal to the number of channels of the resulting whitened sound. In mathematical terms. For an n-channel sound, if E is the matrix with the eigenvectors and D=diag (d1, d2,..., dn) is the diagonal matrix with the eigenvalues of the covariance matrix, then the whitening matrix is W = ED-1/2E′, where D-1/2=diag (d1-1/2, ..., dp-1/2, 0, ..., 0). Only the p most important eigenvalues have been retained, where p was determined as the smallest integer for which (d1+d2+...dp)/(d1+d2+ ... + dn) >= varianceFractionToKeep. The resulting sound samples of the whitened sound, wij, are then calculated from the samples of the original sound, skj, as wij = Σk Wik skj, where 1 ≤ i ≤p, 1 ≤ j ≤ numberOfSamples and 1 ≤ k ≤ n. 
Sound__To_Spectrogram___	Sound: To Spectrogram... A command that creates a Spectrogram from every selected Sound object. It performs a short-term spectral analysis, which means that for a number of time points in the Sound, Praat computes an approximation of the spectrum at that time. Each such spectrum is called an analysis frame. For tutorial information, see Intro 3. Spectral analysis. Settings Window length (s) the duration of the analysis window, in seconds. If this is 0.005 seconds, Praat uses for each frame the part of the sound that lies between 0.0025 seconds before and 0.0025 seconds after the centre of that frame (for Gaussian windows, Praat actually uses a bit more than that). The window length determines the bandwidth of the spectral analysis, i.e. the width of the horizontal line in the spectrogram of a pure sine wave. For a Gaussian window, the -3 dB bandwidth is 2*sqrt(6*ln(2))/(π*Window length), or 1.2982804 / Window length. To get a `broad-band' spectrogram (bandwidth 260 Hz), set Window length to 5 milliseconds; to get a `narrow-band' spectrogram (bandwidth 43 Hz), set it to 30 milliseconds. The other window shapes give slightly different values. Maximum frequency (Hz) the maximum frequency subject to analysis, e.g. 5000 hertz. If it is higher than the Nyquist frequency of the Sound (which is half its sampling frequency), some values in the result will be zero (and will be drawn in white by Spectrogram: Paint...). Time step (s) the distance between the centres of subsequent frames, e.g. 0.002 seconds. This determines the number of frames of the resulting Spectrogram. For instance, if the Sound is 1 second long, and the time step is 2 milliseconds, the Spectrogram will consist of almost 500 frames (not exactly 500, because no reliable spectrum can be measured near the beginning and end of the sound). See below for cases in which the time step of the resulting Spectrogram is different from what you supply here. Frequency step (Hz) the frequency resolution, e.g. 20 Hertz. This determines the number of frequency bands (bins) of the resulting Spectrogram. For instance, if the Maximum frequency is 5000 Hz, and the frequency step is 20 Hz, the Spectrogram will consist of 250 frequency bands. See below for cases in which the frequency step of the resulting Spectrogram is different from what you supply here. Window shape determines the shape of the analysis window. You can choose from: Gaussian, Square (none, rectangular), Hamming (raised sine-squared), Bartlett (triangular), Welch (parabolic), and Hanning (sine-squared). The Gaussian window is superior, as it gives no sidelobes in your spectrogram; it analyzes a factor of 2 slower than the other window shapes, because the analysis is actually performed on twice as many samples per frame. For purposes of computation speed, Praat may decide to change the time step and the frequency step. This is because the time step never needs to be smaller than 1/(8√π) of the window length, and the frequency step never needs to be smaller than (√π)/8 of the inverse of the window length. For instance, if the window length is 29 ms, the actual time step will be never be less than 29/(8√π) = 2.045 ms. And if the window length is 5 ms, the actual frequency step will never be less than (√π)/8/0.005 = 44.31 Hz. Tests of the bandwidth You can check the bandwidth formula with the following procedure: ! create a 1000-Hz sine wave, windowed by a 0.2-seconds Gaussian window. Create Sound from formula: gauss, 1, 0.0, 1.0, 44100, sin(2*pi*1000*x) * exp(-3*((x-0.5)/0.1)^2) ! compute its spectrum and look at its bandwidth To Spectrum: yes Draw: 980, 1020, 20, 80, yes Marks bottom every: 1, 2, yes, yes, yes Marks left every: 1, 2, yes, yes, yes ! now you should see a peak at 1000 Hz with a 3 dB bandwidth of 7 Hz (20 dB: 17 Hz) ! more precise: compute the position and width of the peak, and write them to the console Formula: if x<980 or x>1020 then 0 else self fi To Formant (peaks): 20 Write to console ! now you should be able to read that a peak was found at 999.99982 Hz ! with a bandwidth of 6.497 Hz; the theory above predicted 6.491 Hz ! The same, windowed by a 0.1-seconds Hamming window. Create Sound from formula: Hamming, 1, 0.0, 1.0, 44100, if x<0.4 or x>0.6 then 0 else sin(2*pi*1000*x)*(0.54+0.46*cos(pi*(x-0.5)/0.1)) fi To Spectrum: yes Formula: if x<970 or x>1030 then 0 else self fi To Formant (peaks): 20 Write to console ! peak at 999.99817 Hz, 3 dB bw 6.518 Hz, 20 dB bw 15 Hz, zero bw 20 Hz, sidelobe -42 dB ! The same, windowed by a 0.1-seconds rectangular window. Create Sound from formula: rectangular, 1, 0.0, 1.0, 44100, if x<0.4 or x>0.6 then 0 else sin(2*pi*1000*x) fi To Spectrum: yes Formula: if x<970 or x>1030 then 0 else self fi To Formant (peaks): 20 Write to console ! peak at 999.99506 Hz, 3 dB bw 4.440 Hz, 20 dB bw 27 Hz, zero bw 10 Hz, sidelobe -14 dB ! The same, windowed by a 0.1-seconds Hanning window. Create Sound from formula: Hanning, 1, 0.0, 1.0, 44100, if x<0.4 or x>0.6 then 0 else sin(2*pi*1000*x)*(0.5+0.5*cos(pi*(x-0.5)/0.1)) fi To Spectrum: yes Formula: if x<970 or x>1030 then 0 else self fi To Formant (peaks): 20 Write to console ! peak at 999.99945 Hz, 3 dB bw 7.212 Hz, 20 dB bw 16 Hz, zero bw 20 Hz, sidelobe -31 dB ! The same, windowed by a 0.1-seconds triangular window. Create Sound from formula: triangular, 1, 0.0, 1.0, 44100, if x<0.4 or x>0.6 then 0 else sin(2*pi*1000*x)*(1-abs((x-0.5)/0.1)) fi To Spectrum: yes Formula: if x<970 or x>1030 then 0 else self fi To Formant (peaks): 20 Write to console ! peak at 999.99933 Hz, 3 dB bw 6.384 Hz, 20 dB bw 15 Hz, zero bw 20 Hz, sidelobe -26 dB ! The same, windowed by a 0.1-seconds parabolic window. Create Sound from formula: parabolic, 1, 0.0, 1.0, 44100, if x<0.4 or x>0.6 then 0 else sin(2*pi*1000*x)*(1-((x-0.5)/0.1)2) fi To Spectrum: yes Formula: if x<970 or x>1030 then 0 else self fi To Formant (peaks): 20 Write to console ! peak at 999.99921 Hz, 3 dB bw 5.786 Hz, 20 dB bw 12 Hz, zero bw 15 Hz, sidelobe -21 dB Links to this page Fast Fourier Transform Intro 3.5. The Spectrogram object Sound: To Formant (burg)... 
Sound__To_Spectrum___	Sound: To Spectrum... A command that appears in the Spectrum menu if you select one or more Sound objects. It turns the selected Sound into a Spectrum by an over-all spectral analysis, a Fourier transform. Setting Fast determines whether zeroes are appended to the sound such that the number of samples is a power of two. This can appreciably speed up the Fourier transform. Mathematical procedure For the Fourier transform, the Praat-defined time domain of the Sound is ignored. Instead, its time domain is considered to run from t=0 to t=T, where t=0 is supposed to be aligned with the first sample, and T is the total duration of the samples, i.e. NΔt, where N is the number of samples and Δet is the sampling period. Thus, the last sample lies at t=T–Δt. For a sound x(t), defined for all times t in the domain (0, T), the complex spectrum X(f) for any frequency f is the forward Fourier transform of x(t), with a negative exponent: X(f) = ∫0T x(t) e-2πift dt If the Sound is expressed in Pascal (Pa), the Spectrum is expressed in Pa·s, or Pa/Hz. Since a Spectrum object can only contain a finite number of frequency samples, it is only computed for frequencies that are multiples of Δf = 1/T. The number of those frequencies is determined by the number of samples N of the sound. If N is odd, there will be N frequency samples. For instance, if the sound has 20,457 samples, the spectrum will be computed at the frequencies -10,228Δf, -10,227Δf, ..., –Δf, 0, +Δf, ..., +10,227Δf, +10,228Δf. If we suppose that a frequency sample represents a frequency bin with a width of Δf, we see that the frequency samples span adjacent frequency ranges, e.g. the first sample runs from -10,228.5Δf to -10,227.5Δf, the second from -10,227.5Δf to -10,226.5Δf. Together, the frequency samples span the frequency domain of the spectrum, which runs from -F to +F, where F = 10,228.5Δf. We can see that this frequency equals one half of the sampling frequency of the original sound: F = 10,228.5Δf = 10,228.5/T = 10,228.5/(20,457Δt) = 0.5/Δt. This is the so-called Nyquist frequency. If N is even, there will be N+1 frequency samples. For instance, if the sound has 32,768 samples, the spectrum will be computed at the frequencies -16,384Δf, -16,383Δf, ..., -Δf, 0, +Δf, ..., +16,383Δf, +16,384Δf. Again, the frequency samples span adjacent frequency ranges, but the first and last samples are only half as wide as the rest, i.e. the first sample runs from -16,384Δf to -16,383.5Δf, the second from -16,383.5Δf to -16,382.5Δf, and the last from +16,383.5Δf to +16,384Δf. Together, the frequency samples again span the frequency domain of the spectrum, which runs from –F to +F, where F = 16,384Δf = 0.5/Δt, the Nyquist frequency. Storage In a Spectrum object, Praat stores the real and imaginary parts of the complex spectrum separately. The real part is equal to the cosine transform: re X(f) = ∫0T x(t) cos (2πft) dt The imaginary part is equal to the reverse of the sine transform: im X(f) = – ∫0T x(t) sin (2πft) dt The complex spectrum can be reconstructed from the real and imaginary part as follows: X(f) = re X(f) + i im X(f) Since the cosine is a symmetric function of t and the sine is an antisymmetric function of t, the complex spectrum for a negative frequency is the complex conjugate of the complex spectrum for the corresponding positive frequency: X(-f) = re X(-f) + i im X(-f) = re X(f) - i im X(f) = X*(f) For purposes of storage, therefore, the negative frequencies are superfluous. For this reason, the Spectrum object stores re X(f) and im X(f) only for frequencies f = 0, Δf, 2Δf... In the case of a sound with 20,457 samples, the Spectrum object contains the real part of X(0) (its imaginary part is always zero), and the real and imaginary parts of X(f) for frequencies from Δf to 10,228Δf, which makes in total 1+2·10,228 = 20,457 real values. In the case of a sound with 32,768 samples, the Spectrum object contains the real parts of X(0) and X(16,384Δf) (their imaginary parts are always zero), and the real and imaginary parts of X(f) for frequencies from Δf to 16,383Δf, which makes in total 2+2·16,383 = 32,768 real values. Since the negative frequencies have been removed, the frequency domain now runs from 0 to F. This means that the first frequency bin is now only 0.5Δf wide (i.e. as wide as the last bin for even-N spectra), which has consequences for computations of energies. Behaviour If you perform Spectrum: To Sound on the resulting Spectrum object, a Sound is created that is equal to the original Sound (or to the original Sound with appended zeroes). Properties The frequency integral over the squared Spectrum equals the time integral over the squared Sound: ∫-F+F |X(f)|2 df = ∫0T |x(t)|2 dt This is called Parceval's theorem. Links to this page Fast Fourier Transform Intro 3.7. Configuring the spectral slice Intro 3.8. The Spectrum object Sound: Filter (formula)... Sound: Filter (pass Hann band)... Sound: Filter (stop Hann band)... Spectrum: Get centre of gravity... 
Sound__To_TextGrid___	Sound: To TextGrid... A command to create a TextGrid without any labels, copying the time domain from the selected Sound. Settings Tier names a list of the names of the tiers that you want to create, separated by spaces. Point tiers a list of the names of the tiers that you want to be point tiers; the rest of the tiers will be interval tiers. Example If Tier names is a b c, and Point tiers is b, the resulting TextGrid object will contain an interval tier named a, a point tier named b, and another interval tier named c. Links to this page Intro 7. Annotation LongSound: To TextGrid... 
Sound__To_TextGrid__silences____	Sound: To TextGrid (silences)... A command that creates a TextGrid in which the silent and sounding intervals of the selected Sound are marked. Settings Silence threshold (dB) determines the maximum silence intensity value in dB with respect to the maximum intensity. For example, if imax is the maximum intensity in dB then the maximum silence intensity is calculated as imax - silenceThreshold; intervals with an intensity smaller than this value are considered as silent intervals. Minimum silent interval duration (s) determines the minimum duration for an interval to be considered as silent. If you don't want the closure for a plosive to count as silent then use a large enough value. Minimum sounding interval duration (s) determines the minimum duration for an interval to be not considered as silent. This offers the possibility to filter out small intense bursts of relatively short duration. Silent interval label determines the label for a silent interval in the TextGrid. Sounding interval label determines the label for a sounding interval in the TextGrid. Algorithm First the intensity is determined according to the Sound: To Intensity... command. Next the silent and sounding intervas are determined as in the Intensity: To TextGrid (silences)... command. Links to this page What was new in 4.5? What was new in 4.6? 
Sound__Trim_silences___	Sound: Trim silences... A command that creates from the selected Sound a new sound in which all silence durations are not longer than a specified value. Settings Trim duration (s), specifies the maximum allowed silence duration. Minimum pitch (Hz), and, Time step (s), determine how we measure the intensities on which the determination of silent intervals is based. See Sound: To Intensity... for more info. Silence threshold (dB), Minimum silent interval duration (s), and Minimum sounding interval duration, determine how the silent intervals will be determined. See Intensity: To TextGrid (silences)... for more info. Save trimming info as TextGrid, determines if a TextGrid with trimming information will also be created. The TextGrid will have one tier where interval of the originating sound that were trimmed have been labeled. Trim label, determines the label that the trimmed intervals in the TextGrid will get. 
Sound_files	Sound files This tutorial describes the sound files that you can read and write with Praat. It assumes you are familiar with the Intro. You can read this tutorial sequentially with the help of the < 1 and 1 > buttons. 1. General structure 1.1. Sampling (sampling frequency) 1.2. Quantization (linear, endian, μ-law, A-law) 1.3. Channels (mono, stereo) 1.4. The header 1.5. Size 1.6. Compression 2. File types 2.1. WAV files 2.2. AIFF files 2.3. AIFC files 2.4. NeXT/Sun (.au) files 2.5. NIST files 2.6. FLAC files 2.7. MP3 files 3. Files that Praat can read 4. Files that Praat can write Links to this page Intro 2.1. Saving a sound to disk LongSound Save as AIFC file... Save as AIFF file... Save as FLAC file... Save as NeXT/Sun file... Save as NIST file... Save as WAV file... Sound Types of objects 
Sound_files_1_1__Sampling	Sound files 1.1. Sampling When a sound signal from a microphone or on a tape needs to be read into a computer, it is digitized, which means that it is sampled and quantized. Sampling is the discretization of the time domain of the signal: each second of the signal is divided up into 11025, 22050, or 44100 slices (or any other suitable number), and a sample value is associated with each slice. For instance, a continuous 377-Hz sine wave is expressed by x(t) = sin (2π 377 t) If the sampling frequency (or sample rate) is 44100 Hz, this sine wave will be sampled at points spaced Δt = 1/44100 second apart, and the sample values will be xi = sin (2π 377 (t0 + i Δt)) where t0 is the time after which sampling begins. Δt is called the sample period. Quantization is handled in the next section (§1.2). Links to this page Sound files Sound files 1. General structure Sound files 1.4. The header 
Sound_files_1_2__Quantization	Sound files 1.2. Quantization Apart from sampling (§1.1), digitization also involves quantization, which is the conversion of a sample value into a number that fits into 8 or 16 bits. Links to this page Sound files Sound files 1. General structure Sound files 1.4. The header 
Sound_files_1_3__Channels	Sound files 1.3. Channels For most file types, Praat supports sounds with one channel (mono) and two channels (stereo). Links to this page Sound files Sound files 1. General structure Sound files 1.4. The header 
Sound_files_1_4__The_header	Sound files 1.4. The header The bulk of most sound files is formed by the samples. The sample part is usually preceded by a header, which contains information about: 1. The type of file (WAV, AIFF, AIFC, NeXT/Sun, NIST, Kay, FLAC...). 2. The sampling frequency (§1.1). 3. The encoding (linear, 8 or 16 bit, byte order, μ-law, A-law, see §1.2). 4. The number of channels (mono, stereo, see §1.3). 5. The duration (usually the number of samples). Links to this page Sound files Sound files 1. General structure 
Sound_files_1_5__Size	Sound files 1.5. Size The size of a sound file is equal to the size of the header plus the product of the number of samples, the quantization size, and the number of channels. For instance, a stereo sound with a duration of 3 seconds, sampled at 44100 Hz, would, when written into a 16-bit NeXT/Sun file, take up a disk space of 28 + 2 * 3.0 * 44100 * 2 = 529228 bytes whereas the same sound, when averaged to mono, downsampled to 8000 Hz, and written into a μ-law NeXT/Sun file, take up only a disk space of 28 + 1 * 3.0 * 8000 * 1 = 24028 bytes The first example is typical of CD quality, the second of telephone speech. Links to this page Sound files Sound files 1. General structure 
Sound_files_1_6__Compression	Sound files 1.6. Compression Praat used to be able to read some compressed sound file formats (shortened NIST, Polyphone), but because of licensing problems (Praat went open source, Shorten did not), you now need to use other (freely available) programs to do the conversion before reading them into Praat. Praat can decode (but not create) MP3 files. Praat fully supports FLAC compressed files. Links to this page Sound files Sound files 1. General structure Sound files 2.5. NIST files Sound files 2.6. FLAC files Sound files 2.7. MP3 files 
Sound_files_1__General_structure	Sound files 1. General structure This is chapter 1 of the Sound files tutorial. It describes the general structure of the headers and data parts of sound files. 1.1. Sampling (sampling frequency) 1.2. Quantization (linear, μ-law, A-law) 1.3. Channels (mono, stereo) 1.4. The header 1.5. Size 1.6. Compression 
Sound_files_2_1__WAV_files	Sound files 2.1. WAV files The audio file type most commonly used on Windows computers, also very common on the Internet. Links to this page Sound files Sound files 2. File types 
Sound_files_2_2__AIFF_files	Sound files 2.2. AIFF files AIFF stands for: Audio Interchange File Format. This standard format for sound files was defined by Apple. It is also the format of the sound files on the Iris Indigo, where each sample is quantized into 16 bits. Links to this page Sound files Sound files 2. File types Sound files 2.3. AIFC files 
Sound_files_2_3__AIFC_files	Sound files 2.3. AIFC files AIFC is short for AIFF(C) or AIFF-C, i.e. the Audio Interchange File Format (§2.2) with optional compression. Praat reads and write uncompressed AIFC files, but does not support compressed AIFC files. Links to this page Sound files Sound files 2. File types 
Sound_files_2_4__NeXT_Sun___au__files	Sound files 2.4. NeXT/Sun (.au) files This is the format of the sound files on the Sun. Reading To read a Sound from a Sun audio file on disk, use Read from file....Praat then asks you for a file name. After you click OK, Praat determines the encoding of the file. If the encoding is 16-bit linear, the 16-bit sample values are divided by 32768 so that the amplitude of the resulting Sound is between -1.0 and +1.0. If the encoding is 8-bit μ-law, the 16-bit sample value is determined by table look-up first. The resulting Sound will appear in the list of objects; its name will be equal to the file name, without extension. Saving Use Save as NeXT/Sun file.... The samples of the Sound are multiplied by 32768 and quantized between -32768 and 32767; the result is written to the file in 16-bit mono Sun audio format. To avoid clipping, keep the absolute amplitude below 1.000. If the maximum sound pressure level is 91 dB (top = 32767), the quantization threshold is (top = 1/2) -5 dB. Links to this page Sound files Sound files 2. File types 
Sound_files_2_5__NIST_files	Sound files 2.5. NIST files An audio file type used by speech researchers. Used, for instance, in the TIMIT database. Praat reads several kinds of NIST files: big-endian, little-endian, μ-law, A-law, Polyphone. NIST files compressed with shorten are no longer supported (see §1.6) Links to this page Sound files Sound files 2. File types 
Sound_files_2_6__FLAC_files	Sound files 2.6. FLAC files A lossless compressed audio format (see http://flac.sourceforge.net). Praat reads FLAC files in all bitrate/frequency settings (see also §1.6) Links to this page Sound files Sound files 2. File types 
Sound_files_2_7__MP3_files	Sound files 2.7. MP3 files A ubiquitous lossy audio compression format. Praat supports MP3 decoding through the MPEG Audio Decoder library http://www.underbit.com/products/mad/. (see also §1.6) Links to this page Sound files Sound files 2. File types 
Sound_files_2__File_types	Sound files 2. File types 2.1. WAV files 2.2. AIFF files 2.3. AIFC files 2.4. NeXT/Sun (.au) files 2.5. NIST files 2.6. FLAC files 2.7. MP3 files Links to this page Sound files 
Sound_files_3__Files_that_Praat_can_read	Sound files 3. Files that Praat can read Praat can read five types of standard sound files in several formats, and a number of proprietary types of sound files as well. Standard sound files The Open menu contains two commands for opening sound files: • With Read from file..., you read the entire file into memory. A Sound object will appear in the list. This is appropriate if your sound is not too long to fit into memory. The advantage of having a Sound object is that you can perform analysis on it directly. • With Open long sound file..., you open a sound file that is too long to read into memory completely. A LongSound object will appear in the list. You will typically choose View to view the contents of this sound and analyse it. Praat will only read so much of the file into memory as is needed to play or display parts of it. Both commands understand the following five standard audio file formats: • WAV: • linear 16-bit little-endian • 8-bit μ-law • 8-bit A-law • linear 8-bit unsigned • AIFF or AIFC: • linear 16-bit big-endian • linear 8-bit signed • NeXT/Sun (.au): • linear 16-bit big-endian • 8-bit μ-law • 8-bit A-law • linear 8-bit signed • NIST: • linear 16-bit little-endian • linear 16-bit big-endian • 8-bit μ-law • 8-bit A-law • linear 8-bit signed • FLAC: • 8-bit, 16-bit, 24-bit or 32-bit • all sampling frequencies • MP3: • all constant or variable bitrates Links to this page Sound files 
Sound_files_4__Files_that_Praat_can_write	Sound files 4. Files that Praat can write Praat can write five types of standard sound files in an appropriate linear 16-bit formats, and a number of proprietary types of sound files as well: • Save as WAV file... (16-bit little-endian) • Save as AIFF file... (16-bit big-endian) • Save as AIFC file... (16-bit big-endian) • Save as NeXT/Sun file... (16-bit big-endian) • Save as NIST file... (16-bit little-endian) • Save as FLAC file... (16-bit) Links to this page Sound files 
sound_pressure_calibration	sound pressure calibration Your computer's sound-recording software returns integer values between -32768 and 32767. Praat divides them by 32768 before putting them into a Sound object, so that the values in the Sound objects are always between -1 and +1. The Praat program considers these numbers to be air pressures in units of Pascal. These values in Pascal are probably not the actual true air pressures that went into the microphone. To determine what the actual air pressures were, you have to record an extra sound with a known air pressure, with the same recording gain as the rest of your recordings. It is best if this extra sound is something like a white noise, so that its sound pressure level can be determined reliably. A sine wave of 400 Hz, for instance, is less suitable, since its sound pressure level at your microphone can depend very strongly on the precise position and direction of the loudspeaker and on the position of other objects (like you, the experimenter) in the room (differences of 10 dB are no exception). For example, suppose that you record some speech on a CD recorder or with Praat's SoundRecorder. Immediately before or after this recording, you also record a white noise produced by a noise generator. With a dB meter (Linear or C setting), located at the same position as the microphone of the recording, you measure that the Sound Pressure Level of this noise is 76.5 dB. When you later open the recorded noise in Praat's sound window, Praat tells you that its average intensity (switch on Show intensity) is 68.6 dB. You then know that you have to add 7.9 dB to intensities measured in Praat to get at the true sound pressure level. Thus, if your speech contains a long [a:] whose average intensity is measured in the Sound window as 71.1 dB, its true sound pressure level must be 79.0 dB. In this example, you can make Praat's sound window show the true sound pressures in Pascal and true sound pressure levels in dB, if you multiply the sound with a factor of 10(7.9/20), which you can do by selecting the Sound and choosing Multiply... from the Modify menu, then supplying 10^(7.9/20) as the multiplication factor. Links to this page SoundRecorder 
sound_pressure_level	sound pressure level Air pressures are measured in Pascal (Pa), which are Newtons per square metre (N/m2). The ambient air pressure is about 100,000 Pa, and the lungs modify this in phonation only by a small amount, namely 200 to 1000 Pa (= 2 to 10 cm H2O). Outside your body, the air pressures caused by your speech are much smaller again, namely 0.01 to 1 Pa at 1 metre from your lips. These are comparable to the values that you see for a typical speech recording in Praat's sound window, although these numbers in Praat can be interpreted as true air pressures only if you perform a sound pressure calibration (including the multiplication). A normative human ear can detect a root-mean-squared air pressure as small as 0.00002 Pa, for a sine wave with a frequency of 1000 Hz. The sound pressure level can be expressed in dB relative to this normative threshold: SPL = 10 log10 { 1/(t2-t1) ∫t1t2 x2(t) dt / (2·10-5 Pa)2 } where x(t) is the sound pressure in Pa as a function of time, and t1 and t2 are the times between which the energy (squared air pressure) is averaged. For a calibrated sound, Praat's sound window will show you the SPL as a function of time, if you switch on Show intensity and set its averaging method to energy (with Intensity settings...). Links to this page Create Sound from Shepard tone... 
SoundEditor	SoundEditor An Editor for viewing and editing a Sound object. Most of the functions of this editor are described in the Intro. The markers To set the cursor, use the left mouse button. A short horizontal line will also be shown at the left edge (in cyan); the extension of this line crosses the cursor line at the sound's function value (seen as a cyan dot). This function value (shown at the left in cyan) is the sinc-interpolated value, and is generally different from the value that you would expect when looking at the linearly interpolated version of the sampled sound. To select a part of the time domain, use the time selection mechanism. Playing To play any part of the sound, click on one of the rectangles below or above the sound window (there can be 1 to 8 of these rectangles), or choose a Play command from the View menu. Publishing To perform analyses on the selection, or save it to a file, create an independent Sound as a copy of the selection, by clicking on the button that will copy the selection to the List of Objects; the resulting Sound will be called Sound untitled. Editing Cut: cut the selection to the clipboard, for later pasting into the same or another Sound. Copy selection to Sound clipboard: copy the selection to the clipboard, for later pasting into the same or another Sound. Paste after selection: paste the clipboard to the cursor or after the selection. Set selection to zero: set the selected samples to zero. Reverse selection: reverse the selected part of the sound. You can undo these commands with Undo (Command-Z). The Group button To synchronize a SoundEditor window with other windows that show a time signal, push the Group button in all the windows that you want to synchronize. You cannot Cut from or Paste into a synchronized SoundEditor window. Links to this page Advanced pitch settings... Advanced pulses settings... Extract visible formant contour Extract visible intensity contour Extract visible pitch contour Extract visible spectrogram Get first formant Get pitch Get second formant Intro 2.2. Viewing and editing a sound Intro 3.1. Viewing a spectrogram Intro 3.6. Viewing a spectral slice Intro 4.1. Viewing a pitch contour Intro 4.3. Querying the pitch contour Intro 4.5. The Pitch object Intro 5.1. Viewing formant contours Intro 5.3. Querying the formant contours Intro 5.4. The Formant object Intro 6.1. Viewing an intensity contour Log files LongSoundEditor Pitch settings... Play Show formant Show intensity Show pitch Show pulses Show spectrogram Spectrogram settings... TextGridEditor Time step settings... Types of objects Voice What was new in 3.6? 
SoundRecorder	SoundRecorder With the Praat SoundRecorder window you can record a mono or stereo sound for subsequent viewing and analysis in Praat. The SoundRecorder appears on your screen if you choose Record mono Sound... or Record stereo Sound... from the New menu. Depending on your system, the SoundRecorder window may allow you to choose the sampling frequency, the input gain, and the input device (microphone, line, or digital). The sound input level is monitored continuously with one or two meters. The resulting sound has 16 bits per sample, like sounds on an audio CD. Usage To record the sound, use the Record and Stop buttons in the SoundRecorder window. Click Save to list to copy the recorded sound to the object window (or Save left channel to list or Save right channel to list to copy the left or right channel if you have a stereo sound). The name of the resulting Sound object will be taken from the text field next to the button clicked. Size of the recording buffer The size of the recording buffer determines how many seconds of sound you can record. For instance, if the recording buffer is 20 megabytes (the standard value), you can record 220 seconds in stereo (440 seconds in mono) at a sampling frequency of 22050 Hz, or 110 seconds in stereo (220 seconds in mono) at a sampling frequency of 44100 Hz. You can change the size of the recording buffer with Sound input prefs... from the Preferences menu. If you recorded a very long sound, it is probable that you cannot copy it to the list of objects. In such a case, you can still write the sound to disk with one of the Save commands in the File menu. You can then open such a long sound file in Praat with Open long sound file... from the Open menu. Recording sounds on MacOS X You can record from the combined microphone / line input. On some computers, these are separate. Note that in MacOS X you cannot record from the internal CD. This is because the system provides you with something better. If you open the CD in the Finder, you will see the audio tracks as AIFC files! To open these audio tracks in Praat, use Read from file... or Open long sound file.... The File menu If your computer has little memory, a very long recorded sound can be too big to be copied to the list of objects. Fortunately, the File menu contains commands to save the recording to a sound file on disk, so that you will never have to lose your recording. Sound pressure calibration Your computer's sound-recording software returns integer values between -32768 and 32767. Praat divides them by 32768 before putting them into a Sound object, so that the values in the Sound objects are always between -1 and +1. The Praat program considers these numbers to be air pressures in units of Pascal, but they are probably not the actual true air pressures that went into the microphone. For how to obtain the true air pressures, perform a sound pressure calibration. Links to this page Intro 1.1. Recording a sound Intro 2.1. Saving a sound to disk Play Sound Types of objects What was new in 3.8? 
Sounds__Concatenate	Sounds: Concatenate A command to concatenate all selected Sound objects into a single large Sound. All sounds must have equal sampling frequencies and equal numbers of channels. They are concatenated in the order in which they appear in the list of objects (not in the order in which you select them; remember: What You See Is What You Get). How to concatenate directly to a file If the resulting sound does not fit into memory, use one of the commands in the Save menu. See How to concatenate sound files. See also If you want the sounds to fade into each other smoothly, choose Sounds: Concatenate with overlap... instead. 
Sounds__Concatenate_with_overlap___	Sounds: Concatenate with overlap... A command to concatenate all selected Sound objects into a single large Sound, with smooth cross-fading between the sounds. All sounds must have equal sampling frequencies and equal numbers of channels. They are concatenated in the order in which they appear in the list of objects (not in the order in which you select them; remember: What You See Is What You Get). Settings Overlap time (s) the time by which any two adjacent sounds will come to overlap, i.e. the time during which the earlier sound fades out and the later sound fades in. Procedure Suppose we start with the following two sounds. They are both 0.1 seconds long. The first sound is a sine wave with a frequency of 100 Hz, the second a sine wave with a frequency of 230 Hz: If the overlap time is 0.01 seconds, the concatenation of these two sounds will produce a Sound with a duration of 0.19 seconds, which is the sum of the durations of the two sounds, minus the overlap time. The concatenation works in the following way. The last 0.01 seconds of the first sound is multiplied by a falling raised cosine (the second half of a Hann window, see the first red curve), and the first 0.01 seconds of the second sound is multiplied by a rising raised cosine (the first half of a Hann window, see the second red curve): This figure shows how the two sounds are windowed (faded out and in), as well as how they will overlap. Finally, the two windowed (cross-faded) sounds are added to each other: This example showed how it works if you concatenate two sounds; if you concatenate three sounds, there will be two overlaps, and so on. Links to this page Sounds: Concatenate What was new in 5.3? 
Sounds__Convolve___	Sounds: Convolve... A command available in the Combine menu when you select two Sound objects. This command convolves two selected Sound objects with each other. As a result, a new Sound will appear in the list of objects; this new Sound is the convolution of the two original Sounds. Settings Amplitude scaling Here you can choose between the `principled' options integral, sum, and normalize, which are explained in 1, 2 and 3 below. There is also a `pragmatic' option, namely peak 0.99, which scales the resulting sound in such a way that its absolute peak becomes 0.99, so that the sound tends to be clearly audible without distortion when you play it (see Sound: Scale peak...). Signal outside time domain is... Here you can choose whether outside their time domains the sounds are considered to be zero (the standard value), or similar to the sounds within the time domains. This is explained in 4 below. 1. Convolution as an integral The convolution f*g of two continuous time signals f(t) and g(t) is defined as the integral (f*g) (t) ≡ ∫ f(τ) g(t-τ) dτ If f and g are sampled signals (as Sounds are in Praat), with the same sampling period Δt, the definition is discretized as (f*g) [t] ≡ ∑τ f[τ] g[t-τ] Δt where τ and t-τ are the discrete times at which f and g are defined, respectively. Convolution is a commutative operation, i.e. g*f equals f*g. This means that the order in which you put the two Sounds in the object list does not matter: you get the same result either way. 2. Convolution as a sum You can see in the formula above that if both input Sounds are expressed in units of Pa, the resulting Sound should ideally be expressed in Pa2s. Nevertheless, Praat will express it in Pa, because Sounds cannot be expressed otherwise. This basically means that it is impossible to get the amplitude of the resulting Sound correct for all purposes. For this reason, Praat considers a different definition of convolution as well, namely as the sum (f*g) [t] ≡ ∑τ f[τ] g[t-τ] The sum definition is appropriate if you want to filter a pulse train with a finite-impulse-response filter and expect the amplitudes of each resulting period to be equal to the amplitude of the filter. Thus, the pulse train (made with Create Sound from formula... peaks mono 0 0.6 1000 x*(col mod 100 = 0)), convolved with the `leaky integrator' filter (made with Create Sound from formula... leak mono 0 1 1000 exp(-x/0.1)), yields the convolution The difference between the integral and sum definitions is that in the sum definition the resulting sound is divided by Δt. 3. Normalized convolution The normalized convolution is defined as (normalized f*g) (t) ≡ ∫ f(τ) g(t-τ) dτ / √ (∫ f2(τ) dτ ∫ g2(τ) dτ) 4. Shape scaling The boundaries of the integral in 1 are -∞ and +∞. However, f and g are Sound objects in Praat and therefore have finite time domains. If f runs from t1 to t2 and is assumed to be zero before t1 and after t2, and g runs from t3 to t4 and is assumed to be zero outside that domain, then the convolution will be zero before t1 + t3 and after t2 + t4, while between t1 + t3 and t2 + t4 it is (f*g) (t) = ∫t1t2 f(τ) g(t-τ) dτ In this formula, the argument of f runs from t1 to t2, but the argument of g runs from (t1 + t3) - t2 to (t2 + t4) - t1, i.e. from t3 - (t2 - t1) to t4 + (t2 - t1). This means that the integration is performed over two equal stretches of time during which g must be taken zero, namely a time stretch before t3 and a time stretch after t4, both of duration t2 - t1 (equivalent equations can be formulated that rely on two stretches of t4 - t3 of zeroes in f rather than in g, or on a stretch of t2 - t1 of zeroes in g and a stretch of t4 - t3 of zeroes in f. If you consider the sounds outside their time domains as similar to what they are within their time domains, instead of zero, the discretized formula in 1 should be based on the average over the jointly defined values of f[τ] and g[t-τ], without counting any multiplications of values outside the time domains. Suppose that f is defined on the time domain [0, 1.2] with the value of 1 everywhere, and g is defined on the time domain [0, 3] with the value 1 everywhere. Their convolution under the assumption that they are zero elsewhere is then but under the assumption that the sounds are similar (i.e. 1) elsewhere, their convolution should be i.e. a constant value of 1.2. This is what you get by choosing the similar option; if f is shorter than g, the first and last parts of the convolution will be divided by a straight line of duration t2 - t1 to compensate for the fact that the convolution has been computed over fewer values of f and g there. 5. Behaviour The start time of the resulting Sound will be the sum of the start times of the original Sounds, the end time of the resulting Sound will be the sum of the end times of the original Sounds, the time of the first sample of the resulting Sound will be the sum of the first samples of the original Sounds, the time of the last sample of the resulting Sound will be the sum of the last samples of the original Sounds, and the number of samples in the resulting Sound will be the sum of the numbers of samples of the original Sounds minus 1. 6. Behaviour for stereo and other multi-channel sounds You can convolve e.g. a 10-channel sound either with another 10-channel sound or with a 1-channel (mono) sound. If both Sounds have more than one channel, the two Sounds have to have the same number of channels; each channel of the resulting Sound is then computed as the convolution of the corresponding channels of the original Sounds. For instance, if you convolve two 10-channel sounds, the resulting sound will have 10 channels, and its 9th channel will be the convolution of the 9th channels of the two original sounds. If one of the original Sounds has multiple channels and the other Sound has only one channel, the resulting Sound will have multiple channels; each of these is computed as the convolution of the corresponding channel of the multiple-channel original and the single channel of the single-channel original. For instance, if you convolve a 10-channel sound with a mono sound, the resulting sound will have 10 channels, and its 9th channel will be the convolution of the mono sound with the 9th channel of the original 10-channel sound. The amplitude scaling factor will be the same for all channels, so that the relative amplitude of the channels will be preserved in the resulting sound. For the normalize scaling, for instance, the norm of f in the formula above is taken over all channels of f. For the peak 0.99 scaling, the resulting sound will typically have an absolute peak of 0.99 in only one channel, and lower absolute peaks in the other channels. 7. Algorithm The computation makes use of the fact that convolution in the time domain corresponds to multiplication in the frequency domain: we first pad f with a stretch of t4 - t3 of zeroes and g with a stretch of t2 - t1 of zeroes (see 4 above), so that both sounds obtain a duration of (t2 - t1) + (t4 - t3); we then calculate the spectra of the two zero-padded sounds by Fourier transformation, then multiply the two spectra with each other, and finally Fourier-transform the result of this multiplication back to the time domain; the result will again have a duration of (t2 - t1) + (t4 - t3). Links to this page Filtering Source-filter synthesis 4. Using existing sounds What was new in 5.2? 
Sounds__Cross-correlate___	Sounds: Cross-correlate... A command available in the Combine menu when you select two Sound objects. This command cross-correlates two selected Sound objects with each other. As a result, a new Sound will appear in the list of objects; this new Sound is the cross-correlation of the two original Sounds. Settings Amplitude scaling Here you can choose between the `principled' options integral, sum, and normalize, which are explained in 1, 2 and 3 below. There is also a `pragmatic' option, namely peak 0.99, which scales the resulting sound in such a way that its absolute peak becomes 0.99, so that the sound tends to be clearly audible without distortion when you play it (see Sound: Scale peak...). Signal outside time domain is... Here you can choose whether outside their time domains the sounds are considered to be zero (the standard value), or similar to the sounds within the time domains. This is explained in 4 below. 1. Cross-correlation as an integral The cross-correlation of two continuous time signals f(t) and g(t) is a function of the lag time τ, and defined as the integral cross-corr (f, g) (τ) ≡ ∫ f(t) g(t+τ) dt If f and g are sampled signals (as Sounds are in Praat), with the same sampling period Δt, the definition is discretized as cross-corr (f, g) [τ] ≡ ∑t f[t] g[t+τ] Δt where τ and t+τ are the discrete times at which f and g are defined, respectively. Cross-correlation is not a commutative operation, i.e. cross-corr (g, f) equals the time reversal of cross-corr (f, g). This means that the order in which you put the two Sounds in the object list does matter: the two results are each other's time reversals. 2. Cross-correlation as a sum You can see in the formula above that if both input Sounds are expressed in units of Pa, the resulting Sound should ideally be expressed in Pa2s. Nevertheless, Praat will express it in Pa, because Sounds cannot be expressed otherwise. This basically means that it is impossible to get the amplitude of the resulting Sound correct for all purposes. For this reason, Praat considers a different definition of cross-correlation as well, namely as the sum cross-corr (f, g) [τ] ≡ ∑t f[t] g[t+τ] The difference between the integral and sum definitions is that in the sum definition the resulting sound is divided by Δt. 3. Normalized cross-correlation The normalized cross-correlation is defined as norm-cross-corr (f, g) (τ) ≡ ∫ f(t) g(t+τ) dt / √ (∫ f2(t) dt ∫ g2(t) dt) 4. Shape scaling The boundaries of the integral in 1 are -∞ and +∞. However, f and g are Sound objects in Praat and therefore have finite time domains. If f runs from t1 to t2 and is assumed to be zero before t1 and after t2, and g runs from t3 to t4 and is assumed to be zero outside that domain, then the cross-correlation will be zero before t3 - t2 and after t4 - t1, while between t3 - t2 and t4 - t1 it is cross-corr (f, g) (τ) = ∫t1t2 f(t) g(t+τ) dt In this formula, the argument of f runs from t1 to t2, but the argument of g runs from t1 + (t3 - t2) to t2 + (t4 - t1), i.e. from t3 - (t2 - t1) to t4 + (t2 - t1). This means that the integration is performed over two equal stretches of time during which g must be taken zero, namely a time stretch before t3 and a time stretch after t4, both of duration t2 - t1 (equivalent equations can be formulated that rely on two stretches of t4 - t3 of zeroes in f rather than in g, or on a stretch of t2 - t1 of zeroes in g and a stretch of t4 - t3 of zeroes in f. If you consider the sounds outside their time domains as similar to what they are within their time domains, instead of zero, the discretized formula in 1 should be based on the average over the jointly defined values of f[τ] and g[t-τ], without counting any multiplications of values outside the time domains. Suppose that f is defined on the time domain [0, 1.2] with the value of 1 everywhere, and g is defined on the time domain [0, 3] with the value 1 everywhere. Their cross-correlation under the assumption that they are zero elsewhere is then but under the assumption that the sounds are similar (i.e. 1) elsewhere, their cross-correlation should be i.e. a constant value of 1.2. This is what you get by choosing the similar option; if f is shorter than g, the first and last parts of the cross-correlation will be divided by a straight line of duration t2 - t1 to compensate for the fact that the cross-correlation has been computed over fewer values of f and g there. 5. Behaviour The start time of the resulting Sound will be the start time of f minus the end time of g, the end time of the resulting Sound will be the end time of f minus the start time of g, the time of the first sample of the resulting Sound will be the first sample of f minus the last sample of g, the time of the last sample of the resulting Sound will be the last sample of f minus the first sample of g, and the number of samples in the resulting Sound will be the sum of the numbers of samples of f and g minus 1. 6. Behaviour for stereo and other multi-channel sounds You can cross-correlate e.g. a 10-channel sound either with another 10-channel sound or with a 1-channel (mono) sound. If both Sounds have more than one channel, the two Sounds have to have the same number of channels; each channel of the resulting Sound is then computed as the cross-correlation of the corresponding channels of the original Sounds. For instance, if you cross-correlate two 10-channel sounds, the resulting sound will have 10 channels, and its 9th channel will be the cross-correlation of the 9th channels of the two original sounds. If one of the original Sounds has multiple channels and the other Sound has only one channel, the resulting Sound will have multiple channels; each of these is computed as the cross-correlation of the corresponding channel of the multiple-channel original and the single channel of the single-channel original. For instance, if you cross-correlate a 10-channel sound with a mono sound, the resulting sound will have 10 channels, and its 9th channel will be the cross-correlation of the mono sound with the 9th channel of the original 10-channel sound. The amplitude scaling factor will be the same for all channels, so that the relative amplitude of the channels will be preserved in the resulting sound. For the normalize scaling, for instance, the norm of f in the formula above is taken over all channels of f. For the peak 0.99 scaling, the resulting sound will typically have an absolute peak of 0.99 in only one channel, and lower absolute peaks in the other channels. 7. Algorithm The computation makes use of the fact that cross-correlation in the time domain corresponds to multiplication of the time-reversal of f with g in the frequency domain: we first pad f with a stretch of t4 - t3 of zeroes and g with a stretch of t2 - t1 of zeroes (see 4 above), so that both sounds obtain a duration of (t2 - t1) + (t4 - t3); we then calculate the spectra of the two zero-padded sounds by Fourier transformation, then multiply the complex conjugate of the spectrum of f with the spectrum of g, and finally Fourier-transform the result of this multiplication back to the time domain; the result will again have a duration of (t2 - t1) + (t4 - t3). Links to this page Sound: Autocorrelate... What was new in 5.2? 
Sounds__Paint_enclosed___	Sounds: Paint enclosed... Paints the area between the two selected Sounds. Settings Colour defines the colour of the paint. Time range (s) selects the time domain for the drawing. Vertical range defines the vertical limits, larger amplitudes will be clipped. Example The following script paints the area enclosed between a sine tone of 5 Hz and the straight line y = x/2. s1 = Create Sound from formula: sine, Mono, 0, 1, 10000, 1/2 * sin(2*pi*5*x) s2 = Create Sound from formula: line, Mono, 0, 1, 10000, x / 2 plusObject (s1) Paint enclosed: Grey, 0, 0, -1, 1, yes 
Source-filter_synthesis	Source-filter synthesis This tutorial describes how you can do acoustic synthesis with Praat. It assumes that you are familiar with the Intro. 1. The source-filter theory of speech production The source-filter theory (Fant 1960) hypothesizes that an acoustic speech signal can be seen as a source signal (the glottal source, or noise generated at a constriction in the vocal tract), filtered with the resonances in the cavities of the vocal tract downstream from the glottis or the constriction. The Klatt synthesizer (Klatt & Klatt 1990), for instance, is based on this idea. In the Praat program, you can create a source signal from scratch of from an existing speech signal, and you can create a filter from scratch or extract it from an existing speech signal. You can manipulate (change, adapt) both the source and the filter before doing the actual synthesis, which combines the two. Source-filter synthesis 1. Creating a source from pitch targets Source-filter synthesis 2. Filtering a source Source-filter synthesis 3. The ba-da continuum Source-filter synthesis 4. Using existing sounds Links to this page Create FormantGrid... Create IntensityTier... Create PitchTier... Filtering Formant: Formula (frequencies)... FormantGrid FormantGrid: Add bandwidth point... FormantGrid: Add formant point... IntensityTier Intro 8.4. Manipulation of formants LPC: To Formant Sound Sound & Formant: Filter Sound & Formant: Filter (no scale) Sound & FormantGrid: Filter Sound & FormantGrid: Filter (no scale) Sound: De-emphasize (in-line)... Sound: Filter (de-emphasis)... Sound: To Formant (burg)... Types of objects What was new in 3.7? 
Source-filter_synthesis_1__Creating_a_source_from_pitch	Source-filter synthesis 1. Creating a source from pitch targets Creating a glottal source signal for speech synthesis involves creating a PointProcess, which is a series of time points that should represent the exact moments of glottal closure. You may want to start with creating a well-defined pitch contour. Suppose you want to create a sound with a duration of half a second with a pitch that falls from 300 to 200 Hz during that time. You first create an empty PitchTier by choosing Create PitchTier... from the New menu (I call this PitchTier empty because it does not contain any pitch information yet); you may want to name the PitchTier source and have it start at 0 seconds and end at 0.5 seconds. Once the PitchTier exists and is selected, you can View & Edit it to add pitch points (pitch targets) to it at certain times (or you choose PitchTier: Add point... from the Modify menu repeatedly). You could add a pitch point of 150 Hz at time 0.0 and a pitch point of 100 Hz at time 0.5. In the PitchTier window, you can see that the pitch curve falls linearly from 150 to 100 Hz during its time domain: You can hear the falling pitch by clicking on the rectangles in the PitchTier window (or by clicking Play pulses, Hum, or Play sine in the Objects window). From this PitchTier, you can create a PointProcess with PitchTier: To PointProcess. The resulting PointProcess now represents a series of glottal pulses. To make some parts of this point process voiceless, you can use PointProcess: Remove points between.... It is advisable to make the very beginning and end of this point process voiceless, so that the filtered sound will not start or end abruptly. In the following example, the first and last 20 ms are devoiced, and a stretch of 70 ms in the middle is made voiceless as well, perhaps because you want to simulate a voiceless plosive there: Now that we have a glottal point process (a glottal pulse train), the only thing left is to turn it into a sound by choosing PointProcess: To Sound (phonation).... If you use the standard settings of this command (but with Adaptation factor set to 0.6), the result will be a Sound with reasonable glottal flow derivatives centred around each of the original pulses in the point process. You can check this by selecting the Sound and choosing View & Edit: You will also see that the amplitude of the first two glottal wave shapes of every voiced stretch is (realistically) somewhat smaller than the amplitudes of the following wave shapes; This is the result of setting Adaptation factor to 0.6. What you have now is what we call a glottal source signal. It does two things: it contains information on the glottal flow, and it already takes into account one aspect of the filter, namely the radiation at the lips. This combination is standard procedure in acoustic synthesis. The glottal source signal sounds as a voice without a vocal tract. The following section describes how you add vocal-tract resonances, i.e. the filter. Automation In a clean Praat script, the procedure described above will look as follows: pitchTier = Create PitchTier: source, 0, 0.5 Add point: 0.0, 150 Add point: 0.5, 100 pulses = To PointProcess Remove points between: 0, 0.02 Remove points between: 0.24, 0.31 Remove points between: 0.48, 0.5 source = To Sound (phonation): 44100, 0.6, 0.05, 0.7, 0.03, 3.0, 4.0 removeObject: pitchTier, pulses selectObject: source Links to this page Source-filter synthesis 
Source-filter_synthesis_2__Filtering_a_source	Source-filter synthesis 2. Filtering a source Once you have a glottal source signal, you are ready to create a filter that represents the resonances of the vocal tract, as a function of time. In other words, you create a FormantGrid object. For a vowel spoken by an average (i.e. adult female) human voice, tradition assumes five formants in the range between 0 and 5500 hertz. This number comes from a computation of the formants of a straight tube, which has resonances at wavelengths of four tube lengths, four thirds of a tube length, four fifths, and so on. For a straight tube 16 centimetres long, the shortest wavelength is 64 cm, which, with a sound velocity of 352 m/s, means a resonance frequency of 352/0.64 = 550 hertz. The other resonances will be at 1650, 2750, 3850, and 4950 hertz. You can create a FormantGrid object with Create FormantGrid... from the New menu (submenu Tiers): Create FormantGrid: filter, 0, 0.5, 10, 550, 1100, 60, 50 This creates a FormantGrid with 10 formants and a single frequency value for each formant: F1 is 550 Hz and the higher formants are spaced 1100 Hz apart, i.e., they are 1650, 2750, 3850, 4950, 6050, 7150, 8250, 9350, and 10450 hertz; the ten bandwidths start at 60 Hz and have a spacing of 50 Hz, i.e., they are 60, 110, 160, 210, 260, 310, 360, 410, 460, and 510 hertz. You can then create formant contours with FormantGrid: Add formant point...: Remove formant points between: 1, 0, 0.5 Add formant point: 1, 0.00, 100 Add formant point: 1, 0.05, 700 Remove formant points between: 2, 0, 0.5 Add formant point: 2, 0.00, 500 Add formant point: 2, 0.05, 1100 This example creates a spectral specification whose F1 rises from 100 to 700 hertz during the first 50 milliseconds (as for any obstruent), and whose F2 rises from 500 to 1100 hertz. The other eight formants keep their original values, as do the ten bandwidths. The resulting sound may be a [ba]-like formant transition. To get the final acoustic result (the sound), you select the glottal source signal together with the FormantGrid and choose Sound & FormantGrid: Filter. The resulting sound will have a fairly straight intensity contour. You can change this with the Formula command (Sound: Formula...), or by multiplying the source signal or the acoustic result with an Intensity or IntensityTier object. Links to this page Source-filter synthesis 
Source-filter_synthesis_3__The_ba-da_continuum	Source-filter synthesis 3. The ba-da continuum As an example, we are going to create a male [ba]-[da] continuum in six steps. The acoustic difference between [ba] and [da] is the initial F2, which is 500 Hz for [ba], and 2500 Hz for [da]. We use the same PitchTier throughout, to model a falling intonation contour: Create PitchTier: f0, 0.00, 0.50 Add point: 0.00, 150 Add point: 0.50, 100 The first and last 50 milliseconds are voiceless: To PointProcess Remove points between: 0.00, 0.05 Remove points between: 0.45, 0.50 Generate the glottal source signal: To Sound (phonation): 44100, 0.6, 0.05, 0.7, 0.03, 3.0, 4.0 During the labial or coronal closure, the sound is almost silent, so we use an IntensityTier that models this: Create IntensityTier: intens, 0.00, 0.50 Add point: 0.05, 60 Add point: 0.10, 80 Generate the source signal: plusObject: Sound f0 Multiply Rename: source The ten sounds are generated in a loop: for i from 1 to 10 f2_locus = 500 + (2500/9) * (i - 1) ; variable names start with lower case! Create FormantGrid: filter, 0.0, 0.5, 9, 800, 1000, 60, 80 Remove formant points between: 1, 0.0, 0.5 Add formant point: 1, 0.05, 100 Add bandwidth point: 1, 0.05, 50 Add formant point: 2, 0.05, f2_locus Add bandwidth point: 2, 0.05, 100 plusObject: Sound source Filter (no scale) Rename: bada + string$ (i) removeObject: FormantGrid filter endfor Clean up: removeObject: Sound source, Sound f0, IntensityTier intens, ... PointProcess f0, PitchTier f0 In this example, filtering was done without automatic scaling, so that the resulting signals have equal intensities in the areas where they have equal formants. You will probably want to multiply all these signals with the same value in order to bring their amplitudes in a suitable range between -1 and +1 Pascal. Links to this page Source-filter synthesis 
Source-filter_synthesis_4__Using_existing_sounds	Source-filter synthesis 4. Using existing sounds 1. How to extract the filter from an existing speech sound You can separate source and filter with the help of the technique of linear prediction (see Sound: LPC analysis). This technique tries to approximate a given frequency spectrum with a small number of peaks, for which it finds the mid frequencies and the bandwidths. If we do this for an overlapping sequence of windowed parts of a sound signal (i.e. a short-term analysis), we get a quasi-stationary approximation of the signal's spectral characteristics as a function of time, i.e. a smoothed version of the Spectrogram. For a speech signal, the peaks are identified with the resonances (formants) of the vocal tract. Since the spectrum of a vowel spoken by an average human being falls off with approximately 6 dB per octave, pre-emphasis is applied to the signal before the linear-prediction analysis, so that the algorithm will not try to match only the lower parts of the spectrum. For an adult female human voice, tradition assumes five formants in the range between 0 and 5500 hertz, say at 550, 1650, 2750, 3850, and 4950 hertz. For the linear prediction in Praat, you will have to implement this 5500-Hz band-limiting by resampling the original speech signal to 11 kHz. For a male voice, you would use 10 kHz; for a young child, 20 kHz. To perform the resampling, you use Sound: Resample...: you select a Sound object, and click Resample.... In the rest of this tutorial, I will use the syntax that you would use in a script, though you will usually do these things by clicking on objects and buttons. Thus: selectObject: Sound hallo Resample: 11000, 50 You can then perform a linear-prediction analysis on the resampled sound with Sound: To LPC (burg)...: selectObject: Sound hallo_11000 To LPC (burg): 10, 0.025, 0.005, 50 This says that your analysis is done with 10 linear-prediction parameters (which will yield at most five formant-bandwidth pairs), with an analysis window effectively 25 milliseconds long, with time steps of 5 milliseconds (so that the windows will appreciably overlap), and with a pre-emphasis frequency of 50 Hz (which is the point above which the sound will be amplified by 6 dB/octave prior to the analysis proper). As a result, an object called LPC hallo will appear in the list of objects. This LPC object is a time function with 10 linear-prediction coefficients in each time frame. These coefficients are rather opaque even to the expert (try to view them with Inspect), but they are the raw material from which formant and bandwidth values can be computed. To see the smoothed Spectrogram associated with the LPC object, choose LPC: To Spectrogram...: selectObject: LPC hallo_11000 To Spectrogram: 20, 0, 50 Paint: 0, 0, 0, 0, 50, 0, 0, yes Note that when drawing this Spectrogram, you will want to set the pre-emphasis to zero (the fifth 0 in the last line), because pre-emphasis has already been applied in the analysis. You can get and draw the formant-bandwidth pairs from the LPC object, with LPC: To Formant and Formant: Speckle...: selectObject: LPC hallo_11000 To Formant Speckle: 0, 0, 5500, 30, yes Note that in converting the LPC into a Formant object, you may have lost some information about spectral peaks at very low frequencies (below 50 Hz) or at very high frequencies (near the Nyquist frequency of 5500 Hz. Such peaks usually try to fit an overall spectral slope (if the 6 dB/octave model is inappropriate), and are not seen as related with resonances in the vocal tract, so they are ignored in a formant analysis. For resynthesis purposes, they might still be important. Instead of using the intermediate LPC object, you could have done a formant analysis directly on the original Sound, with Sound: To Formant (burg)...: selectObject: Sound hallo To Formant (burg): 0.005, 5, 5500, 0.025, 50 A Formant object has a fixed sampling (time step, frame length), and for every formant frame, it contains a number of formant-bandwidth pairs. From a Formant object, you can create a FormantGrid with Formant: Down to FormantGrid. A FormantGrid object contains a number of tiers with time-stamped formant points and bandwidth points. Any of these three types (LPC, Formant, and FormantGrid) can represent the filter in source-filter synthesis. 2. How to extract the source from an existing speech sound If you are only interested in the filter characteristics, you can get by with Formant objects. To get at the source signal, however, you need the raw LPC object: you select it together with the resampled Sound, and apply inverse filtering: selectObject: Sound hallo_11000, LPC hallo_11000 Filter (inverse) A new Sound named hallo_11000 will appear in the list of objects (you could rename it to source). This is the estimated source signal. Since the LPC analysis was designed to yield a spectrally flat filter (through the use of pre-emphasis), this source signal represents everything in the speech signal that cannot be attributed to the resonating cavities. Thus, the source signal will consist of the glottal volume-velocity source (with an expected spectral slope of -12 dB/octave for vowels) and the radiation characteristics at the lips, which cause a 6 dB/octave spectral rise, so that the resulting spectrum of the source signal is actually the derivative of the glottal flow, with an expected spectral slope of -6 dB/octave. Note that with inverse filtering you cannot measure the actual spectral slope of the source signal. Even if the actual slope is very different from -6 dB/octave, formant extraction will try to match the pre-emphasized spectrum. Thus, by choosing a pre-emhasis of -6 dB/octave, you impose a slope of -6 dB/octave on the source signal. 3. How to do the synthesis You can create a new Sound from a source Sound and a filter, in at least four ways. If your filter is an LPC object, you select it and the source, and choose LPC & Sound: Filter...: selectObject: Sound source, LPC filter Filter: no If you had computed the source and filter from an LPC analysis, this procedure should give you back the original Sound, except that windowing has caused 25 milliseconds at the beginning and end of the signal to be set to zero. If your filter is a Formant object, you select it and the source, and choose Sound & Formant: Filter: selectObject: Sound source, Formant filter Filter If you had computed the source and filter from an LPC analysis, this procedure will not generally give you back the original Sound, because some linear-prediction coefficients will have been ignored in the conversion to formant-bandwidth pairs. If your filter is a FormantGrid object, you select it and the source, and choose Sound & FormantGrid: Filter: selectObject: Sound source, FormantGrid filter Filter Finally, you could just know the impulse response of your filter (in a Sound object). You then select both Sound objects, and choose Sounds: Convolve...: selectObject: Sound source, Sound filter Convolve: integral, zero As a last step, you may want to bring the resulting sound within the [-1; +1] range: Scale peak: 0.99 4. How to manipulate the filter You can hardly change the values in an LPC object in a meaningful way: you would have to manually change its rather opaque data with the help of Inspect. A Formant object can be changed in a friendlier way, with Formant: Formula (frequencies)... and Formant: Formula (bandwidths).... For instance, to multiply all formant frequencies by 0.9, you do selectObject: Formant filter Formula (frequencies): self * 0.9 To add 200 hertz to all values of F2, you do Formula (frequencies): if row = 2 then self + 200 else self fi A FormantGrid object can be changed by adding or removing points: FormantGrid: Add formant point... FormantGrid: Add bandwidth point... FormantGrid: Remove formant points between... FormantGrid: Remove bandwidth points between... 5. How to manipulate the source signal You can manipulate the source signal in the same way you that would manipulate any sound, for instance with the ManipulationEditor. Links to this page Source-filter synthesis 
Speaker	Speaker One of the types of objects in Praat. See Articulatory synthesis. Speaker commands • Create Speaker... • Artword & Speaker: To Sound...: articulatory synthesis 
Special_symbols	Special symbols When drawing text into the Picture window or into the TextGridEditor, you can use backslash sequences to display various kinds of special symbols. You can usually also type the characters themselves, if your computer has an input method for them. European symbols To get the symbol â (a-circumflex), you type \a^, i.e., a sequence of backslash + a + circumflex. In this way, you can get a hundred non-ASCII symbols that are used in the alphabets of many European languages. ä \a ë \e ï \i ö \o ü \u ÿ \y Ä \A Ë \E Ï \I Ö \O Ü \U Ÿ \Y á \a' ć \c' é \e' í \i' ń \n' ó \o' ś \s' ú \u' ý \y' ź \z' Á \A' Ć \C' É \E' Í \I' Ń \N' Ó \O' Ś \S' Ú \U' Ý \Y' Ź \Z' ő \o: ű \u: Ő \O: Ű \U: à \a` è \e` ì \i` ò \o` ù \u` À \A` È \E` Ì \I` Ò \O` Ù \U` â \a^ ê \e^ î \i^ ô \o^ û \u^ Â \A^ Ê \E^ Î \I^ Ô \O^ Û \U^ ã \a~ ñ \n~ õ \o~ Ã \A~ Ñ \N~ Õ \O~ č \c< ď \d< ě \e< ǧ \g< ň \n< ř \r< š \s< ť \t< ž \z< Č \C< Ď \D< Ě \E< Ǧ \G< Ň \N< Ř \R< Š \S< Ť \T< Ž \Z< đ \d- Đ \D- å \ao ů \uo Å \Ao Ů \Uo ą \a; ę \e; Ą \A; Ę \E; æ \ae Æ \Ae ø \o/ Ø \O/ ç \c, Ç \C, ł \l/ Ł \L/ ß \ss þ \th ż \z! Ż \Z! ¡ \!d ¿ \?d € \eu euro, £ \Lp pound sterling, ¥ \Y= yen, ƒ \fd florin, ¢ \c/ cent § \SS section, ¶ \|| pilcrow (paragraph) © \co copyright, ® \re registered, ™ \tm trademark ª \a_ feminine ordinal, º \o_ masculine ordinal « \<< left-pointing guillemet, » \>> right-pointing guillemet Mathematical symbols · \.c middle dot, × \xx multiplication, ÷ \:- division, ∕ \/d division slash ° \dg degree, ′ \'p prime (minute), ″ \p double prime (second) − \-m minus, – \-- en-dash, ± \+- plus-minus ≤ \<_ less than or equal to, ≥ \>_ greater than or equal to, ≠ \=/ not equal to ¬ \no logical not, ∧ \an logical and, ∨ \or logical or ∀ \At for all, ∃ \Er there exists, ∴ \.3 therefore ∝ \oc proportional to, ≡ \=3 defined as (or congruent modulo), ≈ \~~ approximately equal to √ \Vr square root ← \<-, → \->, ↔ \<> ⇐ \<=, ⇒ \=>, ⇔ \eq ↑ \^|, ≅ \=~ congruent to, ↓ \_| ∞ \oo infinity, ⊥ \Tt up tack (perpendicular to) ∅ \O| empty set, ∩ \ni intersection, ∪ \uu union, ⊂ \c= subset of, ∈ \e= element of ∂ \dd partial differential ⊗ \ox circled times, ⊕ \o+ circled plus ∑ \su summation, ∫ \in integral Greek letters To get ευρηκα, you type \ep\up\ro\et\ka\al. α \al Α \Al alpha β \be Β \Be beta γ \ga Γ \Ga gamma δ \de Δ \De delta ε \ep Ε \Ep epsilon ζ \ze Ζ \Ze zeta η \et Η \Et eta θ \te Θ \Te theta ϑ \t2 ι \io Ι \Io iota κ \ka Κ \Ka kappa λ \la Λ \La lambda μ \mu Μ \Mu mu ν \nu Ν \Nu nu ξ \xi Ξ \Xi xi ο \on Ο \On omicron π \pi Π \Pi pi ρ \ro Ρ \Ro rho σ \si Σ \Si sigma ς \s2 τ \ta Τ \Ta tau υ \up Υ \Up upsilon φ \fi Φ \Fi phi ϕ \f2 χ \ci Χ \Ci chi ψ \ps Ψ \Ps psi ω \om Ω \Om omega ϖ \o2 Hebrew letters To get an alef, you type \?+. On Windows, you have to install international support to get the left-to-right order correct. א \?+alef ב \B+bet ג \G+gimel ד \D+dalet ה \H+he ו \V+vav ז \Z+zayin ח \X+het ט \Y+tet י \J+yod כ \K+kafך \K% ל \L+lamed מ \M+memם \M% נ \N+nunן \N% ס \S+samekh ע \9+ayin פ \P+peף \P% צ \C+tsadiץ \C% ק \Q+qof ר \R+resh ש \W+shin ת \T+tav אִ \?+\hIhiriq אֶ \?+\sEsegolאֵ \?+\cEtsere אָ \?+\qAqamatsאַ \?+\pApatah אֹ \?+\hOholam אֻ \?+\qUqubuts ּ \dqdagesh or maliq Combinations: וֹ \vOvav holam וּ \sUshuruq Phonetic symbols See Phonetic symbols Miscellaneous \ \bs backslash • \bu bullet ♣ \cl (club), ♦ \di (diamond), ♥ \he (heart), ♠ \sp (spade) ☞ \pf pointing finger, ❀ \f5 flower-five See also Text styles Links to this page Font menu Formulas 5. String functions ManPages Text... Unicode Viewport text... What was new in 4.0? What was new in 5.0? WordList 
Spectra__Multiply	Spectra: Multiply Returns a new Spectrum object that is the product of the two selected Spectrum objects. 
spectro-temporal_representation	spectro-temporal representation A representation (of a sound signal, for instance) as some sort of intensity as a function of time and frequency. In Praat, we have the Spectrogram, which is acoustic energy density as a function of time in seconds and frequency in Hz, and the Cochleagram, which is basilar membrane excitation as a function of time in seconds and frequency in Bark. For tutorial information, see Intro 3.1. Viewing a spectrogram. 
Spectrogram	Spectrogram One of the types of objects in Praat. For tutorial information, see Intro 3. Spectral analysis. A Spectrogram object represents an acoustic time-frequency representation of a sound: the power spectral density PSD (f, t), expressed in Pa2/Hz. It is sampled into a number of points centred around equally spaced times ti and frequencies fj. Inside a Spectrogram With Inspect, you will see the following attributes: xmin start time, in seconds. xmax end time, in seconds. nx the number of times (≥ 1). dx time step, in seconds. x1 the time associated with the first column, in seconds. This will usually be in the range [xmin, xmax]. The time associated with the last column (i.e., x1 + (nx – 1) dx)) will also usually be in that range. ymin lowest frequency, in Hertz. Normally 0. ymax highest frequency, in Hertz. ny the number of frequencies (≥ 1). dy frequency step, in Hertz. y1 the frequency associated with the first row, in Hertz. Usually dy / 2. The frequency associated with the last row (i.e., y1 + (ny – 1) dy)) will often be ymax - dy / 2. zij, i = 1 ... ny, j = 1 ... nx the power spectral density, in Pa2/Hz. Links to this page Formulas 1.8. Formulas for modification Formulas 7. Attributes of objects Intro 3.5. The Spectrogram object Sound: To Spectrogram... Source-filter synthesis 4. Using existing sounds spectro-temporal representation Spectrogram: Formula... Spectrogram: Paint... Spectrogram: To Spectrum (slice)... Spectrum: To Spectrogram time domain 
Spectrogram__Formula___	Spectrogram: Formula... A command for changing the data in all selected Spectrogram objects. See the Formulas tutorial for examples and explanations. 
Spectrogram__Paint___	Spectrogram: Paint... A command to draw the selected Spectrogram object(s) into the Picture window in shades of grey. Settings From time (s) To time (s) the time domain along the x axis. From frequency (Hz) To frequency (Hz) the frequency domain along the y axis. Dynamic range (dB) The global maximum of the spectrogram (after preemphasis) will always be drawn in black; all values that are more than Dynamic range dB below this maximum (after dynamic compression) will be drawn in white. Values in-between have appropriate shades of grey. Preemphasis (dB/octave) determines the steepness of a high-pass filter, i.e., how much the power of higher frequencies will be raised before drawing, as compared to lower frequencies. Since the spectral slope of human vowels is approximately -6 dB per octave, the standard value for this parameter is +6 dB per octave, so that the spectrum is flattened and the higher formants look as strong as the lower ones. Dynamic compression determines how much stronger weak time frames should be made before drawing. Normally, this parameter is between 0 and 1. If it is 0, there is no dynamic compression. If it is 1, all time frames (vertical bands) will be drawn equally strong, i.e., all of them will contain frequencies that are drawn in black. If this parameter is 0.4 and the global maximum is at 80 dB, then a frame with a maximum at 20 dB (which will normally be drawn all white if the dynamic range is 50 dB), will be raised by 0.4 * (80 - 20) = 24 dB, so that its maximum will be seen at 44 dB (thus making this frame visible). Links to this page Intro 3.5. The Spectrogram object Sound: To Spectrogram... 
Spectrogram__To_Spectrum__slice____	Spectrogram: To Spectrum (slice)... A command to create a Spectrum object from every selected Spectrogram object. Purpose to extract the information contained in a Spectrogram at a certain time. Algorithm The Spectrum will be constructed from one frame of the Spectrogram, namely the frame whose centre is closed to the time argument. 
Spectrogram_settings___	Spectrogram settings... A command in the Spectrogram menu of the SoundEditor and TextGridEditor windows. See Intro 3.2. Configuring the spectrogram. 
Spectrum	Spectrum One of the types of objects in Praat. A Spectrum object represents the complex spectrum as a function of frequency. If the spectrum was created from a sound (which is expressed in units of Pascal), the complex values are expressed in units Pa/Hz (Pascal per Hertz). For detailed information, see Sound: To Spectrum.... Spectrum commands Creation: • Sound: To Spectrum... Queries: • Spectrum: Get centre of gravity... • Spectrum: Get standard deviation... • Spectrum: Get skewness... • Spectrum: Get kurtosis... • Spectrum: Get central moment... Modification: • Spectrum: Filter (pass Hann band)... • Spectrum: Filter (stop Hann band)... • Formula... Conversion: • Spectrum: To Ltas (1-to-1) • Spectrum: To Spectrogram Synthesis: • Spectrum: To Sound Links to this page Band filtering in the frequency domain Formulas 1.8. Formulas for modification Formulas 7. Attributes of objects Intro 3.6. Viewing a spectral slice Intro 3.8. The Spectrum object LPC: To Spectrum (slice)... Polynomial: To Spectrum... power spectral density Sound: Deepen band modulation... Spectra: Multiply Spectrogram: To Spectrum (slice)... Spectrum: Conjugate Spectrum: Formula... Spectrum: Shift frequencies... SpectrumEditor 
Spectrum__Conjugate	Spectrum: Conjugate Reverses the sign of the complex part of the selected Spectrum object(s). For real signals, conjugation in the spectral domain amounts to time-inversion in the time domain. 
Spectrum__Filter__pass_Hann_band____	Spectrum: Filter (pass Hann band)... A command to modify every selected Spectrum object. The complex values in the Spectrum are multiplied by real-valued sine shapes and straight lines, according to the following figure: Settings From frequency (Hz) (standard value: 500 Hz) the lower edge of the pass band (f1 in the figure). The value zero is special: the filter then acts as a low-pass filter. To frequency (Hz) (standard value: 1000 Hz) the upper edge of the pass band (f2 in the figure). The value zero is special: the filter then acts as a high-pass filter. Smoothing (Hz) (standard value: 100 Hz) the width of the region between pass and stop (w in the figure). Usage Because of its symmetric Hann-like shape, the filter is especially useful for decomposing the Spectrum into consecutive bands. For instance, we can decompose the spectrum into the bands 0-500 Hz, 500-1000 Hz, 1000-2000 Hz, and 2000-0 Hz: By adding the four bands together, we get the original spectrum again. A complementary filter is described at Spectrum: Filter (stop Hann band).... See the Filtering tutorial for information on the need for smoothing and a comparative discussion of various filters. Links to this page Sound: Filter (pass Hann band)... 
Spectrum__Filter__stop_Hann_band____	Spectrum: Filter (stop Hann band)... A command to modify every selected Spectrum object. The complex values in the Spectrum are multiplied by real-valued sine shapes and straight lines, according to the following figure: Settings From frequency (Hz) (standard value: 500 Hz) the lower edge of the stop band (f1 in the figure). The value zero is special: the filter then acts as a high-pass filter. To frequency (Hz) (standard value: 1000 Hz) the upper edge of the stop band (f2 in the figure). The value zero is special: the filter then acts as a low-pass filter. Smoothing (Hz) (standard value: 100 Hz) the width of the region between stop and pass (w in the figure). Usage This filter is the complement from the pass-band filter (Spectrum: Filter (pass Hann band)...). For instance, we can decompose the spectrum into the above stop-band spectrum and a band from 500 to 1000 Hz: By adding the two spectra together, we get the original spectrum again. See the Filtering tutorial for information on the need for smoothing and a comparative discussion of various filters. Links to this page Sound: Filter (stop Hann band)... 
Spectrum__Formula___	Spectrum: Formula... A command for changing the data in all selected Spectrum objects. See the Formulas tutorial for examples and explanations. 
Spectrum__Get_central_moment___	Spectrum: Get central moment... A command to query the selected Spectrum object. If the complex spectrum is given by S(f), the nth central spectral moment is given by ∫0∞ (f – fc)n |S(f)|p df divided by the energy ∫0∞ |S(f)|p df In this formula, fc is the spectral centre of gravity (see Spectrum: Get centre of gravity...). Thus, the nth central moment is the average of (f – fc)n over the entire frequency domain, weighted by |S(f)|p. For p = 2, the weighting is done by the power spectrum, and for p = 1, the weighting is done by the absolute spectrum. A value of p = 2/3 has been seen as well. Settings Moment the number n in the formulas above. A number of 3 gives you the third central spectral moment. It is not impossible to ask for fractional moments, e.g. n = 1.5. Power the quantity p in the formula above. Common values are 2, 1, or 2/3. Usage For n = 1, the central moment should be zero, since the centre of gravity fc is computed with the same p. For n = 2, you get the variance of the frequencies in the spectrum; the standard deviation of the frequency is the square root of this. For n = 3, you get the non-normalized spectral skewness; to normalize it, you can divide by the 1.5 power of the second moment. For n = 4, you get the non-normalized spectral kurtosis; to normalize it, you can divide by the square of the second moment and subtract 3. Praat can directly give you the quantities mentioned here: • Spectrum: Get centre of gravity... • Spectrum: Get standard deviation... • Spectrum: Get skewness... • Spectrum: Get kurtosis... 
Spectrum__Get_centre_of_gravity___	Spectrum: Get centre of gravity... A command to query the selected Spectrum object. If the complex spectrum is given by S(f), where f is the frequency, the centre of gravity is given by ∫0∞ f |S(f)|p df divided by the energy ∫0∞ |S(f)|p df Thus, the centre of gravity is the average of f over the entire frequency domain, weighted by |S(f)|p. For p = 2, the weighting is done by the power spectrum, and for p = 1, the weighting is done by the absolute spectrum. A value of p = 2/3 has been seen as well. Setting Power the quantity p in the formulas above. Common values are 2, 1, or 2/3. Interpretation The spectral centre of gravity is a measure for how high the frequencies in a spectrum are on average. For a sine wave with a frequency of 377 Hz, the centre of gravity is 377 Hz. You can easily check this in Praat by creating such a sine wave (Create Sound from formula...), then converting it to a Spectrum (Sound: To Spectrum...), then querying the mean frequency. For a white noise sampled at 22050 Hz, the centre of gravity is 5512.5 Hz, i.e. one half of the Nyquist frequency. Related measures The centre of gravity is used in the computation of spectral moments: • Spectrum: Get central moment... • Spectrum: Get standard deviation... • Spectrum: Get skewness... • Spectrum: Get kurtosis... 
Spectrum__Get_kurtosis___	Spectrum: Get kurtosis... A command to query the selected Spectrum object. The (normalized) kurtosis of a spectrum is the fourth central moment of this spectrum, divided by the square of the second central moment, minus 3. See Spectrum: Get central moment.... Setting Power the quantity p in the formula for the centre of gravity and the second and fourth central moment. Common values are 2, 1, or 2/3. Interpretation The kurtosis is a measure for how much the shape of the spectrum around the centre of gravity is different from a Gaussian shape. For a white noise, the kurtosis is -6/5. Related measures • Spectrum: Get centre of gravity... • Spectrum: Get central moment... • Spectrum: Get standard deviation... • Spectrum: Get skewness... 
Spectrum__Get_skewness___	Spectrum: Get skewness... A command to query the selected Spectrum object. The (normalized) skewness of a spectrum is the third central moment of this spectrum, divided by the 1.5 power of the second central moment. See Spectrum: Get central moment.... Setting Power the quantity p in the formula for the centre of gravity and the second and third central moment. Common values are 2, 1, or 2/3. Interpretation The skewness is a measure for how much the shape of the spectrum below the centre of gravity is different from the shape above the mean frequency. For a white noise, the skewness is zero. Related measures • Spectrum: Get centre of gravity... • Spectrum: Get central moment... • Spectrum: Get standard deviation... • Spectrum: Get kurtosis... 
Spectrum__Get_standard_deviation___	Spectrum: Get standard deviation... A command to query the selected Spectrum object. The standard deviation of a spectrum is the square root of the second central moment of this spectrum. See Spectrum: Get central moment.... Setting Power the quantity p in the formula for the centre of gravity and the second central moment. Common values are 2, 1, or 2/3. Interpretation The standard deviation is a measure for how much the frequencies in a spectrum can deviate from the centre of gravity. For a sine wave, the standard deviation is zero. For a white noise, the standard deviation is the Nyquist frequency divided by √12. Related measures • Spectrum: Get centre of gravity... • Spectrum: Get central moment... • Spectrum: Get skewness... • Spectrum: Get kurtosis... 
Spectrum__Shift_frequencies___	Spectrum: Shift frequencies... Creates a new Spectrum by shifting all frequencies of the selected Spectrum upwards or downwards. Settings Shift by (Hz) a positive value shifts the spectrum towards higher frequencies, a negative value shifts the spectrum towards lower frequencies. New maximum frequency (Hz) the maximum frequency in the new Spectrum. Precision the number of neighbouring frequency points that are used in the calculation of the new frequency points. The precision relates linearly to the amount of computing time needed to get the new shifted spectrum. 
Spectrum__To_Ltas__1-to-1_	Spectrum: To Ltas (1-to-1) A command for converting each selected Spectrum object into an Ltas object without loss of frequency resolution. Algorithm Each band bi in the Ltas is computed from a single frequency sample si in the Spectrum as follows: bi = 2 ((re (si))2 + (im (si))2) / 4.0·10-10 If the original Spectrum is expressible in Pa / Hz (sound pressure in air), the Ltas values are in dB/Hz relative to the auditory threshold at 1000 Hz (2·10-5 Pa). Links to this page Ltas: Get frequency of maximum... Ltas: Get frequency of minimum... Ltas: Get maximum... Ltas: Get minimum... 
Spectrum__To_Sound	Spectrum: To Sound A command for creating a Sound object from every selected Spectrum object. Mathematical procedure The reverse of the Fourier transform described in Sound: To Spectrum.... If the Spectrum is expressed in Pa/Hz, the Sound will be in Pascal. The frequency integral over the Sound equals the time integral over the Spectrum. Behaviour If you perform this command on a Spectrum object that was created earlier with Sound: To Spectrum..., the resulting Sound is equal to the Sound that was input to Sound: To Spectrum.... Links to this page Fast Fourier Transform Sound: Filter (formula)... Sound: Filter (pass Hann band)... Sound: Filter (stop Hann band)... 
Spectrum__To_Spectrogram	Spectrum: To Spectrogram A command to create a Spectrogram object from every selected Spectrum object. Purpose Format conversion. Behaviour The Spectrogram will have only one frame (time slice). Algorithm The values are computed as the sum of the squares of the real and imaginary parts of the Spectrum. 
SpectrumEditor	SpectrumEditor One of the editors in Praat. It allows you to view, zoom, and play a Spectrum object. Clicking on one of the (maximally) 8 rectangles above or below the drawing area lets you play a Sound that is synthesized from a band-filtered part of the Spectrum. You can also copy the Spectrum, band-filtered with the frequency selection, or the Sound synthesized from this Spectrum, to the list of objects. Links to this page Intro 3.6. Viewing a spectral slice Types of objects What was new in 3.6? 
SpeechSynthesizer	SpeechSynthesizer The SpeechSynthesizer is one of the types of objects in Praat. It creates a speech sound from text. The actual text-to-speech synthesis is performed by the Espeak speech synthsizer and therefore our SpeechSynthsizer is merely an interface to Espeak. Commands Creation: Create SpeechSynthesizer... Playing: Play text... To Sound... Modification: Set text input settings... Set speech output settings... 
SpeechSynthesizer__Play_text___	SpeechSynthesizer: Play text... The selected SpeechSynthesizer plays a text Settings Text is the text to be played. Text within [[ ]] is treated as phonemes codes in Kirshenbaum phonetic encoding. For example, besides a text like This is text, you might also input This [[Iz]] text. 
SpeechSynthesizer__Set_speech_output_settings___	SpeechSynthesizer: Set speech output settings... A command available in the Modify menu when you select a SpeechSynthesizer. Settings Sampling frequency determines how the sampling frequency of the sound. Gap between words determines the amount of silence between words. Pitch adjustment Pitch range Words per minute determines the speaking rate in words per minute. estimate words per minute from data Output phoneme codes are 
SpeechSynthesizer__Set_text_input_settings___	SpeechSynthesizer: Set text input settings... A command available in the Modify menu when you select a SpeechSynthesizer. Settings Input text format is determines how the input text will be synthesized. Input phoneme codes are 
SpeechSynthesizer__To_Sound___	SpeechSynthesizer: To Sound... The selected SpeechSynthesizer converts a text to the corresponding speech sound. Settings Text is the text to be played. Text within [[ ]] is treated as phonemes codes in Kirshenbaum phonetic encoding. For example, besides a text like This is text, you might also input This [[Iz]] text. Create TextGrid with annotations determines whether, besides the sound, a TextGrid with multiple-tier annotations will appear. 
SpellingChecker	SpellingChecker One of the types of objects in Praat. For checking the spelling in texts and TextGrid objects. 1. How to create a SpellingChecker object You normally read in a SpellingChecker with Read from file... from the Open menu. 2. How to check the spelling of a TextGrid A SpellingChecker object can be used fur purposes of spelling checking. In order to check the spellings in a TextGrid object, you first view the TextGrid in an editor window by selecting the TextGrid together with the SpellingChecker object, and clicking View & Edit. In most cases, you will also want to select a Sound or LongSound object before clicking View & Edit, so that a representation of the sound is also visible (and audible) in the editor. Thus, you typically select three objects and click View & Edit. The editor then allows you to check the spellings (commands Check spelling in tier and Check spelling in interval from the Spell menu). 3. How to create a SpellingChecker object for the first time If you are the maintainer of a word list for spelling checking, you will want to convert this list to a SpellingChecker object that you can distribute among the transcribers of your corpus. The first step is to create a WordList object from your text file, as described on the WordList man page. Then you simply click To SpellingChecker. A button labelled Edit... appears. This command allows you to set the following attributes of the SpellingChecker object: Allow all parenthesized this flag determines whether text between parentheses is ignored in spelling checking. This would allow the transcriber to mark utterances in foreign languages, which cannot be found in the lexicon. Separating characters determines the set of characters (apart from the space character) that separate words. The standard is .,;:(). If a string like error-prone should be considered two separate words, you will like to change this to .,;:()-. For the Corpus of Spoken Dutch (CGN), the hyphen is not a separator, since words like mee-eter should be checked as a whole. If a string like Mary's should be considered two separate words, include the apostrophe. Allow all names determines whether all words that start with a capital are allowed. For the CGN, this is on, since the lexicon does not contain many names. Name prefixes a space-separated list that determines what small groups of characters can precede names. For the CGN, this is 's- d' l', since names like 's-Gravenhage, d'Ancona, and l'Hôpital should be ignored by the spelling checker. Allow all words containing a space-separated list of strings that make a word correct even if not in the lexicon. For the CGN, this is * xxx, since words like keuje*d and verxxxing should be ignored by the spelling checker. Allow all words starting with a space-separated list of prefixes that make a word correct even if not in the lexicon. For the CGN, this is empty. Allow all words ending in a space-separated list of suffixes that make a word correct even if not in the lexicon. For the CGN, this is -, since the first word in verzekerings- en bankwezen should be ignored by the spelling checker. Links to this page TextGridEditor What was new in 3.9? 
spline	spline A spline function f is a piecewise polynomial function defined on an interval [xmin, xmax] with specified continuity constraints, i.e., when the interval [xmin, xmax] is subdivided by points ξi such that xmin = ξ1 < ... < ξq = xmax, then within each subinterval [ξj, ξj+1) the function is a polynomial Pj of specified degree k. A knot sequence t = {t1, ..., tn+k}, where n is the number of free parameters that specify the spline function, is derived from the ξi by placing knots at the boundary values ξi according to the order of continuity at that boundary. The most common continuity characteristics imposed on f request that for adjacent polynomials the derivatives up to order k–2 match. For example, the knot sequence of a spline of order k for a partition of [xmin, xmax] into three intervals (q = 4) will be t1 = ... = tk = xmin (=ξ1), tk+1 = ξ2, tk+2 = ξ3 , tk+3 = ... = tk+k+2 = xmax (= ξ4). This is called a simple knot sequence, because all interior knots are simple. The number of free parameters n for this case obeys a simple formula: n = numberOfInteriorKnots + order. With suitable basis functions, for example, the M-spline family Mi(x|k, t), i=1..n, we can write any spline f in the form: f = ∑i=1..n aiMi, where the Mi are defined by the following recursive formula's: Mi(x|1,t) = 1 / (ti+1 – ti), ti ≤ x < ti+1, 0 otherwise Mi(x|k,t) = k [(x–ti)Mi(x|k–1,t) + (ti+k–x)Mi+1(x|k–1,t)] / ((k–1)(ti+k–ti)) These Mi are localized because Mi(x|k,t) > 0 only when ti ≤ x < ti+k and zero otherwise. Also, we have ∫ Mi(x)dx = 1. Because of this localization a change in coefficient ai will only effect f within this interval. The following picture shows an M-spline of order 3 on the interval [0, 1], with three interior knots at 0.3, 0.5 and 0.6. Because the M-splines are nonnegative, monotone splines can be derived from them by integration: Ii(x|k,t) = ∫xminx Mi(u|k,t) du Because each Mi(x|k, t) is a piecewise polynomial of degree k–1, each Ii will be of degree k. Now we can write: f = ∑i=1..n biIi(x|k,t) We can use an M-spline of order k+1 with a simple knot sequence t, for which tj ≤ x < tj+1, to put the I-spline of order k into a more convenient form: Ii(x|k,t) = 0, i > j Ii(x|k,t) = ∑m=i+1..j (tm+k+1–tm)Mm(x|k+1,t)/(k+1), j–k ≤ i ≤ j Ii(x|k,t) = 1, i < j–k The following figure shows the I-splines that were derived from the M-splines above. These spline formula's were taken from Ramsay (1988) and the errors in his I-spline formulas were corrected. Links to this page Create ISpline... Create MSpline... Dissimilarity & Configuration: Draw regression (i-spline mds)... Dissimilarity: To Configuration (i-spline mds)... ISpline MDS models MSpline 
SSCP	SSCP One of the types of objects in PRAAT. An object of type SSCP represents the sums of squares and cross products of a multivariate data set. Besides the matrix part, an object of type SSCP also contains a vector with centroids. Inside a SSCP With Inspect you will see that this type contains the same attributes as a TableOfReal with the following extras: numberOfObservations centroid Links to this page Covariance Discriminant & SSCP: Project Discriminant: Extract pooled within-groups SSCP Discriminant: Extract within-group SSCP... Eigen & SSCP: Project PCA & SSCP: Project Principal component analysis SSCP & TableOfReal: Extract quantile range... SSCP: Draw sigma ellipse... SSCP: Get confidence ellipse area... SSCP: Get diagonality (bartlett)... SSCP: Get fraction variation... SSCP: Get sigma ellipse area... SSCP: To CCA... SSCP: To Covariance... TableOfReal: To SSCP... 
SSCP___TableOfReal__Extract_quantile_range___	SSCP & TableOfReal: Extract quantile range... Extract those rows from the selected TableOfReal object whose Mahalanobis distance, with respect to the selected SSCP object, are within the quantile range. 
SSCP__Draw_sigma_ellipse___	SSCP: Draw sigma ellipse... A command to draw for the selected SSCP an ellipse that covers a part of the multivariate data. Setting Number of sigmas determines the data coverage. 
SSCP__Get_confidence_ellipse_area___	SSCP: Get confidence ellipse area... A command to query the selected SSCP object for the area of a confidence ellipse. Algorithm The algorithm proceeds as follows: 1. The four array elements in the SSCP-matrix that correspond to the chosen dimensions are copied into a two-dimensional matrix S (symmetric of course). 2. The eigenvalues of S are determined, call them s1 and s2. 3. The lengths l1 and l2 of the two axes of the ellipse can be obtained as (see for example Johnson (1998), page 410): li = scaleFactor · √ (si ), where scaleFactor = √ (f · p · (n – 1) / (n · (n – p))), in which f = invFisherQ (1 – confidenceLevel, p, n – p), where p is the numberOfRows from the SSCP object and n the numberOfObservations. 4. The area of the ellipse will be π·l1·l2. Links to this page Discriminant: Get confidence ellipse area... 
SSCP__Get_diagonality__bartlett____	SSCP: Get diagonality (bartlett)... Tests the hypothesis that the selected SSCP matrix object is diagonal. Setting Number of constraints modifies the number of independent observations. The default value is 1. Algorithm The test statistic is |R|N/2, the N/2-th power of the determinant of the correlation matrix. Bartlett (1954) developed the following approximation to the limiting distribution: χ2 = -(N - numberOfConstraints - (2p + 5) /6) ln |R| In the formula's above, p is the dimension of the correlation matrix, N-numberOfConstraints is the number of independent observations. Normally numberOfConstraints would equal 1, however, if the matrix has been computed in some other way, e.g., from within-group sums of squares and cross-products of k independent groups, numberOfConstraints would equal k. We return the probability α as α = chiSquareQ (χ2 , p(p-1)/2). A very low α indicates that it is very improbable that the matrix is diagonal. Links to this page What was new in 4.1? 
SSCP__Get_fraction_variation___	SSCP: Get fraction variation... A command to ask the selected SSCP object for the fraction of the total variation that is accounted for by the selected dimension(s). Further details can be found in Covariance: Get fraction variance.... 
SSCP__Get_sigma_ellipse_area___	SSCP: Get sigma ellipse area... A command to query the selected SSCP object for the area of a sigma ellipse. Algorithm The algorithm proceeds as follows: 1. The four array elements in the SSCP-matrix that correspond to the chosen dimensions are copied into a two-dimensional matrix S (symmetric of course). 2. The eigenvalues of S are determined, call them s1 and s2. 3. The lengths li of the axes of the ellipse can be obtained as the square root of the si multiplied by a scale factor: li = scaleFactor · √ (si ), where scaleFactor = numberOfSigmas / √(numberOfObservations – 1). 4. The area of the ellipse will be π·l1·l2. Links to this page Discriminant: Get concentration ellipse area... What was new in 3.9? 
SSCP__To_CCA___	SSCP: To CCA... A command that creates a canonical correlation object from the selected SSCP object. Setting Dimension of dependent variate (ny) defines a partition of the square n x n SSCP matrix S into the parts Syy of dimension ny x ny, Sxx of dimension nx x nx, and the parts Sxy and Syx of dimensions nx x ny and ny x nx, respectively. Algorithm The partition for the square SSCP-matrix is as follows: The canonical correlation equations we have to solve are: (1) (Syx Sxx-1 Syx′ -λ Syy)y = 0 (2) (Syx′ Syy-1 Syx -λ Sxx)x = 0 where Syy [ny × ny] and Sxx [nx × nx] are symmetric, positive definite matrices belonging to the dependent and the independent variables, respectively. These two equations are not independent and we will show that both equations have the same eigenvalues and that the eigenvectors x for equation (2) can be obtained from the eigenvectors y of equation (1). We can solve equation (1) in several ways, however, the numerically stablest algorithm is probably by performing first a Cholesky decomposition of Sxx and Syy, followed by a generalized singular value decomposition. The algorithm goes as follows: The Cholesky decompositions (square roots) of Syy and Sxx are: Syy = U′ U and Sxx = H′ H, where U and H are upper triangular matrices. From these decompositions, the inverse for Sxx-1 is easily computed. Let K be the inverse of H, then we can write: Sxx-1 = K K′. We next substitute in equation (1) and rewrite as: ((K′Syx′)′ (K′Syx′) - λ U′ U)x = 0 This equation can be solved for eigenvalues and eigenvectors by the generalized singular value decomposition because it is of the form A′A -λ B′B. Now, given the solution for equation (1) we can find the solution for equation (2) by first multiplying (1) from the left with Syx′Syy-1, resulting in: (Syx′Syy-1SyxSxx-1Syx′ -λ Syx′) y = 0 Now we split of the term Sxx-1Syx′ and obtain: (Syx′Syy-1Syx - λ Sxx) Sxx-1Syx′ y = 0 This equation is like equation (2) and it has therefore the same eigenvalues and eigenvectors. (We also proved this fact in the algorithmic section of TableOfReal: To CCA....) The eigenvectors x is now x = Sxx-1Syx′ y. 
SSCP__To_Covariance___	SSCP: To Covariance... A command that creates a Covariance object from each selected SSCP object. Setting Number of constraints determines the factor by which each entry in the SSCP-matrix is scaled to obtain the Covariance matrix. Details The relation between the numbers cij in the covariance matrix and the numbers sij in the originating SSCP matrix is: cij = sij / (numberOfObservations - numberOfConstraints) Normally numberOfConstraints will equal 1. However, when the SSCP was the result of summing g SSCP objects, as is, for example, the case when you obtained the total within-groups SSCP from pooling the individual group SSCP's, numberOfConstraints will equal the number of pooled SSCP's, g. 
start_time	start time - the beginning of the time domain (see there). 
Statistics	Statistics This is the tutorial about basic statistical techniques in Praat, which work with the Table object or even directly from the Goodies menu. It assumes that you are familiar with the Intro. (Under construction..................) Goodies menu: • Difference of two proportions For a selected Table: • Logistic regression For more sophisticated techniques, see: • Principal component analysis • Multidimensional scaling • Discriminant analysis Links to this page What was new in 4.1? 
stereo	stereo A stereo sound is a sound consisting of a left and a right channel. Praat can read and write both mono and stereo sounds. Reading a stereo sound from disk If you read a Sound into Praat from disk with Read from file..., and that sound file is a stereo file, the resulting Sound object will be a stereo Sound. If you want to look at the left or right channel separately, you can use Extract one channel.... Saving a stereo sound to disk If you choose Save as WAV file..., and the sound is a stereo sound, then the sound file will be a stereo file. If you have two mono sounds and you want to combine them into one stereo sound, you can use Combine to stereo. Links to this page Read separate channels from sound file... 
Stevens__1951_	Stevens (1951) S.S. Stevens (1951): Mathematics, measurement, and psychophysics. In S.S. Stevens (ed.): Handbook of experimental psychology. New York: Wiley. Links to this page Measurement levels 
stress	stress A badness-of-fit measure for the entire MDS representation. Several measures exist. Raw stress σr (d′, X) = ∑i<j wij(d′ij – dij(X))2 = ∑i<j wijd′ij2 + ∑i<j wijdij2(X) – 2 ∑i<j wijd′ijdij(X) = ηd′2 + η2(X) – 2ρ(d′, X) where the d′ij are the disparities that are the result from the transformation of the dissimilarities, i.e., f(δij). Raw stress can be misleading because it is dependent on the normalization of the disparities. The following measure tries to circumvent this inconvenience. Normalized stress σn = σr / ηd′2 This is the stress function that we minimize by iterative majorization. It goes back to De Leeuw (1977). Kruskal's stress-1 σ1 = √ (∑i<j wij(d′ij – dij(X))2 / ∑i<j wijdij2(X))1/2 In this measure, which is due to Kruskal (1964), stress is expressed in relation to the size of X. Kruskal's stress-2 σ2 = √ (∑i<j wij(d′ij – dij(X))2 / ∑i<j wij(dij(X) - averageDistance)2)1/2. In general, this measure results in a stress value that is approximately twice the value for stress-1. Relation between σ1 and σn When we have calculated σn for Configuration X, disparities d′ and Weight W we cannot directly use X, d′ and W to calculate σ1 because the scale of X is not necessarily optimal for σ1. We allow therefore a scale factor b > 0 and try to calculate σ1 (d′, b X). We minimize the resulting expression for b and substitute the result back into the formula for stress, i.e., σ12 (d′, b X) = (ηd′2 + b2 η2(X) – 2 b ρ(d′, X)) / b2 η2(X) dσ12 (b) / db == 0, gives b = ηd′2 / ρ σ12 = (1 - ρ2 / (ηd′2·η2(X))) This means that σ1 = √ σn. Relation between σ2 and σn We can do the same trick as before for σ2: σ22 (d′, b X) = (ηd′2 + b2 η2(X) – 2 b ρ(d′, X)) / (b2 ∑i<j wij(dij(X) - averageDistance)2) From which we derive: σ2 = √ ((ηd′2 · η2(X) - ρ2(d′, X)) / (ηd′2 · ∑i<j wij(dij(X) - averageDistance)2)) Links to this page Dissimilarity & Configuration & Weight: Get stress... Dissimilarity & Configuration & Weight: To Configuration... Dissimilarity & Configuration: Get stress (absolute mds)... Dissimilarity & Configuration: Get stress (i-spline mds)... Dissimilarity & Configuration: Get stress (interval mds)... Dissimilarity & Configuration: Get stress (monotone mds)... Dissimilarity & Configuration: Get stress (ratio mds)... Dissimilarity & Weight: To Configuration... Dissimilarity & Weight: To Configuration... Kruskal analysis MDS models Multidimensional scaling Weight 
Strings	Strings One of the types of objects in Praat. Represents an ordered list of strings. Creation The difficult way is to create a Strings object from a generic Praat text file (if there are non-ASCII symbols, use UTF-8 or UTF-16 format): ooTextFile Strings 5 ! number of strings Hello Goodbye Auf wiedersehen Tschüss Arrivederci In this example, we see that a double quote within a string should be written twice; the fourth string will therefore be read as Tschüss. This file can be read simply with the generic Read from file... command from the Open menu. An easier way is to use the special command Read Strings from raw text file.... The file can then simply look like this: Hello Goodbye Auf wiedersehen Tschüss Arrivederci You can also create a Strings object from a directory listing or from some other objects: • Create Strings as file list... • Distributions: To Strings... • OTGrammar: Generate inputs... • OTGrammar & Strings: Inputs to outputs... Links to this page Create Strings as directory list... Index: To Permutation... OT learning 2.9. Output distributions OT learning 3.1. Data from a pair distribution OT learning 3.2. Data from another grammar OT learning 4. Learning an ordinal grammar OT learning 5. Learning a stochastic grammar OT learning 7. Learning from overt forms PairDistribution: To Stringses... Strings & Permutation: Permute strings Strings: To Distributions Strings: To Index Strings: To Permutation... WordList 
Strings___Permutation__Permute_strings	Strings & Permutation: Permute strings Generate a new Strings with a strings ordering determined by the Permutation. The number of strings in the Strings and the number of elements in the Permutation have to be equal. Examples 1. If the selected Strings has the 4 strings ordered as heed, hid, hood, hud, and the permutation is (4,3,2,1), the new Strings has the ordering hud, hood, hid, heed. 2. In the example that is discussed in the listening experiment section, we have four stimuli heed.wav, hid.wav, hood.wav, hud.wav that we want to present three times to each subject with a <PermuteBalancedNoDoublets> randomization strategy, i.e. stimuli presented in blocks of four, randomized, and no two successive stimuli equal. This type of randomization can easily be accomplished with a Permutation object and a Strings. 1. Fill the Strings object with 12 strings, i.e. three repetitions of the four stimuli. 2. Create a Permutation object with 12 elements and perform Permute randomly (blocks): 0, 0, 4, yes, yes. We randomly permute blocks of size 4 and permute randomly within these blocks and make sure that on the transition from on block to the other no two stimuli are equal. (Of course, the random permutation of the blocks makes no difference here since all the blocks have the same content.) 3. Select the Strings and the Permutation together and choose Permute strings. Now the new Strings will contain the new ordering of the stimuli. Links to this page Index: To Permutation... Strings: To Permutation... 
Strings__To_Distributions	Strings: To Distributions A command to analyse each selected Strings object into a Distributions object. The resulting Distributions will collect the occurrences of every string in the Strings object, and put the number of occurrences in its first and only column. Example We start from the following Strings: 6 (number of strings) hallo dag allemaal hallo tot morgen hallo tot morgen This will give us the following Distributions: 1 (number of columns) (no column name) hallo 3 dag allemaal 1 tot morgen 2 Links to this page OT learning 2.9. Output distributions 
Strings__To_Index	Strings: To Index Generates an Index from the selected Strings. Example We start from the following Strings: 6 (number of strings) hallo dag allemaal hallo tot morgen hallo tot morgen This will give us the following Index: 1 (number of columns) (no column name) dag allemaal hallo tot morgen 6 (number of elements) 2 1 2 3 2 3 Links to this page Index: To Permutation... 
Strings__To_Permutation___	Strings: To Permutation... Generates a Permutation with the same number of elements as the Strings. Setting Sort determines whether the Permutation will have an element ordering that can be used to sort the Strings alphabetically. Example If Sort is on, and the selected Strings contains 4 strings ordered as hud, hid, hood, heed, the generated Permutation will be (4,2,3,1). If you now select the String and the Permutation together and choose Permute strings, the new Strings will have the strings ordered alphabetically as heed, hid, hood, hud. You can also sort the Strings alphabetically descending, by first reversing the elements in the Permutation before you select the Permutation and the Strings together. 
T-test	T-test A test on the mean of a normal variate when the variance is unknown. In Praat, the t-test is used to query a Covariance object and: 1. get the significance of one mean. See Covariance: Get significance of one mean.... 2. get the significance of the difference between two means. See Covariance: Get significance of means difference.... You should use a t-test when you want to test a hypothesis about the mean of one column in a TableOfReal object, or, if you want to test a hypothesis about the difference between the means of two columns in this object. You can perform these t-tests in Praat by first transforming the TableOfReal object into a Covariance object (see TableOfReal: To Covariance) and then choosing the appropriate query method on the latter object. Links to this page What was new in 4.1? 
Table	Table One of the types of objects in Praat. See the Statistics tutorial. Links to this page Create formant table (Peterson & Barney 1952) Create formant table (Pols & Van Nierop 1973) Create formant table (Weenink 1985) Formulas 7. Attributes of objects Table: Bar plot where... Table: Box plots where... Table: Get median absolute deviation... Table: Horizontal error bars plot where... Table: Horizontal error bars plot... Table: Line graph where... Table: Normal probability plot... Table: Quantile-quantile plot... Table: Report one-way anova... Table: Report one-way Kruskal-Wallis... Table: Report two-way anova... Table: Vertical error bars plot where... Table: Vertical error bars plot... What was new in 4.1? 
Table__Bar_plot_where___	Table: Bar plot where... Draws a bar plot from data in one or more columns of the selected Table. In a bar plot the horizontal axis has nominal values (labels). Settings Vertical column(s) you list the table columns that you want to represent in the bar plot. The number of selected columns is the group size. Vertical range determine the lower and upper limit of the display. Column with labels determines the column whose labels will be put at the bottom of the plot. Distance of first bar from border determines how far the first (and last) bar wil be positioned from the borders (in units of the width of one bar). Distance between bar groups determines how far groups of bars are from each other. Distance between bars within group determines the distance between the bars within each group. Colours determines the colours of the bars in a group. Label text angle (degrees) determines the angle of the labels written below the plot. If you have very long label texts you can prevent the label texts from overlapping. Formula: can be used to supply an expression to select only those rows for plotting where the expression evaluates to true. A 1 value always evaluates to true. Examples Keating & Esposito (2006) present a bar plot in their fig. 3 from which we estimate the following data table Language Modal Breathy Chong -1.5 5 Fuzhou 2 10 Green Hmong 3 12 White Hmong 2 11 Mon -1.5 0 SADV Zapotec -6 -4 SLQ Zapotec 3.5 14 Tlacolula Zapotec 3 13 Tamang 1 1 !Xoo 1 14 Given that we have these data in a Table with the three columns labeled Language, Modal and Breathy, respectively, we can first try to reproduce their figure 3 (a bar plot with both Modal and Breathy columns displayed) As you can see the labels in the first column are very long texts and they will surely overlap if plotted at the bottom of a plot. We therefore use a value of 15 degrees for the Label text angle parameter. This will make the label texts nonoverlapping. We cannot make this angle much larger because then the label texts will run out of the viewport. Sometimes you need to plot only a part of the Table and for the selection of this part, the Formula field can be used. Since we only have a small table we put a 1 in this field which always evaluates to true. In effect, all the rows will be selected. The following script line will produce the picture below. Bar plot where: Modal Breathy, -10, 20, Language, 1.0, 1.0, 0.0, 0.9 0.5, 15.0, yes, 1 The essentials of the bart plot in their paper are perfectly reproduced in the figure above. If you want the bars within a group to be placed somewhat more apart say 0.2 (times the bar width) you can set the Distance between bars in a group to a value of 0.2: Bar plot where: Modal Breathy, -10, 20, Language, 1.0, 1.0, 0.2, 0.9 0.5, 15.0, yes, 1 Of course we can also work with colours and we can add vertical marks as the following sriptlet shows Bar plot where: Modal Breathy, -10, 20, Language, 1.0, 1.0, 0.0, Green Red, 15.0, yes, 1 Marks left every: 1, 5, 1, 1, 1 Text left: 1, H1-H2 (dB) 
Table__Box_plots_where___	Table: Box plots where... A command to draw box plots from the data in a column of the selected Table object. Example To draw separate box plots for the male, female and children F0 for the Peterson & Barney (1952) data: Create formant table (Peterson & Barney 1952) Box plots where: F0, Type, 70, 400, 1 Text left: yes, F0 (Hz) 
Table__Get_median_absolute_deviation___	Table: Get median absolute deviation... Get the median absolute deviation (MAD) of the column in the selected Table (adjusted by a scale factor). Algorithm From the n numbers x1, x2, ..., xn in the selected column we first calculate the median value xmedian. Next we calculate the n absolute deviations from this median: d1, d2, ..., dn, where dj=|xj - xmedian|. Then we calculate the MAD value, which is the median of the n values d1, d2, ..., dn. Finally we multiply the MAD value by the scale factor 1.4826. This last multiplication makes the result comparable with the value of the standard deviation if the x values are normally distributed. 
Table__Horizontal_error_bars_plot___	Table: Horizontal error bars plot... Draws horizontal lines that represent the error intervals of a data column from the selected Table. This command behaves analogous to Table: Vertical error bars plot where.... 
Table__Horizontal_error_bars_plot_where___	Table: Horizontal error bars plot where... Draws horizontal lines that represent the error intervals of a data column from the selected Table. This command behaves analogous to Table: Vertical error bars plot where.... 
Table__Line_graph_where___	Table: Line graph where... Draws a line graph from the data in a column of the selected Table. In a line plot the horizontal axis can have a nominal scale or a numeric scale. The data point are connected by line segments. Settings Vertical column The column whose data points you want to plot. Vertical range determine the lower and upper limits of the plot. Horizontal column determines the horizontal scale. If you leave it empty, or, if the (selected part of the) selected column contains nominal values, i.e. the values are not numeric but text, the horizontal distance between the data points will be constant (i.e. 1) and the nominal values (texts) will be put as labels at the bottom of the horizontal axis. On the other hand, if this column contains only numerical values, the horizontal position of the data points will be determined by the values in this column. Horizontal range determines the left and right limit of the plot. Text The text to put at the position of the data point in the plot. Label text angle (degrees) determines the angle of the labels written below the plot. If you have very long label texts in the Horizontal column, you can prevent the label texts from overlapping. This only has effect for a horizontal column with nominal values. Formula can be used to supply an expression to select only those rows for plotting where the expression evaluates to true. A 1 value always evaluates to true. Examples The following table was estimated from fig. 3 in Ganong (1980) and represents the fraction /d/ responses as a function of a voice onset time (VOT) continuum. The second column shows the responses in a word - nonword continuum, while the third column shows the responses to a nonword - word continuum. VOT dash-tash dask-task -17.5 0.98 0.92 -7.5 0.95 0.83 -2.5 0.71 0.33 2.5 0.29 0.10 7.5 0.12 0.02 17.5 0.10 0.02 We can reproduce fig. 3 from Ganong (1980) with the following script, where we labeled the word - nonword curve with wn and the nonword - word curve with nw. We deselect Garnish because we want to put special marks at the bottom. Dotted line Line graph where: dash-tash, 0, 1, VOT, -20, 20, wn, 0, 0, 1 Dashed line Line graph where: dask-task, 0, 1, VOT, -20, 20, nw, 0, 0, 1 Draw inner box One mark bottom: 2.5, 0, 1, 0, +2.5 One mark bottom: -2.5, 1, 1, 0, One mark bottom: -7.5,1, 1, 0, One mark bottom: 7.5, 0, 1, 0, +7.5 One mark bottom: 2.5, 0, 0, 0, +2.5 One mark bottom: -20, 0, 0, 0, Short VOT One mark bottom: 20, 0, 0, 0, Long VOT Text bottom: 1, VOT (ms) Marks left every: 1, 0.2, 1, 1, 0 Text left: 1, Prop. of voiced responses As an example of what happens if you don't supply an argument for the Horizontal column we will use the same table as for the previous plot. However the resulting plot may not be as meaningful (note that the horizontal nominal scale makes all points equidistant in the horizontal direction.) Dotted line) Line graph where: dash-tash, 0, 1, , 0, 0, wn, 0, 1, 1 One mark bottom: 1, 0, 1, 0, Short VOT 
Table__Normal_probability_plot___	Table: Normal probability plot... In a normal probability plot, the data in the selected column of the Table are plotted against a normal distribution in such a way that the points should form approximately a straight line. Departures from a straight line indicate departures from normality. Settings Number of quantiles the number of quantile points, n, in the plot. From this number n, the quantile points are determined as follows: the last quantile point is qn = 0.51/n and the first quantile point is q1=1–qn. The intermediate quantile points qi are determined according to qi=(i – 0.3175)/(n + 0.365), where i runs from 2 to n–1. Number of sigmas determines the horizontal and vertical drawing ranges in units of standard deviations. 
Table__Quantile-quantile_plot___	Table: Quantile-quantile plot... In a quantile-quantile plot the quantiles of the data in the first selected column of the Table are plotted against the quantiles of the data in the second selected column. If the two sets come from a population with the same distribution, the points should fall approximately along the reference line. 
Table__Report_one-way_anova___	Table: Report one-way anova... Performs a one-way analysis of variance on the data in one column of a selected Table and reports the fixed-effects anova table results in the info window. Settings Column with data the label of the column who's data will be analyzed. Factor the label of the column with the names of the levels. Table with means if checked, a Table with the mean values of the levels will be created. Table with differences between means if checked, a Table with the differences between the mean values of the levels will be created. Table with Tukey's post-hoc test if checked, a Table with Tukey's HSD tests will be created. Each value in this Table measures the probability that the corresponding difference between the level means happened by chance. The test compares all possible level means and is based on the studentized range distribution. 
Table__Report_one-way_Kruskal-Wallis___	Table: Report one-way Kruskal-Wallis... Performs a one-way Kruskal-Wallis analysis on the data in one column of a selected Table and reports the results in the info window. This test is sometimes refered to as a one-way analysis of variance for non-normally distributed data. Settings Column with data the label of the column who's data will be analyzed. Factor the label of the column with the names of the levels. Algorithm The analysis is done on the ranked data and consists of the following steps: 1. Rank all the N data points together, i.e. rank the data from 1 to N. 2. The test statistic is: K = (12 / (N(N+1)) Σi=1g ni (meanRanki)2 - 3(N+1), where g is the number of levels, ni the number of data in i-th level and meanRanki the average rank of the i-th level. 3. The p value is approximated by the χ2 (K, g - 1) distribution. 
Table__Report_two-way_anova___	Table: Report two-way anova... Performs a two-way analysis of variance on the data in one column of a selected fully factorial Table and reports the fixed-effects anova table in the info window. Settings Column with data the label of the column who's data will be analyzed. First factor the label of the column with the names of the levels for the first factor. Second factor the label of the column with the names of the levels for the second factor. Table with means if checked, a Table with the mean values of all the levels will be created. Example Suppose you want to check if fundamental frequency depends on the type of vowel and speaker type. We will use the Peterson & Barney vowel data set to illustrate this. The following script will first create the data set and then produce the two-way anova report. Create formant table (Peterson & Barney 1952) Report two-way anova: F0, Vowel, Type This will produce the following anova table in the info window: Two-way analysis of F0 by Vowel and Type. Source SS Df MS F P Vowel 73719.4 9 8191.05 7.62537 5.25258e-11 Type 4.18943e+06 2 2.09471e+06 1950.05 0 Vowel x Type 6714.34 18 373.019 0.347258 0.994969 Error 1.60053e+06 1490 1074.18 Total 5.87039e+06 1519 The analysis shows that F0 strongly depends on the vowel and also on the speaker type and, luckily, we do not have any interaction between the vowel and the speaker type. Besides the anova table there is also shown a table with the mean F0 values for each Vowel-Type combination which looks like: c m w Mean aa 258 124 212 198 ae 248 125 208 194 ah 263 129 223 205 ao 259 127 217 201 eh 259 128 220 202 er 264 133 219 205 ih 270 136 232 213 iy 270 136 231 212 uh 273 136 234 214 uw 278 139 235 218 Mean 264 131 223 206 The first column of this table shows the vowel codes while the first row shows the speaker types (child, man, women). The last row and the last column of the table shows the averages for the factors Type and Vowel, respectively. The actual data are unbalanced because we have 300, 660 and 560 replications per column respectively (for each speaker we have two replcations of the data). Algorithm The formula's to handle unbalanced designs come from Khuri (1998). 
Table__Vertical_error_bars_plot___	Table: Vertical error bars plot... Draws vertical lines that represent the error intervals of a data column from the selected Table. For more info see Table: Vertical error bars plot where... 
Table__Vertical_error_bars_plot_where___	Table: Vertical error bars plot where... Draws vertical lines that represent the error intervals of a data column from the selected Table. Settings Horizontal column determines the data along the horizontal axis. Horizontal range determines the lower and upper limits of the plot. Vertical column determines the data along the horizontal axis. Vertical range determines the lower and upper limits of the plot. Lower error value column, Upper error value column determine the size of the vertical lines that will be drawn. These lines are drawn between the points (x,y-low) and (x, y+up), where x and y are the values from the horizontal column and the vertical column, respectively, and, low and up are the corresponding values in the lower error value column and the upper error value column, respectively. If either of these column names is not given the corresponding values (low and/or up) will taken as zero. This makes it possible to draw one-sided and two-sided error bars. If your errors are symmetric around the y-position, your table only needs one column and you can supply the name of this column in both fields. Bar size (mm) determines the width of the horizontal bars or whishers at the lower an postion of the drawn line. Garnish determines whether or not some decoration is drawn. Formula can be used to supply an expression to select only those rows for plotting where the expression evaluates to true. A 1 value always evaluates to true. Links to this page Table: Horizontal error bars plot where... Table: Horizontal error bars plot... Table: Vertical error bars plot... 
TableOfReal	TableOfReal One of the types of objects in Praat. A TableOfReal object contains a number of cells. Each cell belongs to a row and a column. For instance, a TableOfReal with 10 rows and 3 columns has 30 cells. Each row and each column may be labeled with a title. Creating a TableOfReal from data in a text file Suppose you have F1 and F2 data for vowels. You can create a simple text file like the following: ooTextFile ! The line by which Praat can recognize your file TableOfReal ! The line that tells Praat about the contents 2 F1 F2 ! Number of columns, and column labels 3 ! Number of rows a 800 1100 ! Row label (vowel), F1 value, F2 value i 280 2800 ! Row label (vowel), F1 value, F2 value u 260 560 ! Row label (vowel), F1 value, F2 value Praat is rather forgiving about the use of spaces, tabs, and newlines. See Save as text file... for general information. You will often have your data in a file with a self-describing format, i.e. in which the number of values on a line equals the number of columns of the table: 800 1100 280 2800 260 560 Such a file can be read with Read Matrix from raw text file.... This creates a Matrix object, which can be cast to a TableOfReal object by Matrix: To TableOfReal. The resulting TableOfReal does not have any row or column labels yet. You could add column labels with: Set column label (index)... 1 F1 Set column label (index)... 2 F2 Of course, if the row labels contain crucial information, and the number of rows is large, this is not a feasible method. Links to this page Canonical correlation analysis CCA & TableOfReal: To TableOfReal (loadings) CCA & TableOfReal: To TableOfReal (scores)... Confusion: To TableOfReal (marginals) Correlation: Confidence intervals... Covariance & TableOfReal: Extract quantile range... Covariance & TableOfReal: To TableOfReal (mahalanobis)... Covariance: To TableOfReal (random sampling)... Create TableOfReal (Pols 1973)... Create TableOfReal (Van Nierop 1973)... Create TableOfReal (Weenink 1985)... Discriminant & TableOfReal: To ClassificationTable... Discriminant & TableOfReal: To Configuration... Discriminant & TableOfReal: To TableOfReal (mahalanobis)... Dissimilarity Distributions Eigen & TableOfReal: Project... FFNet: Extract weights... Formulas 7. Attributes of objects GaussianMixture & TableOfReal: To ClassificationTable GaussianMixture & TableOfReal: To Correlation (columns) GaussianMixture & TableOfReal: To TableOfReal (BHEP normality tests)... HMM: Extract emission probabilities HMM: Extract transition probabilities KNN & Pattern & FeatureWeights: To TableOfReal... KNN & Pattern: To TabelOfReal... MFCC: To TableOfReal... PCA & Configuration: To TableOfReal (reconstruct) PCA & TableOfReal: Get fraction variance... PCA & TableOfReal: To Configuration... PCA & TableOfReal: To TableOfReal (z-scores)... PCA: To TableOfReal (reconstruct 1)... Principal component analysis SSCP SSCP & TableOfReal: Extract quantile range... T-test TableOfReal & Permutation: Permute rows TableOfReal: Centre columns TableOfReal: Centre rows TableOfReal: Change column labels... TableOfReal: Change row labels... TableOfReal: Draw biplot... TableOfReal: Draw box plots... TableOfReal: Draw rows as histogram... TableOfReal: Get table norm TableOfReal: Normalize columns... TableOfReal: Normalize rows... TableOfReal: Normalize table... TableOfReal: Select columns where row... TableOfReal: Set value... TableOfReal: Standardize columns TableOfReal: To CCA... TableOfReal: To Configuration (lda)... TableOfReal: To Configuration (pca)... TableOfReal: To Correlation TableOfReal: To Correlation (rank) TableOfReal: To Covariance TableOfReal: To Discriminant TableOfReal: To GaussianMixture (row labels)... TableOfReal: To GaussianMixture... TableOfReal: To Pattern and Categories... TableOfReal: To PCA TableOfReal: To SSCP... TableOfReal: To TableOfReal (means by row labels)... What was new in 3.7? 
TableOfReal___Permutation__Permute_rows	TableOfReal & Permutation: Permute rows Generate a new TableOfReal with a row ordering determined by the Permutation. Example If the selected TableOfReal has 5 rows and the permutation is (5,4,3,2,1) the first row of the new TableOfReal equals the fifth row of the selected, the second row of new equals the fourth row of the selected and so on. 
TableOfReal__Centre_columns	TableOfReal: Centre columns A command that centres the columns in the selected TableOfReal objects. Algorithm The new values in the table, x′ij, will be: x′ij = xij – x·j, where x·j = ∑i=1..numberOfRows xij / numberOfRows, the average of column j. 
TableOfReal__Centre_rows	TableOfReal: Centre rows A command that centres the rows in the selected TableOfReal objects. Algorithm The new values in the table, x′ij, will be: x′ij = xij – xi·, where xi· = ∑j=1..numberOfColumns xij / numberOfColumns, the average of row i. 
TableOfReal__Change_column_labels___	TableOfReal: Change column labels... Changes the column labels of the selected TableOfReal object according to the specification in the search and replace fields. Both search and replace fields may contain Regular expressions. The Replace limit parameter limits the number of replaces that may occur within each label. 
TableOfReal__Change_row_labels___	TableOfReal: Change row labels... Changes the row labels of the selected TableOfReal object according to the specification in the search and replace fields. Both search and replace fields may contain Regular expressions. The Replace limit parameter limits the number of replaces that may occur within each label. 
TableOfReal__Draw_biplot___	TableOfReal: Draw biplot... A command to draw a biplot for each column in the selected TableOfReal object. Settings Xmin, Xmax, Ymin, Ymax determine the drawing boundaries. Split factor determines the weighing of the row and column structure (see below). Behaviour 1. Get the singular value decomposition U Σ V′ of the table. 2. Calculate weighing factors λ for row and columns λr,1 = σ1splitFactor λc,1 = σ11-splitFactor λr,2 = σ2splitFactor λc,2 = σ21-splitFactor where σ1 and σ2 are the first and the second singular values 3. For the rows (i from 1..numberOfRows) form: xri = Ui1 λr,1 yri = Ui2 λr,2 4. For the columns (i from 1..numberOfColumns) form: xci = Vi1 λc,1 yci = Vi2 λc,2 5. Plot the points (xri, yri) and (xci, yci) in the same figure with the corresponding row and column labels. 
TableOfReal__Draw_box_plots___	TableOfReal: Draw box plots... A command to draw a box plot for each column in the selected TableOfReal object. Settings From row, To row, From column, To column determine the part of the table that you want to analyse. Ymin and Ymax determine the drawing boundaries. Links to this page What was new in 3.9? 
TableOfReal__Draw_rows_as_histogram___	TableOfReal: Draw rows as histogram... A command to draw a histogram from the rows in the selected TableOfReal object. The histogram will consist of groups of bars. The number of groups will be determined by the number of selected columns from the table, while the number of bars within each group will be determined from the number of selected rows. Settings Row numbers and Column range determine the part of the table that you want to draw. The column range determines the number of bars that you want to draw for each row selected by the Row numbers argument. Ymin and Ymax the drawing boundaries. The following arguments are all relative to the width of a bar in the histogram. Horizontal offset the offset from the left and right margin. Distance between bar groups the distance between each group, i.e., the distance between the right side of the last bar in a group to the left side of the first bar in the next group. Distance between bars the distance between the bars in a group. Grey values the grey values of the bars in a group. Bar positioning If you want to put the labels yourself you will need the following information. The width of a bar is determined as follows: width = 1 / (nc · nr + 2 · hoffset + (nc - 1)· intergroup +nc·(nr -1)· interbar), where nc is the number of columns (groups) to draw, nr is the number of rows to draw (the number of bars within a group), hoffset is the horizontal offset, intergroup the distance between each group and interbar the distance between the bars within a group. The spacing between the bars drawn from a row: dx = (intergroup + nr + (nr -1) · interbar) * width The first bar for the k-th row starts at: x1 = hoffset · width + (k - 1) · (1 + interbar) · width 
TableOfReal__Get_table_norm	TableOfReal: Get table norm A command that returns the norm of the selected TableOfReal object. Algorithm Returns: sqrt (∑i=1..numberOfRows ∑j=1..numberOfColumns xij2). 
TableOfReal__Normalize_columns___	TableOfReal: Normalize columns... A command that normalizes the columns in the selected TableOfReal objects. Setting Norm determines the sum of the squared elements in each column after normalization. Algorithm All elements xij in each column j=1..numberOfColumns will be multiplied by sqrt (norm / ∑i=1..numberOfRows xij2). 
TableOfReal__Normalize_rows___	TableOfReal: Normalize rows... A command that normalizes the rows in the selected TableOfReal objects. Setting Norm determines the sum of the squared elements in each row after normalization. Algorithm All elements xij in each row i=1..numberOfRows will be multiplied by sqrt (norm / ∑j=1..numberOfColumns xij2). 
TableOfReal__Normalize_table___	TableOfReal: Normalize table... A command that normalizes the elements in the selected TableOfReal objects. Setting Norm determines the sum of the squared elements after normalization. Algorithm All elements xij will be multiplied by sqrt (norm / ∑i=1..numberOfRows ∑j=1..numberOfColumns xij2. 
TableOfReal__Report_multivariate_normality__BHEP____	TableOfReal: Report multivariate normality (BHEP)... Report about multivariate normality according to the BHEP multivariate normality test. Settings Smoothing parameter determines the smoothing parameter h. 
TableOfReal__Select_columns_where_row___	TableOfReal: Select columns where row... Copy columns from the selected TableOfReal object to a new TableOfReal object. Settings Columns defines the indices of the columns to be selected. Ranges can be defined with a colon :. Columns will be selected in the specified order. Row condition specifies a condition for the selection of rows. If the condition evaluates as true for a particular row, the selected elements in this row will be copied. See Matrix: Formula... for the kind of expressions that can be used here. Examples Select columns where row: 1 2 3, 1 Select columns where row: 1 : 3, 1 Two alternative expressions to copy the first three columns to a new table with the same number of rows. Select columns where row: 3 : 1, 1 Copy the first three columns to a new table with the same number of rows. The new table will have the 3 columns reversed. Select columns where row: 1:6 9:11, self[row,8]>0 Copy the first six columns and columns 9, 10, and 11 to a new table. Copy only elements from rows where the element in column 8 is greater than zero. 
TableOfReal__Set_value___	TableOfReal: Set value... A command to change the value of one table cell in each selected TableOfReal object. Settings Row number the number of the row of the cell whose value you want to change. Column number the number of the column of the cell whose value you want to change. New value the value that you want the specified cell to have. Links to this page Multidimensional scaling 
TableOfReal__Standardize_columns	TableOfReal: Standardize columns Standardizes each column of the selected TableOfReal. The entries xij in the TableOfReal will change to: (xij – μj) / σj, where μj and σj are the mean and the standard deviation as calculated from the jth column, respectively. After standardization all column means will equal zero and all column standard deviations will equal one. Links to this page Principal component analysis 
TableOfReal__To_CCA___	TableOfReal: To CCA... A command that creates a CCA object from the selected TableOfReal object. Settings Dimension of dependent variate (ny) defines the partition of the table into the two parts whose correlations will be determined. The first ny columns must be the dependent part, the rest of the columns will be interpreted as the independent part (nx columns). In general nx must be larger than or equal to ny. Behaviour Calculates canonical correlations between the dependent and the independent parts of the table. The corresponding canonical coefficients are also determined. Algorithm The canonical correlation equations for two data sets Ty [n × p] and Tx [n × q] are: (1) (Syx Sxx-1 Syx′ -λ Syy)y = 0 (2) (Syx′ Syy-1 Syx -λ Sxx)x = 0 where Syy [p × p] and Sxx [q × q] are the covariance matrices of data sets Ty and Tx, respectively, Syx [p × q] is the matrix of covariances between data sets Ty and Tx, and the vectors y and x are the canonical weights or the canonical function coefficients for the dependent and the independent data, respectively. In terms of the (dependent) data set Ty and the (independent) data set Tx, these covariances can be written as: Syy = Ty′ Ty, Syx = Ty′ Tx and Sxx = Tx′ Tx. The following singular value decompositions Ty = Uy Dy Vy′ and Tx = Ux Dx Vx′ transform equation (1) above into: (3) (Vy Dy Uy′Ux Ux′ Uy Dy Vy′ - λ Vy Dy Dy Vy′)y = 0 where we used the fact that: Sxx-1 = Vx Dx-2 Vx′. Equation (3) can be simplified by multiplication from the left by Dy-1 Vy' to: (4) ((Ux′ Uy)′ (Ux′ Uy) - λ I)Dy Vy′ y = 0 This equation can, finally, be solved by a substitution of the s.v.d of Ux′ Uy = U D V′ into (4). This results in (5) (D2 - λ I) V′ Dy Vy′ y = 0 In an analogous way we can reduce eigenequation (2) to: (6) (D2 - λ I) U′ Dx Vx′ x = 0 From (5) and (6) we deduce that the eigenvalues in both equations are equal to the squared singular values of the product matrix Ux′Uy. These singular values are also called canonical correlation coefficients. The eigenvectors y and x can be obtained from the columns of the following matrices Y and X: Y = Vy Dy-1 V X = Vx Dx-1 U For example, when the vector y equals the first column of Y and the vector x equals the first column of X, then the vectors u = Tyy and v = Txx are the linear combinations from Ty and Tx that have maximum correlation. Their correlation coefficient equals the first canonical correlation coefficient. Links to this page Canonical correlation analysis canonical variate SSCP: To CCA... 
TableOfReal__To_Configuration__lda____	TableOfReal: To Configuration (lda)... Calculates a Configuration based on the Discriminant scores obtained from the selected TableOfReal. Row labels in the table indicate group membership. Setting Number of dimensions determines the number of dimensions of the resulting Configuration. Algorithm First we calculate the Discriminant from the data in the TableOfReal. See TableOfReal: To Discriminant for details. The eigenvectors of the Discriminant determine the directions that the data in the TableOfReal will be projected unto. Links to this page Discriminant analysis 
TableOfReal__To_Configuration__pca____	TableOfReal: To Configuration (pca)... Calculates a Configuration based on the principal components from the selected TableOfReal. Setting Number of dimensions determines the number of dimensions of the resulting Configuration. Algorithm We form principal components without explicitly calculating the covariance matrix C = M′·M, where M is the matrix part of the TableOfReal. 1. Make the singular value decomposition of M. This results in M = U·d·V′. 2. Sort singular values d and corresponding row vectors in V (descending). 3. The principalComponentij = ∑k=1..numberOfColumns Mik · Vjk. Remark The resulting configuration is unique up to reflections along the new principal directions. Links to this page Principal component analysis 
TableOfReal__To_Correlation	TableOfReal: To Correlation A command that creates a (Pearson) Correlation object from every selected TableOfReal object. The correlations are calculated between columns. Algorithm The linear correlation coefficient rij (also called the product moment correlation coefficient or Pearson's correlation coefficient) between the elements of columns i and j is calculated as: rij = Σk (xki - meani)(xkj - meanj)/(√ (Σk(xki - meani)2) √ (Σk(xkj - meanj)2)), where xmn is the element m in column n, and meann is the mean of column n. 
TableOfReal__To_Correlation__rank_	TableOfReal: To Correlation (rank) A command that creates a (Spearman rank-order) Correlation object from every selected TableOfReal object. The correlations are calculated between columns. Algorithm The Spearman rank-order correlation coefficient rij between the elements of columns i and j is calculated as the linear correlation of the ranks: rij = Σk (Rki - Rmeani) (Rkj - Rmeanj) / (√ (Σk(Rki - Rmeani)2) √ (Σk(Rkj - Rmeanj)2)), where Rmn is the rank of element m in column n, and Rmeann is the mean of the ranks in column n. 
TableOfReal__To_Covariance	TableOfReal: To Covariance A command that creates a Covariance object from every selected TableOfReal object. The covariances are calculated between columns. Algorithm The covariance coefficients sij between the elements of columns i and j are defined as: sij = Σk (xki - meani)(xkj - meanj)/(numberOfObservations - numberOfConstraints), where xki is the element k in column i, meani is the mean of column i, numberOfObservations equals the number of rows in the table, and numberOfConstraints equals 1. The actual calculation goes as follows 1. Centralize each column (subtract the mean). 2. Get its singular value decomposition U Σ V′. 3. Form S = V Σ V′. 4. Divide all elements in S by (numberOfObservations - 1). Links to this page PCA & TableOfReal: Get fraction variance... T-test 
TableOfReal__To_Discriminant	TableOfReal: To Discriminant A command that creates a Discriminant object from every selected TableOfReal object. Row labels in the table indicate group membership. Algorithm We solve for directions x that are eigenvectors of the generalized eigenvalue equation: B x - λ W x = 0, where B and W are the between-groups and the within-groups sums of squares and cross-products matrices, respectively. Both B and W are symmetric matrices. Standard formula show that both matrices can also be written as a matrix product. The formula above then transforms to: B1′B1 x - λ W1′W1 x = 0 The equation can be solved with the generalized singular value decomposition. This procedure is numerically very stable and can even cope with cases when both matrices are singular. The a priori probabilities in the Discriminant will be calculated from the number of training vectors ni in each group: aprioriProbabilityi = ni / Σk=1..numberOfGroups nk Links to this page Discriminant analysis TableOfReal: To Configuration (lda)... 
TableOfReal__To_GaussianMixture___	TableOfReal: To GaussianMixture... Creates a GaussianMixture from the selected TableOfReal by an expectation-maximization procedure. Settings Number of components defines the number of Gaussians in the mixture. Tolerance of minimizer defines when to stop optimizing. If the relative difference between the likelihoods at two successive iteration steps differs by less then the tolerance we stop, i.e. when |(L(i-1)-L(i))/L(i)| < tolerance. Maximum number of iterations defines another stopping criterion. The EM iteration will stop when either the tolerance is reached or the maximum number of iterations. If zero is chosen, no iteration will be performed and the GaussianMixture will be initialized with the initial guess. Stability coefficient lambda defines the fraction of the total covariance that will be added to the each of the mixture covariance matrices during the EM iteration. This may prevent one or more of these matrices to become singular. Covariance matrices are defines whether the complete covariance matrices in the mixture have to be calculated or only the diagonal. Expectation–Maximization Algorithm The Expectation–Maximization (EM) algorithm is an iterative procedure to maximize the likelihood of the data given a model. For a GaussianMixture, the parameters in the model are the centers and the covariances of all components in the mixture and their mixing probabilities. The number of parameters depends on the number of components in the mixture and the dimension of the data. For a full covariance matrix we have to find dimension(dimension+1)/2 matrix elements and another dimension vector elements for its center. This makes the total number of parameters that have to be estimated for a mixture with Number of components components equal to numberOfComponents · dimension(dimension+3)/2 + numberOfComponents. For diagonal covariance matrices the number of parameters reduces considerably. The EM iteration has to start with a sensible initial guess for all the parameters. For the initial guess, we derive our centers from positions on the 1-σ ellipse in the plane spanned by the first two principal components. We then make all covariance matrices equal to a scaled down version of the total covariance matrix where the scaling factor depends on the number of components and the quotient of the between and within variance. Initialy all mixing probabilities will be chosen equal. How to proceed from the initial guess with the EM to find the optimal values for all the parameters in the Gaussian mixture is explained in great detail by Bishop (2006). Links to this page GaussianMixture & TableOfReal: Improve likelihood... 
TableOfReal__To_GaussianMixture__row_labels____	TableOfReal: To GaussianMixture (row labels)... Creates a GaussianMixture from the selected TableOfReal. The number of mixture components is determined by the number of different row labels. Setting Covariance matrices are defines whether the complete covariance matrices in the mixture have to be calculated or only the diagonal. 
TableOfReal__To_Pattern_and_Categories___	TableOfReal: To Pattern and Categories... Extracts a Pattern and a Categories from the selected TableOfReal. The selected rows and columns are copied into the Pattern and the corresponding row labels are copied into a Categories. 
TableOfReal__To_PCA	TableOfReal: To PCA A command that creates a PCA object from every selected TableOfReal object. Links to this page Principal component analysis 
TableOfReal__To_SSCP___	TableOfReal: To SSCP... Calculates Sums of Squares and Cross Products (SSCP) from the selected TableOfReal. Algorithm The sums of squares and cross products sij between the elements of columns i and j are calculated as: sij = Σk (xki - meani)(xkj - meanj), where xmn is the element m in column n and meann is the mean of column n. 
TableOfReal__To_TableOfReal__means_by_row_labels____	TableOfReal: To TableOfReal (means by row labels)... A command that appears in the Multivariate statistics menu if you select a TableOfReal. It calculates the multivariate means for the different row labels from the selected TableOfReal. Setting Expand when off, then for a table with n rows and m different labels (m≤n), the resulting table will have m rows. When on, the dimensions of the resulting table will be the same as the originating, and corresponding means substituded in each row. Example The following commands Create TableOfReal (Pols 1973): no To TableOfReal (means by row labels): 0 will result in a new TableOfReal that has 12 rows. Each row will contain the mean F1, F2 and F3 values for a particular vowel. These means were obtained from 50 representations of that vowel. If we had chosen the expansion: To TableOfReal (means by row labels): yes the resulting TableOfReal would have had 600 rows. This representation comes in handy when, for example, you have to calculate deviations from the mean. 
Takane__Young___de_Leeuw__1976_	Takane, Young & de Leeuw (1976) Y. Takane, F. Young, J. de Leeuw (1976): Non-metric individual differences multidimensional scaling: an alternating least squares method with optimal scaling features. Psychometrika 42: 7–67. Links to this page individual difference scaling 
Technical	Technical The title of a submenu of the Praat menu. 
Ten_Berge__1995_	Ten Berge (1995) J.M.F. ten Berge (1995): Suppressing permutations or rigid planar rotations: a remedy against nonoptimal varimax rotations. Psychometrika 60, 437–446. Links to this page Configuration: To Configuration (varimax)... 
Ten_Berge__Kiers___Krijnen__1993_	Ten Berge, Kiers & Krijnen (1993) J.M.F. ten Berge, H.A.L. Kiers & W.P. Krijnen (1993): Computational solutions for the problem of negative saliences and nonsymmetry in INDSCAL. Journal of Classification 10: 115–124. Links to this page INDSCAL analysis 
Tenreiro__2009_	Tenreiro (2009) C. Tenreiro (2009): On the choice of the smoothing parameter for the BHEP goodness-of-fit test. Computational Statistics and Data Analysis 53: 1038–1053. Links to this page BHEP multivariate normality test 
Tesar___Smolensky__1998_	Tesar & Smolensky (1998) Bruce Tesar & Paul Smolensky (1998): Learnability in Optimality Theory. Linguistic Inquiry 29: 229–268. The first version of the constraint-demotion algorithm appeared in: Bruce Tesar & Paul Smolensky (1993): The learnability of Optimality Theory: an algorithm and some basic complexity results. Manuscript Department of Computer Science & Institute of Cognitive Science, University of Colorado at Boulder. Available as Rutgers Optimality Archive 2, http://ruccs.rutgers.edu/roa.html The Error-Driven Constraint Demotion algorithm (EDCD) can be found in: Bruce Tesar & Paul Smolensky (1996): Learnability in Optimality Theory (long version). Technical Report 96-3, Department of Cognitive Science, Johns Hopkins University, Baltimore. Available as Rutgers Optimality Archive 156, http://ruccs.rutgers.edu/roa.html A corrected version of EDCD appeared in Boersma (2009b). Links to this page OT learning 1. Kinds of grammars OT learning 4. Learning an ordinal grammar OT learning 6. Shortcut to grammar learning OT learning 7. Learning from overt forms Robust Interpretive Parsing 
Text___	Text... One of the commands in the World menu of the Picture window. Purpose To write text inside the drawing area. Scope This works with all the drawings that leave margins around themselves. Settings x horizontal position, expressed in the horizontal domain of your latest drawing. y vertical position, expressed in the vertical range or domain of your latest drawing. Horizontal alignment determines the horizontal alignment of the text relative to x. Vertical alignment determines the vertical alignment of the text relative to y. Text will be drawn in the current font and font size that you set with the Font menu. Usage With the Text... command, you can use all special symbols and text styles. 
Text_left_right_top_bottom___	Text left/right/top/bottom... Four of the commands in the Margins menu of the Picture window. Purpose To write text into the margins around the drawing area. Behaviour The text will be centred along the side. Text at the left or right will be turned by 90 degrees and written up and down, respectively. 
Text_styles	Text styles When drawing text into the Picture window or into an editor, you can use text styles other than regular Roman. Italic, bold, superscript, subscript With the following symbols, you introduce stretches of text drawn in special styles: %: the following letter will be italic. #: the following letter will be bold. #%: the following letter will be bold-italic. ^: the following letter will be superscript: %m%c^2 gives mc2. _: the following letter will be subscript. Example: F0 is typed as %F_0. %%: the following letters will be italic, until the following %: Now %%you% try gives: Now you try. The same goes for ##, ^^, and __. \s{...}: small: W\s{ARP} gives: WARP To draw a %, #, ^, or _ symbol, you type \% , \# , \^ , or \_ : a backslash, the symbol, and a space. On Xwindows machines, the font `Symbol' will never look bold or italic, but it will be printed correctly. See also Special symbols Links to this page Font menu ManPages OT learning 2.2. Inside the grammar Text... Viewport text... What was new in 3.6? 
TextGrid	TextGrid One of the types of objects in Praat, used for annotation (segmentation and labelling). For tutorial information, see Intro 7. Annotation. Description A TextGrid object consists of a number of tiers. There are two kinds of tiers: an interval tier is a connected sequence of labelled intervals, with boundaries in between. A point tier is a sequence of labelled points. How to create a TextGrid From scratch: Sound: To TextGrid... (takes the time domain from the Sound) LongSound: To TextGrid... (takes the time domain from the LongSound) PointProcess: To TextGrid... (takes the time domain from the PointProcess) PointProcess: To TextGrid (vuv)... (labels voiced and unvoiced intervals) Create TextGrid... From merging existing TextGrids with each other: TextGrids: Merge How to edit a TextGrid You select a TextGrid alone or together with a Sound or LongSound, and click View & Edit. A TextGridEditor will appear on your screen, containing the TextGrid and an optional copy of the Sound or LongSound. How to draw a TextGrid You can draw a TextGrid to the Picture window with: TextGrid: Draw... TextGrid & Sound: Draw... TextGrid & Pitch: Draw... TextGrid & Pitch: Draw separately... Links to this page DTW & TextGrid: To TextGrid (warp times) Intensity: To TextGrid (silences)... PointProcess: Up to TextGrid... Sound: To TextGrid (silences)... SpellingChecker TextGrid: Count labels... TextGrid: Extend time... time domain 
TextGrid__Count_labels___	TextGrid: Count labels... A command to ask the selected TextGrid object how many of the specified labels it contains in the specified tier. Settings Tier number the number (1, 2, 3...) of the tier whose labels you want to investigate. Label text the text on the labels that you want to count. Behaviour The number of intervals or points with label Label text in tier Tier number is written into the Info window. If the specified tier does not exist, the number will be 0. Scripting You can use this command to put the number into a script variable: selectObject: TextGrid hallo number_of_a = Count labels: 1, a In this case, the value will not be written into the Info window. Links to this page What was new in 3.7? 
TextGrid__Extend_time___	TextGrid: Extend time... Extends the domain of the selected TextGrid object. Settings Extend domain by defines the amount of time by which the domain will be extended. At defines whether starting times or finishing times will be modified. Behaviour We add an extra (empty) interval into each interval tier. This is necessary to keep original intervals intact. According to the value of the second argument, the new interval will be added at the beginning or at the end of the tier. For point tiers only the domain will be changed. 
TextGridEditor	TextGridEditor One of the Editors in Praat, for editing a TextGrid object. You can optionally include a copy of a Sound or LongSound in this editor, by selecting both the TextGrid and the Sound or LongSound before clicking View & Edit. The Sound or LongSound is shown in the upper part of the window, the tiers in the lower part. A text window at the top shows the text of the selected interval or point, i.e. the interval or point at the location of the cursor. All tiers are visible, and if you do not zoom in, all boundaries, points, and texts are visible, too. You can do many of the same things that you can do with a SoundEditor or LongSoundEditor. Positioning the cursor or the selection marks To position the cursor hair, click in the Sound, on a boundary, on a point, or inside an interval. To select any part of the time domain, use the time selection mechanism; if you do this by clicking in a tier, the selected time domain will snap to the nearest boundary or point. Creating new intervals, boundaries, points, or tiers To create a new interval, create a new boundary in an interval tier. To create a new boundary or point in a tier, click inside the cursor circle in that tier, or choose one of the commands in the Boundary/Point menu to insert a boundary at the cursor time on the selected tier (shortcut: Enter) or on any tier (shortcuts: Command-F1 through Command-F9). The original text in the interval that is split, is divided up between the two resulting intervals, depending on the position of the text cursor in the text window. To create a new tier, choose Add interval tier or Add point tier from the Tier menu. Playing an entire interval, or part of it As in many other editors, you can play a stretch of sound by clicking in any of the rectangles around the drawing area. To play an interval of an interval tier, you first click inside it. This will make the interval selected, which means that the visible part of the interval will be drawn in yellow. The cursor will be positioned at the start of the interval, and the time selection will comprise exactly the interval. This means that you can use the Tab key to play the interval. If you press it while a sound is playing, the Tab key will halt the playing sound, and the cursor will move to the time at which the sound stopped playing. This helps you to divide up a long sentence into parts that you can remember long enough to write them down. The Tab key will play the selected interval. Editing the text in an interval or at a point To edit the label text of an interval or point: 1. Select that interval or point by clicking in or on it. The text currently in the interval or point will appear in the text window. 2. Just type the text, and use the mouse and the arrow keys to navigate the text window. Everything you type will become visible immediately in the text window as well as in the selected interval or point. You can use all the Special symbols that you can use elsewhere in Praat, including mathematical symbols, Greek and Chinese letters, superscripts, and phonetic symbols. Selecting a tier To select a tier, click anywhere inside it. Its number and name will be drawn in red, and a pointing finger symbol (☞) will appear on its left. Selecting a boundary or point To select a boundary on an interval tier, click in its vicinity or inside the following interval; the boundary will be drawn in red. The text in the interval will appear in the text window. To select a point on a point tier, click in its vicinity; it will be drawn in red. The text of the point will appear in the text window. Moving one or more boundaries or points To move a boundary or point to another time position, drag it with the mouse. To move all the boundaries and points with the same time (on different tiers) to another time position, Shift-drag them. To move boundaries or points to the exact time position of a boundary or point on an other tier, drag them into that other tier and into the vicinity of that boundary or point. To move boundaries or points to the exact time position of the cursor, drag them into the vicinity of the cursor. Removing a boundary, point, or tier To remove a selected boundary, choose Remove from the Boundary menu. This creates a new interval which is the union of the two intervals originally adjoining the boundary; the new text of this interval is the concatenation of the two original texts, except if these were equal, in which case the new text equals both original texts. To remove a selected point, choose Remove from the Point menu. To remove a selected tier, choose Remove entire tier from the Tier menu. Extracting a part of the sound To copy the selected part of the Sound or LongSound as a Sound to the List of Objects, choose Extract sound selection from the File menu. You can specify whether you want the time domain of the resulting Sound to match the starting and finishing times of the selection or whether you want the time domain of the resulting Sound to start at zero seconds. If you are viewing a LongSound, you can save the selected part of it to a 16-bit sound file (AIFF, AIFC, WAV, NeXT/Sun, NIST) with a command from the File menu. Accelerations To save the TextGrid object as a text file without going to the Object window: choose Save TextGrid as text file... from the File menu. Searching The Search menu contains the command Find (Command-F), which will allow you to specify a text whose first occurrence will then be looked for in the currently selected tier (starting from the currently selected text in the currently selected interval). The command Find again (Command-G) will search for the next occurrence of the same search text. Checking the spelling You can check the spelling of the intervals in your tiers by including a SpellingChecker object as you launch the editor: select TextGrid + (Long)Sound + SpellingChecker, then click View & Edit. The Spell menu will contain the commands Check spelling in tier (Command-N), and Check spelling in interval which will search for the next word in the tier or interval that does not occur in the lexicon. Links to this page Advanced pitch settings... Advanced pulses settings... Extract visible formant contour Extract visible intensity contour Extract visible pitch contour Extract visible spectrogram Get first formant Get pitch Get second formant Intro 3.6. Viewing a spectral slice Intro 4.3. Querying the pitch contour Intro 4.5. The Pitch object Intro 5.3. Querying the formant contours Intro 5.4. The Formant object Intro 6.1. Viewing an intensity contour Intro 7. Annotation Log files Phonetic symbols Phonetic symbols: consonants Phonetic symbols: diacritics Phonetic symbols: vowels Pitch settings... Play Show formant Show intensity Show pitch Show pulses Show spectrogram Spectrogram settings... Time step settings... Types of objects 
TextGrids__Merge	TextGrids: Merge A command to merge all selected TextGrid objects into a new TextGrid. 
Theil__1950_	Theil (1950) H. Theil (1950): A rank-invariant method of linear and polynomial regression analysis, Proceedings of Koninklijke Nederlandse Akademie van Wetenschappen A.53: 1397–1412. Links to this page theil regression 
theil_regression	theil regression a robust linear regression method, first proposed by Theil (1950). The slope of the regression line is estimated as the median of all pairwise slopes between each pair of points in the data set. Because this number of pairs increases quadratically with the number of data points, we have implemented a somewhat less computationally intensive procedure, the incomplete theil regression. In the incomplete method we first split the data set of N data points (xi, yi), i = 1..N, in two equal sets of size N/2 and then calculate N/2 slopes as mi = (yN/2+i - yi) / (xN/2+i - xi), for i = 1..N/2. The regression slope m is calculated as the median of these N/2 values mi. Given the slope m, the offset b is calculated as the median of the N values bi= yi - m·xi. The theil regression has a breakdown point of 29.3%, which means that it can tolerate arbitrary corruption of up to 29.3 of the input data-points without degradation of its accuracy Links to this page PowerCepstrum: Get peak prominence... 
time	time In normal life, time is how late the watch says it is. In Praat, this definition is largely irrelevant. Sound files rarely tell us the absolute time of recording. So when you read a sound file into Praat and click View & Edit, you will see that the Sound starts at a time of 0 seconds, and if its duration is 3.5 seconds, you will see that the Sound finishes at a time of 3.5 seconds. Besides sounds, many other types of objects in Praat have a time scale as well: spectrograms, pitch contours, formant contours, point processes, and so on. None of these are required to have a time domain that starts at 0 seconds. In the Sound editor window, for example, you can select the part that runs from 1.4. to 1.7 seconds, and extract it to the Objects window while preserving the times. The resulting Sound object will have a start time of 1.4 seconds and an end time of 1.7 seconds, as you can see when you click View & Edit. Spectrograms and pitch contours that you create from this sound will also have a time domain from 1.4 to 1.7 seconds. This time domain is preserved if you save these objects to a text file or to a binary file and read them into Praat again later. Only if you save the Sound object to an audio file (WAV, AIFF), the time information is not preserved in that file; if you read such an audio file into Praat again, the time domain of the new Sound object will run from 0 to 0.3 seconds. In order to prevent confusion, Praat always requires times to be expressed in seconds. So if you want to supply a window length of 5 milliseconds (5 ms), you fill in 0.005 or 5e-3. For 83.2 microseconds (83.2 μs), you say 0.0000832, or better 83.2e-6 or 8.32e-5. On a clock, time runs around in circles. In Praat's editor windows, time runs from left to right. You can often see only a part of the time scale in the window. To see another part, you scroll backward or forward. Links to this page Intro 3.1. Viewing a spectrogram spectro-temporal representation 
time_domain	time domain This manual page assumes that you have read the Intro. Many objects in Praat are functions of time. Examples are: Sound, Pitch, Spectrogram, Formant, Intensity, TextGrid, PitchTier, DurationTier, Harmonicity, PointProcess. In Praat, these functions have a contiguous time domain, i.e. a single time stretch with a start time and an end time. The total duration of such a function is the difference between the start time and the end time. There are up to five ways to see the time domain of an object. The time domain in editor windows If you select an object that is a function of time and click View & Edit, an editor window will appear on the screen. The rectangle at the bottom will show the start time, the end time, and the total duration. The time domain in the picture window If you select an object that is a function of time and choose one of the Draw commands, the window that pops up will invite you to supply a time range. If you keep this time range at its standard setting (from 0.0 to 0.0 seconds), Praat will draw the object for the whole time domain and print the start time and the end time below the horizontal axis (if Garnish is on): The time domain in the Info window If you select an object that is a function of time and click Info, the Info window will tell you the start time, the end time, and the total duration (among other properties of the object). Time domain query commands If you select an object that is a function of time, the following three commands will become available in the Query menu: Get start time Get end time Get total duration If you choose one of these commands, the Info window will tell you the result, expressed in seconds. These commands are most useful in a Praat script. Example: selectObject: Pitch hello startTime = Get start time endTime = Get end time centreTime = (startTime + endTime) / 2 writeInfoLine: This Pitch runs from , startTime, to , endTime, seconds, appendInfoLine: and the centre of its time domain is at , centreTime, seconds. Details for hackers If you select an object that is a function of time and you click Inspect, you can see how the time domain information is stored in the object: the start time is the object's xmin attribute and the end time is its xmax attribute. The total duration is not stored in the object, because it can easily be computed as xmax minus xmin. Links to this page Create FormantGrid... Sound: To Spectrum... 
time_selection	time selection The ways to select a part of the time domain in some editors in Praat, namely those that contain a function of time. The time selection is used for selecting the time interval that will be played, copied, cut, modified, or questioned: 1. How to make a selection The easiest way is to drag the mouse across the part that you want to select. This is analogous to how selection works in a text processor. 2. How to extend or shrink a selection The easiest way is to click with the Shift key pressed. The nearest edge of the selection will move to the time position where you clicked. This is analogous to how extending a selection works in a text processor. For instance, if the currently selected time interval runs from 2 to 5 seconds, and you shift-click at a time position of 4 seconds, the end of the selection will move from 5 to 4 seconds, thus shrinking the selection. You can also shift-drag, i.e. hold the Shift key and the mouse button down while moving the mouse. 3. Other tricks To select a specific time stretch or collapse the selection to its start or end, use the Select menu. Links to this page Frequency selection Intro 3.6. Viewing a spectral slice Intro 6.2. Configuring the intensity contour ManipulationEditor PitchEditor PitchTierEditor PointEditor SoundEditor TextGridEditor 
Time_step_settings___	Time step settings... A command in the View menu of the SoundEditor and TextGridEditor to determine the time interval between consecutive measurements of pitch, formants, and intensity. Automatic time steps It is recommended that you set the Time step strategy to Automatic. In this way, Praat computes just enough pitch, formant, and intensity values to draw reliable pitch, formant, and intensity contours. In general, Praat will compute 4 values within an analysis window (four times oversampling). As described in Sound: To Pitch..., Praat's standard time step for pitch analysis is 0.75 divided by the pitch floor, e.g., if the pitch floor is 75 Hz, the time step will be 0.01 seconds. In this way, there will be 4 pitch measurements within an analysis window, which is 3 / (75 Hz) = 40 milliseconds long. As described in Sound: To Formant (burg)..., Praat's standard time step for formant measurements is the Window length divided by 4, e.g. if the window length is 0.025 seconds, the time step will be 6.25 milliseconds. As described in Sound: To Intensity..., Praat's standard time step for intensity measurements is 0.8 divided by the pitch floor, e.g. if the pitch floor is 75 Hz, the time step will be 10.6666667 milliseconds. In this way, there will be 4 intensity measurements within an intensity analysis window, which is 3.2 / (75 Hz) = 42.6666667 milliseconds long. Fixed time step You can override the automatic time step by setting the Time step strategy to Fixed. The Fixed time step setting then determines the time step that Praat will use: if you set it to 0.001 seconds, Praat will compute pitch, formant, and intensity values for every millisecond. Beware that this can slow down the editor window appreciably, because this step is much smaller than usual values of the automatic time step (see above). Enlarging the time step to e.g. 0.1 seconds will speed up the editor window but may render the pitch, formant, and intensity curves less exact (they become undersampled), which will influence your measurements and the locations of the pulses. If there are fewer than 2.0 pitch measurement points per analysis window, Praat will draw the pitch curve as separate little blue disks rather than as a continuous blue curve, in order to warn you of the undersampling. E.g. if the pitch floor is 75 Hz, Praat will draw the pitch curve as disks if the time step is greater than 0.02 seconds. View-dependent time step Another way to override the standard time step is by setting the Time step strategy to View-dependent. The Number of time steps per view setting then determines the time step that Praat will use: if you set it to 100, Praat will always compute 100 pitch, formant, and intensity values within the view window. More precisely: if you zoom the view window to 3 seconds, Praat will show you 100 pitch, formant, and intensity points at distances of 0.03 seconds (or fewer than 100, if you are near the left or right edge of the signal). As with the Fixed time step setting, Praat will draw the pitch as separate disks in case of undersampling. You may want to use this setting if you want the pitch curve to be drawn equally fast independently of the degree of zooming. Links to this page What was new in 4.2? 
TIMIT_acoustic-phonetic_speech_corpus	TIMIT acoustic-phonetic speech corpus A large American-English speech corpus that resulted from the joint efforts of several American research sites. The TIMIT corpus contains a total of 6300 sentences, 10 sentences spoken by 630 speakers selected from 8 major dialect regions of the USA. 70% of the speakers are male, 30% are female. The text corpus design was done by the Massachusetts Institute of Technology (MIT), Stanford Research Institute and Texas Instruments (TI). The speech was recorded at TI, transcribed at MIT, and has been maintained, verified and prepared for CDROM production by the American National Institute of Standards and Technology (NIST) (Lamel et al. (1986)). 
Torgerson__1958_	Torgerson (1958) W.S. Torgerson (1958): Theory and methods of scaling. New York: Wiley. 
total_duration	total duration - the extent of the time domain (see there). 
Tribolet_et_al___1979_	Tribolet et al. (1979) J.M. Tribolet & T.F. Quatieri (1979): Computation of the Complex Cepstrum. In Programs for Digital Signal Processing, Digital Signal Processing Committee (eds.), IEEE Press. 
Tukey__1977_	Tukey (1977) J.W. Tukey (1977): Exploratory data analysis. Reading, MA: Addison-Wesley. Links to this page box plot 
Types_of_objects	Types of objects Praat contains the following types of objects and Editors. For an introduction and tutorials, see Intro. General purpose: • Matrix: a sampled real-valued function of two variables • Polygon • PointProcess: a point process (PointEditor) • Sound: a sampled continuous process (SoundEditor, SoundRecorder, Sound files) • LongSound: a file-based version of a sound (LongSoundEditor) • Strings • Distributions, PairDistribution • Table, TableOfReal • Permutation • ParamCurve Periodicity analysis: • Tutorials: • Intro 4. Pitch analysis • Intro 6. Intensity analysis • Voice (jitter, shimmer, noise) • Pitch: articulatory fundamental frequency, acoustic periodicity, or perceptual pitch (PitchEditor) • Harmonicity: degree of periodicity • Intensity, IntensityTier: intensity contour Spectral analysis: • Tutorials: • Intro 3. Spectral analysis • Intro 5. Formant analysis • Spectrum: complex-valued equally spaced frequency spectrum (SpectrumEditor) • Ltas: long-term average spectrum • Spectro-temporal: Spectrogram, BarkFilter, MelFilter, FormantFilter • Formant: acoustic formant contours • LPC: coefficients of Linear Predictive Coding, as a function of time • Cepstrum, CC, LFCC, MFCC (cepstral coefficients) • Excitation: excitation pattern of basilar membrane • Excitations: an ensemble of Excitation objects • Cochleagram: excitation pattern as a function of time Labelling and segmentation (see Intro 7. Annotation): • TextGrid (TextGridEditor) Listening experiments: • ExperimentMFC Manipulation of sound: • Tutorials: • Intro 8.1. Manipulation of pitch • Intro 8.2. Manipulation of duration • Intro 8.3. Manipulation of intensity • Filtering • Source-filter synthesis • PitchTier (PitchTierEditor) • Manipulation (ManipulationEditor): overlap-add • DurationTier • FormantGrid Articulatory synthesis (see the Articulatory synthesis tutorial): • Speaker: speaker characteristics of a woman, a man, or a child • Articulation: snapshot of articulatory specifications (muscle activities) • Artword: articulatory target specifications as functions of time • (VocalTract: area function) Neural net package: • FFNet: feed-forward neural net • Pattern • Categories: for classification (CategoriesEditor) Numerical and statistical analysis: • Eigen: eigenvectors and eigenvalues • Polynomial, Roots, ChebyshevSeries, LegendreSeries, ISpline, MSpline • Covariance: covariance matrix • Confusion: confusion matrix • Discriminant analysis: Discriminant • Principal component analysis: PCA • Correlation, ClassificationTable, SSCP • DTW: dynamic time warping Multidimensional scaling: • Configuration (Salience) • Kruskal analysis: Dissimilarity (Weight), Similarity • INDSCAL analysis: Distance, ScalarProduct • Correspondence analysis: ContingencyTable Optimality-theoretic learning (see the OT learning tutorial) • OTGrammar (OTGrammarEditor) Bureaucracy • WordList, SpellingChecker Links to this page AffineTransform AmplitudeTier CCA EditCostsTable EditDistanceTable FeatureWeights Index KNN PowerCepstrogram PowerCepstrum Procrustes Proximity SpeechSynthesizer VocalTractTier 
undefined	undefined When you give a query command for a numeric value, Praat sometimes writes the numeric value --undefined-- into the Info window (two hyphens at both sides of the word). This happens if the value you ask for is not defined, as in the following examples: You select a Sound with a finishing time of 1.0 seconds and ask for the minimum point in the wave form between 1.5 and 2.0 seconds (with the query command Get minimum...). You ask for a pitch value in a voiceless part of the sound (select a Pitch, then choose Get value at time...). You type into the Calculator the following formula: 10^400. Usage in a script In a Praat script, this value is simply represented as undefined. You use it to test whether a query command returned a valid number: selectObject: Pitch hallo meanPitch = Get mean: 0.1, 0.2, Hertz, Parabolic if meanPitch = undefined # Take some exceptional action. else # Take the normal action. endif Details for hackers In text files, this value is written as --undefined--. In binary files, it is written as a big-endian IEEE positive infinity. In memory, it is the ANSI-C constant HUGE_VAL, which equals infinity on IEEE machines. Links to this page Formant: Get bandwidth at time... Formant: Get time of maximum... Formant: Get time of minimum... Formant: Get value at time... Formulas 3. Constants Get high index from time... Get low index from time... Get nearest index from time... Harmonicity: Get mean... Harmonicity: Get value at time... Harmonicity: Get value in frame... PointProcess: Get interval... PointProcess: Get jitter (ddp)... PointProcess: Get jitter (local)... PointProcess: Get jitter (local, absolute)... PointProcess: Get jitter (ppq5)... PointProcess: Get jitter (rap)... Sound: Get nearest zero crossing... Sound: Get standard deviation... Sound: Get value at sample number... 
Undo	Undo One of the commands in the Edit menu of the Picture window. It erases your most recently created drawing, which could have come from a command in the Objects window or from one of the drawing commands in the World and Margins menus. Behaviour This command will erase some drawings, but it will not change your settings in the Pen and Font menus (line type, line width, font, font size, and colour). The world window will be what it was after the latest-but-one drawing, so that you can use the Margins menu as if the latest drawing had never happened. 
Unicode	Unicode Praat is becoming a fully international program: the texts in Praat's TextGrids, Tables, scripts, or Info window (and elsewhere) can contain many types of characters (see special symbols). For this reason, Praat saves its text files in one of two possible formats: ASCII or UTF-16. ASCII text files If your TextGrid (or Table, or script, or Info window...) contains only characters that can be encoded as ASCII, namely the characters !#$%&’()*+,-./0123456789:;<=>?@ ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_` abcdefghijklmnopqrstuvwxyz{|}~, then when you say Save as text file... or Save, Praat will write an ASCII text file, which is a text file in which every character is encoded in a single byte (8 bits). All programs that can read plain text files can read such files produced by Praat. UTF-16 text files If your TextGrid (or Table, or script, or Info window...) contains one or more characters that cannot be encoded as ASCII, for instance West-European characters such as åçéöß¿, East-European characters such as čłőšůź, or Hebrew characters such as אבגםוֹוּ, then when you say Save as text file... or Save, Praat will write an UTF-16 text file, which is a text file in which every character is encoded in two bytes (and some very rare characters in four bytes). Many programs can read such text files, for instance NotePad, WordPad, Microsoft Word, and TextWrangler. What if my other programs cannot read UTF-16 text files? If you want to export your Table to Microsoft Excel or to SPSS, or if you want your TextGrid file to be read by somebody else's Perl script, then there will be no problem if your Table contains only ASCII characters (see above). But if your Table contains any other (i.e. non-ASCII) characters, you may be in trouble, because Praat will write the Table as an UTF-16 text file, and not all of the programs just mentioned can read such files yet. What you can do is go to Text writing preferences... in the Preferences submenu of the Praat menu, and there set the output encoding to UTF-8. Praat will from then on save your text files in the UTF-8 format, which means one byte for every ASCII character and 2 to 4 bytes for every non-ASCII character. Especially on Linux, many programs understand UTF-8 text and will display the correct characters. Programs such as SPSS do not understand UTF-8 but will still display ASCII characters correctly; for instance, the names München and Wałęsa may appear as MÃ÷nchen and WaÅ,Ä™sa or so. If you can get by with West-European characters (on Windows), then you may choose try ISO Latin-1, then UTF-16 for the output encoding. It is possible (but not guaranteed) that programs like SPSS then display your West-European text correctly. This trick is of limited use, because it will not work if your operating system is set to a codepage differently from ISO Latin-1 (or ANSI), or if you need East-European or Hebrew characters, or if you want to share your text files with Macintosh users. If you already have some UTF-16 text files and you want to convert them to UTF-8 or ISO Latin-1 (the latter only if they do not contain non-West-European characters), then you can read them into Praat and save them again (with the appropriate output encoding setting). Other programs, such a NotePad and TextWrangler, can also do this conversion. Finally, it is still possible to make sure that all texts are ASCII, e.g. you type the characters ß and ő as \ss and \o: respectively. See special symbols. Links to this page FAQ (Frequently Asked Questions) 
Van_Nierop_et_al___1973_	Van Nierop et al. (1973) D.J.P.J. Van Nierop, L.C.W. Pols & R. Plomp (1973): Frequency analysis of Dutch vowels from 25 female speakers. Acustica 29: 110–118 Links to this page Create formant table (Pols & Van Nierop 1973) Create TableOfReal (Van Nierop 1973)... 
vector_peak_interpolation	vector peak interpolation An algorithm for finding a maximum or a minimum in a sampled signal. Overview The signal is described with the sequence yi, i = 1...n, where n is the number of samples. Each sample i is associated with an x value (typically, time) given by xi = x1 + (i - 1) dx, where dx is the sample period. The maximum is looked for in two kinds of locations: 1. At the left and right edge, i.e. at i = 1 and at i = n. 2. At or near all local maxima, i.e. at or near those i that satisfy yi-1 < yi ≤ yi+1. The greatest of the following values, therefore, will be the maximum: 1. y1. 2. The local maxima, which are at or near yi, where yi-1 < yi ≤ yi+1. 3. yn. We will now see what near means. The precision of the result depends on the interpolation method of this algorithm. 1. Lowest precision: round to sample If the interpolation method is None, the local maxima are at the samples m that satisfy ym-1 < ym ≤ ym+1. Thus, their x values are at xm = x1 + (m - 1) dx, and their y values are ym. This kind of precision is appropriate for an unordered sequence of values yi: the result is simply the greatest available value. 2. Middle precision: parabolic interpolation If the interpolation method is Parabolic, the algorithm uses one point on each side of every local maximum ym to estimate the location and value of the local maximum. Because a Taylor expansion shows that any smooth curve can be approximated as a parabola in the vicinity of any local maximum, the location xmax and value ymax can be found with the following procedure: dy ≡ 1/2 (ym+1 - ym-1) d2y ≡ 2 ym - ym-1 - ym+1 m′ ≡ m + dy/d2y xmax = x1 + (m′ - 1) dx ymax = ym + 1/2 dy2 / d2y This kind of precision is appropriate if y is considered a smooth function of x, as in: Formant: Get minimum... Formant: Get time of minimum... Formant: Get maximum... Formant: Get time of maximum... Intensity: Get minimum... Intensity: Get time of minimum... Intensity: Get maximum... Intensity: Get time of maximum... 3. Higher precision: cubic interpolation If the interpolation method is Cubic, the interpolation is performed over four points (see vector value interpolation). The results are similar to those of the parabolic interpolation method, but you can use it (or sinc interpolation) if you want the result of a command like Get maximum... to be equal to the result of a sequence of commands like Get time of maximum... and Get value at time.... 4. Highest precision: sinc interpolation If the interpolation method is Sinc70 or Sinc700, the algorithm assumes that the signal is a sum of sinc functions, so that a number of points (namely, 70 or 700) on each side of the initial guess m must be taken into account (see vector value interpolation). The algorithm finds the maximum of this continuous function by Brent's method (see Press et al. (1992)). This method is appropriate for signals that result from sampling a continuous signal after it has been low-pass filtered at the Nyquist frequency. See: Sound: Get minimum... Sound: Get time of minimum... Sound: Get maximum... Sound: Get time of maximum... Sound: Get absolute extremum... Links to this page Harmonicity: Get maximum... Harmonicity: Get minimum... Harmonicity: Get time of maximum... Harmonicity: Get time of minimum... Ltas: Get frequency of maximum... Ltas: Get frequency of minimum... Ltas: Get maximum... Ltas: Get minimum... PowerCepstrum: Get peak prominence... 
vector_value_interpolation	vector value interpolation An algorithm for estimating the value of a sampled signal at a specified location. Overview The signal is described with the sequence yi, i = 1...n, where n is the number of samples. Each sample i is associated with an x location (typically, time) given by xi = x1 + (i - 1) dx, where dx is the sample period, so that the real-valued sample number associated with a given time x is s = (x - x1) / dx + 1 If the resulting s is an integer number, the y value must be ys. Otherwise, the estimated y value y(s) must be interpolated from nearby values of y. The precision of the result depends on the interpolation method of this algorithm. 1. Lowest precision: round to sample If the interpolation method is Nearest, we take the value of the nearest point: near ≡ round (s) y(s) ≈ ynear 2. Middle precision: linear interpolation If you know or assume that the function that underlies your points is continuous, the rounding interpolation would be poor, because the rounded value would abruptly change at the centres between the sample points. For a linear interpolation, therefore, we use the attested values on both sides (left and right) of s: sl ≡ floor (s) ; sr ≡ sl + 1 y(s) ≈ yl + (s - sl) · (yr - yl) where floor (x) computes the greatest integer not greater than x. This interpolation is continuous. 3. Higher precision: cubic interpolation If you know or assume that the function that underlies your points is smooth, i.e. its derivative is defined for every x, linear interpolation would probably be poor, because the derivative of the interpolated function would abruptly change at every sample point. The next higher interpolation (Cubic), therefore, is differentiable at sample points. To enforce this, we define the derivatives y′l and y′r at the left and right sample points on the basis of their immediate neighbours (i.e., the algorithm needs four sample points), perhaps by a parabolic interpolation through these three points. A parabolic interpolation has the advantage that the extrema will be computed correctly if the underlying function can be approximated by a parabola near its extremes (see vector peak interpolation). Because the derivative of a parabolic function is a linear function of x, the derivatives at the left and right sample points are simply estimated as y′l ≈ (yr - yl-1) / 2 ; y′r ≈ (yr+1 - yl) / 2 Now that we know yl, yr, y′l, and y′r, we can fit these values with a third-degree (cubic) polynomial: Asl3 + Bsl2 + Csl + D = yl Asr3 + Bsr2 + Csr + D = yr 3Asl2 + 2Bsl + C = y′l 3Asr2 + 2Bsr + C = y′r If we shift the x axis to the left sample point, we can reduce the four equations to D = yl A + B + C + D = yr C = y′l 3A + 2B + C = y′r so that the interpolated value y(s) at any point s between sl and sr is estimated as (y′r + y′l - 2yr + 2yl) φl3 + (3yr - 3yl - 2y′l - y′r) φl2 + y′l φl + yl where φl ≡ s - sl. Some rearrangement gives y(s) ≈ yl φr + yr φl + - φl φr [1/2 (y′r - y′l) + (φl - 1/2) (y′l + y′r - 2(yr - yl))] where φr ≡ 1 - φl. From this formula we see: 1. The first two terms define the linear interpolation. 2. If the underlying function is linear, so that y′l equals y′r and both equal yr - yl, the higher-degree terms are zero. 3. If y′l + y′r equals 2(yr - yl), the third-degree term is zero, so that the interpolated function is parabolic. 4. At the left and right points, one of the φ is 0 and the other is 1, so that at these boundary points, y is computed with exact precision. 4. Highest precision: sinc interpolation If the interpolation method is Sinc70 or Sinc700, the algorithm assumes that the signal is a sum of sinc functions, so that a number of points (the interpolation depth: 70 or 700) on each side of s must be taken into account. Because the interpolation depth must be finite, the sum of sinc functions is multiplied by a Hanning window: sl ≡ floor (s); sr ≡ sl + 1 φl ≡ s - sl; φr ≡ 1 - φl y(s) ≈ ∑i=1...N yr-i sinc (π(φl+i-1)) (1/2 + 1/2 cos (π(φl+i-1)/(φl+N))) + + ∑i=1...N yl+i sinc (π(φr+i-1)) (1/2 + 1/2 cos (π(φr+i-1)/(φr+N))) where the sinc function is defined as sinc (0) ≡ 1; sinc (x) ≡ sin x / x for x ≠ 0 If s is less than the interpolation depth or greater than n + 1 minus the interpolation depth, the depth is reduced accordingly. This method is appropriate for signals that result from sampling a continuous signal after it has been low-pass filtered at the Nyquist frequency. See: Sound: Get value at time... Links to this page Formant: Get value at time... Harmonicity: Get value at time... Intensity: Get value at time... Ltas: Get value at frequency... 
View	View One of the menus in several editors and in the manual. Links to this page Intro 8.2. Manipulation of duration Play 
View___Edit	View & Edit A command in the Dynamic menu of several types of objects. This command puts an editor window on the screen, which shows the contents of the selected object. This window will allow your to view and modify the contents of this object. Links to this page Intro 1.1. Recording a sound Intro 2.2. Viewing and editing a sound Intro 3.1. Viewing a spectrogram Intro 3.8. The Spectrum object Intro 4.1. Viewing a pitch contour Intro 4.5. The Pitch object Intro 5.1. Viewing formant contours Intro 6.1. Viewing an intensity contour Intro 7. Annotation Intro 8.1. Manipulation of pitch Intro 8.2. Manipulation of duration Intro 8.3. Manipulation of intensity Scripting 7.2. Scripting an editor from within 
Viewport_text___	Viewport text... One of the commands in the Select menu of the Picture window. Purpose To write text inside the viewport, at nine different places, with a rotation between 0 to 360 degrees. Settings: Horizontal alignment determines the horizontal alignment of the text: • Left means pushed against the left edge of the viewport; • Right means pushed against the right edge of the viewport; • Centre means horizontally centred in the viewport. Vertical alignment determines the vertical alignment of the text: • Top means pushed against the top of the viewport; • Bottom means pushed against the bottom of the viewport; • Half means vertically centred in the viewport. Text will be drawn in the current font and font size that you set with the Font menu. Behaviour For rotated text, the alignment settings will not only determine the position inside the viewport, but also the alignment in the rotated coordinate system. This gives surprises now and then; so, if you want several rotated texts that align with each other, you should do this by varying the viewport, not the alignment. Usage You can use all special symbols and text styles. 
VocalTract	VocalTract One of the types of objects in Praat. A VocalTract object represents the area function of the vocal tract, expressed in m2, running from the glottis to the lips. Links to this page Create Vocal Tract from phone... VocalTract: Formula... VocalTractTier 
VocalTract__Formula___	VocalTract: Formula... A command for changing the data in all selected VocalTract objects. See the Formulas tutorial for examples and explanations. 
VocalTractTier	VocalTractTier One of the types of objects in Praat. A VocalTractTier objects contains a number of (time, VocalTract) points, where a VocalTract represents the area function of the vocal tract expressed as m2, running from the glottis to the lips. 
Voice	Voice This tutorial describes how you can do voice analysis with Praat. To understand this tutorial, you have to be familiar with the Intro, which describes the more general features of the SoundEditor window. Most of Praat's voice analysis methods start from the glottal pulses that are visible in the SoundEditor window as blue vertical lines through the waveform. If you do not see these lines, choose Show pulses from the Pulses menu. If your sound is long, you may have to zoom in in order to see the separate pulses. You may notice that for some sounds, the time location of the pulses can vary when you zoom or scroll. This is because only the visible part of the sound is used for the analysis. The measurement results will also vary slightly when you zoom or scroll. The Pulse menu contains the command Voice report, which will show in the Info window the results of many voice measurements for the visible part of the selection (or for the visible part of the whole sound, if there is a cursor instead of a selection or if the selection is not visible). Pitch settings The results of the voice measurements will depend on your Pitch settings. In general, you will want to be careful about the pitch range. The standard range is 75–600 Hertz, but take a range of e.g. 50–200 Hertz for pathological male voices if that is the typical range. You may also want to choose Optimize for voice analysis; otherwise, the voice report will complain about possible inaccuracies. The `advanced' pitch settings like Silence threshold and Octave jump cost can stay at their standard values. Voice 1. Voice breaks Voice 2. Jitter Voice 3. Shimmer Voice 4. Additive noise (HNR, harmonicity) Voice 5. Comparison with other programs Voice 6. Automating voice analysis with a script Links to this page Acknowledgments Advanced pulses settings... Types of objects 
Voice_1__Voice_breaks	Voice 1. Voice breaks Normal voices can easily maintain phonation for some time when saying [a]. Some pathological voices have trouble with it. This can be measured in Praat in two ways. Fraction of locally unvoiced pitch frames This is the fraction of pitch frames that are analysed as unvoiced (MDVP calls it DUV). If the pitch floor is 75 Hz, your Sound editor window will contain pitch measurements that are 0.01 seconds apart, so that if you select one second, there will be 100 pitch frames. If 86 of these are locally voiced, the Fraction will be 14 percent. The usual pitch analysis contains a path finder that searches for a smooth path through the local pitch candidates. This path finder is temporarily switched off to determine the fraction of locally unvoiced frames. A frame is regarded as locally unvoiced if it has a voicing strength below the voicing threshold (whose standard value is 0.45), or a local peak below the silence threshold (whose standard value is 0.03). In the voice report, the fraction of unvoiced frames will be reported as follows: Fraction of locally unvoiced frames: 14.000% (14/100) The numbers between parentheses are the number of unvoiced frames and the total number of frames, respectively (in MDVP, these are called NUV and SEG, respectively). The normative value for the fraction of unvoiced frames is 0, i.e., normal healthy voices should have no trouble maintaining voicing during a sustained vowel. Every non-zero value can be considered a sign of pathology (like a common cold). Naturally, you will not select the leading and trailing silences when measuring this parameter. Number of voice breaks The number of distances between consecutive pulses that are longer than 1.25 divided by the pitch floor. Thus, if the pitch floor is 75 Hz, all inter-pulse intervals longer than 16.6667 milliseconds are regarded as voice breaks. Degree of voice breaks This is the total duration of the breaks between the voiced parts of the signal, divided by the total duration of the analysed part of the signal (MDVP calls it DVB). Since silences at the beginning and the end of the signal are not considered breaks, you will probably not want to select these silences when measuring this parameter. In the voice report, the degree of voice breaks will be reported like this: Degree of voice breaks: 29.529% (1.163061 s / 3.938685 s) The numbers between parentheses are the total duration of the voice breaks and the duration of the analysed part of the signal, respectively. Links to this page Voice 
Voice_2__Jitter	Voice 2. Jitter You can measure jitter in the Sound editor window, after choosing Show pulses from the Pulses menu. You will see blue lines that can be thought of as representing the glottal closures. Use Voice report from the Pulses menu to get the jitter in the selected part. You typically perform jitter measurements only on long sustained vowels. The voice report gives five kinds of jitter measurements. All of these measurements are based on the computation of all periods by the waveform-matching procedure (see Voice 6. Automating voice analysis with a script), where the Period floor setting is 0.8 divided by the pitch ceiling, the Period ceiling setting is 1.25 divided by the pitch floor, and the Maximum period factor is determined in Advanced pulses settings.... Jitter (local) This is the average absolute difference between consecutive periods, divided by the average period. For the precise procedure, see PointProcess: Get jitter (local).... MDVP calls this parameter Jitt, and gives 1.040% as a threshold for pathology. As this number was based on jitter measurements influenced by noise (see Voice 5. Comparison with other programs), the correct threshold is probably lower. Jitter (local, absolute) This is the average absolute difference between consecutive periods, in seconds. For the precise procedure, see PointProcess: Get jitter (local, absolute).... MDVP calls this parameter Jita, and gives 83.200 μs as a threshold for pathology. As this number was based on jitter measurements influenced by noise (see Voice 5. Comparison with other programs), the correct threshold is probably lower. Jitter (rap) This is the Relative Average Perturbation, the average absolute difference between a period and the average of it and its two neighbours, divided by the average period. For the precise procedure, see PointProcess: Get jitter (rap).... MDVP gives 0.680% as a threshold for pathology. As this number was based on jitter measurements influenced by noise (see Voice 5. Comparison with other programs), the correct threshold is probably lower. Jitter (ppq5) This is the five-point Period Perturbation Quotient, the average absolute difference between a period and the average of it and its four closest neighbours, divided by the average period. For the precise procedure, see PointProcess: Get jitter (ppq5).... MDVP calls this parameter PPQ, and gives 0.840% as a threshold for pathology; as this number was based on jitter measurements influenced by noise (see Voice 5. Comparison with other programs), the correct threshold is probably lower. Jitter (ddp) This is the average absolute difference between consecutive differences between consecutive periods, divided by the average period. For the precise procedure, see PointProcess: Get jitter (ddp).... This is Praat's original Get jitter. The value is three times RAP. Links to this page Voice What was new in 5.3? 
Voice_3__Shimmer	Voice 3. Shimmer You can measure shimmer in the Sound editor window, after choosing Show pulses from the Pulses menu. You will see blue lines that can be thought of as representing the glottal closures. Use the Pulse menu to get the shimmer in the selected part. You typically perform shimmer measurements only on long sustained vowels. The voice report gives six kinds of shimmer measurements. Shimmer (local) This is the average absolute difference between the amplitudes of consecutive periods, divided by the average amplitude. MDVP calls this parameter Shim, and gives 3.810% as a threshold for pathology. Shimmer (local, dB) This is the average absolute base-10 logarithm of the difference between the amplitudes of consecutive periods, multiplied by 20. MDVP calls this parameter ShdB, and gives 0.350 dB as a threshold for pathology. Shimmer (apq3) This is the three-point Amplitude Perturbation Quotient, the average absolute difference between the amplitude of a period and the average of the amplitudes of its neighbours, divided by the average amplitude. Shimmer (apq5) This is the five-point Amplitude Perturbation Quotient, the average absolute difference between the amplitude of a period and the average of the amplitudes of it and its four closest neighbours, divided by the average amplitude. Shimmer (apq11) This is the 11-point Amplitude Perturbation Quotient, the average absolute difference between the amplitude of a period and the average of the amplitudes of it and its ten closest neighbours, divided by the average amplitude. MDVP calls this parameter APQ, and gives 3.070% as a threshold for pathology. Shimmer (ddp) This is the average absolute difference between consecutive differences between the amplitudes of consecutive periods. This is Praat's original Get shimmer. The value is three times APQ3. Links to this page Voice 
Voice_4__Additive_noise	Voice 4. Additive noise For a signal that can be assumed periodic (i.e., a sustained vowel), the signal-to-noise ratio equals the harmonics-to-noise ratio, which you get can get by selecting a Sound and choosing one of the To Harmonicity... commands from the Periodicity menu (for the algorithm, see Sound: To Harmonicity (ac)... or Sound: To Harmonicity (cc)...). These are the world's most sensitive HNR measurements (up to 90 dB). For more information, see the Harmonicity manual page. Links to this page Voice 
Voice_5__Comparison_with_other_programs	Voice 5. Comparison with other programs Voicing, jitter, and shimmer measurements made by Praat cannot always be compared directly with those made by other programs such as MDVP. The causes are the voicing decision strategy and the accuracy of period and peak determination. 5.1. Voicing decisions: slightly different Different programs use very different methods for deciding whether an irregular part of the signal is voiced or not. A comparison of Boersma (1993) for Praat and Deliyski (1993) for MDVP leads to the following considerations. Both Praat and MDVP use an autocorrelation method for pitch analysis, but MDVP quantizes the amplitudes into the values -1, 0, and +1 before computing the autocorrelation, whereas Praat uses the original amplitude. Also, Praat corrects the autocorrelation function by dividing it by the autocorrelation function of the window, unlike any other program. Lastly, Praat uses sinc interpolation to compute an accurate estimate of the height of the autocorrelation peaks, unlike any other program. All three of these differences (and there are more) influence the measurement of the height of the autocorrelation peak at 1/F0. This height is generally taken as a criterion for voicing: if it is more than the voicing threshold (which you can change with Pitch settings..., the frame is considered voiced, otherwise voiceless. In Praat, the standard voicing threshold is 0.45, in MDVP it is 0.29, which suggests that MDVP tends to regard more frames as voiced than Praat. But the difference between these two numbers may partly be explained by the fact that MDVP does not correct the autocorrelation function and that MDVP does not do an accurate sinc interpolation: both of these properties cause the measured height of the peak at 1/F0 (in MDVP) to be lower than the real height, as explained by Boersma (1993). 5.2. Jitter measurements: sometimes very different The jitter measures in various programs may yield different results, with Praat often giving much lower values than MDVP, especially for noisy sounds. I will now explain where the difference comes from. A more elaborate explanation with pictures is given in Boersma (2009a). If a sound is computer-generated as a glottal source signal with a random period duration variation of 1 percent (around a constant F0), then filtered with the characteristics of a vocal tract configuration corresponding to a sustained vowel, both Praat and MDVP will measure this sound as having a jitter of 1 percent. For non-noisy jittery sginals, therefore, the two programs give equally accurate results. If a sound is computer-generated as a glottal source signal with a constant period, then filtered with the characteristics of a vocal tract configuration corresponding to a sustained vowel, both Praat and MDVP will measure this sound as having a jitter of less than 0.01 percent. The two programs, therefore, have a comparable sensitivity in measuring small jitter values. So far, the two programs give comparable results. The difference between the two programs comes when noise is added. If a sound is computer-generated as a glottal source signal with a constant period, then filtered with the characteristics of a vocal tract configuration corresponding to a sustained vowel, and if then 1 percent additive white noise (a quite usual amount) is added, Praat will measure this sound as having a jitter of 0.02 percent, whereas MDVP will measure this sound as having a jitter of 0.6 percent. In other words, Praat will tell you that there is almost no jitter, whereas MDVP will tell you that the jitter is of an almost pathological level. The relevant curves can be seen in my papers Stemmen meten met Praat and Boersma (2009a), and the numbers are confirmed by Deliyski, Shaw & Evans (Journal of Voice, 2005: 23). One can see that Praat's jitter measure attempts to separate the influence of period duration variation (which it reports as jitter) from the influence of additive noise (which is does not report as jitter), and that MDVP's jitter measure combines the influence of period duration variation with the influence of additive noise (both of which it reports as jitter). The difference between Praat's and MDVP's jitter measures is due to a difference between the way in which periods are measured. Praat uses waveform-matching, in which the duration of a period is determined by looking for best matching wave shapes (a cross-correlation maximum). MDVP uses peak-picking instead, where the duration of a period is determined by measuring the time difference between two locally highest peaks in the wave form. The waveform-matching method averages away much of the influence of additive noise, whereas peak-picking is highly sensitive to additive noise. For detailed illustrations, see Boersma (2009a). Links to this page Voice Voice 2. Jitter 
Voice_6__Automating_voice_analysis_with_a_script	Voice 6. Automating voice analysis with a script In a Praat script you usually do not want to raise a Sound window. Instead, you probably want to work with objects in the Objects window only. This page tells you how to do that for voice analysis. 1. Creating the pulses in the Objects window The pulses you see as blue lines are a PointProcess object. You can see this if you choose Extract visible pulses from the Pulses menu in the Sound window: a PointProcess object will appear in the list. You can also create a PointProcess in the Objects window directly. To do this, select a Sound and choose Sound: To PointProcess (periodic, cc)... from the Periodicity menu. You can also do this in two steps. First you create a Pitch with Sound: To Pitch... or Sound: To Pitch (ac)... or Sound: To Pitch (cc).... Then you select the resulting Pitch together with the original Sound and choose Sound & Pitch: To PointProcess (cc). Since the direct method of Sound: To PointProcess (periodic, cc)... actually uses the AC method for computing the Pitch (which is optimal for intonation analysis), you may prefer the two-step version if your goal is to do voice analysis. In that case, you use Sound: To Pitch (cc)... as the first step, and Sound & Pitch: To PointProcess (cc) as the second step. This is also how the Sound window does it: if you choose Optimize for voice analysis in the Pitch settings, Praat uses Sound: To Pitch (cc)... for pitch analysis. What you should not do if you want to perform voice analysis is to create the PointProcess by selecting a Pitch only and then choosing Pitch: To PointProcess. In that way, the resulting pulses would not be aligned to the periods in the Sound. 2. Measuring jitter from a script Once you have a PointProcess that represents the periods in the Sound, you can select it and choose some Get jitter commands from the Query menu. 3. Measuring shimmer from a script Once you have a PointProcess that represents the periods in the Sound, you can select it together with the Sound, then choose some Get shimmer commands from the Query menu. 4. Getting the whole voice report from a script If you select the Sound, the Pitch, and the PointProcess together (all three), there will be a button that says Voice report.... If you press it, the voice report will be written to the Info window. This is identical to the voice report in the Sound window, although you will have to specify the time range by manually typing it. In a script, you can get the jitter and shimmer from the voice report by doing something like: voiceReport$ = Voice report: 0, 0, 75, 500, 1.3, 1.6, 0.03, 0.45 jitter = extractNumber (voiceReport$, Jitter (local): ) shimmer = extractNumber (voiceReport$, Shimmer (local): ) writeInfoLine: Jitter = , percent$ (jitter, 3), , shimmer = , percent$ (shimmer, 3) 5. Disadvantage of automating voice analysis In all the commands mentioned above, you have to guess the time range, and you would usually supply 0.0 and 0.0, in which case you will get the average jitter and shimmer for the whole sound. This may include parts of the sound that you are often not interested in, such as false starts. You do not have these problems when asking for a voice report in the sound window, because there you would make an explicit time selection by hand after judging what part of the sound is relevant. Links to this page Voice Voice 2. Jitter 
Voice_report	Voice report A command in the Pulses menu that will write to the Info window an extensive report about many voice parameters. See the Voice tutorial. Links to this page Voice 2. Jitter 
Vollgraf___Obermayer__2006_	Vollgraf & Obermayer (2006) Roland Vollgraf & Klaus Obermayer (2006): Quadratic optimization for simultaneous matrix diagonalization. IEEE Transactions On Signal Processing 54: 3270–3278. Links to this page Sound: To Sound (blind source separation)... 
VowelEditor	VowelEditor An Editor for generating vowel-like Sounds from mouse movements. How to get a sound With the mouse button down, you can move the mouse cursor around in the plane spanned by the first two formants. While you move the cursor around, the positions you trace will be indicated by blue dots. After you release the mouse button, the color of the trajectory will change to black. Next you will hear the vowel-like sound whose first two formants follow this trajectory. (The small bars on the trajectory are time markers. With default settings, time markers are at 50 milliseconds apart and they may give you an indication of the speed by which you traversed the trajectory.) The interface In the lower part of the editor a number of buttons and fields are displayed. Play will play the trajectory. Reverse will reverse the trajectory and play it. Publish will publish the sound in the list of objects. Duration (s) allows to modify the duration of the current trajectory. Extend (s) determines the duration of the straight line trajectory that connects the endpoint of the current trajectory with the startpoint of a new trajectory. You may extend the current trajectory by starting a new trajectory with the shift button pressed. After you finished the new trajectory, three trajectories will be appended: the current one, the straight line one and the new one. Start F0 (Hz) determines the fundamental frequency at the start of the trajectory. F0 slope (oct/s) determines how many octaves the pitch will changes during the course of the trajectory. The bottom line in the Editor displays the first and second formant frequency and the fundamental frequency at the start point and the endpoint of the trajectory. Edit menu Set F0... Set pitch and slope. Set F3 & F4... Set the frequencies and bandwidths for the third and fourth formant. Reverse trajectory Reverses the trajectory (like editor button). Modify trajectory duration... Modifies trajectory duration (like editor field). New trajectory... Set startpoint, endpoint and duration of a new trajectory. Extend trajectory... Extend current trajectory to... Shift trajectory... Shift current trajectory. View menu F1 & F2 range... Modify the horizontal and vertical scales. Show vowel marks from fixed set... Show the vowel marks in the editor from a fixed set of vowel inventories. Show vowel marks from Table file... Put your own marks in the editor. The Table needs to have at least three mandatory columns labeled Vowel, F1 and F2 and one optional column labeled Size. The Vowel column contains the vowel marker labels, the F1 and F2 columns have the first and second formant frequencies in Hertz. The optional Size column contains the font size of the vowel markers. Show trajectory time markers every... Shows time markers as small bars orthogonal to the trajectory. Publishing Publish Sound Extract FormantTier Extract PitchTier Publish the Sound, the PitchTier and the FormantTier from the trajectory. Draw trajectory... Draws the trajectory in the picture window Links to this page Acknowledgments VowelEditor: Show vowel marks from Table file... 
VowelEditor__Show_vowel_marks_from_Table_file___	VowelEditor: Show vowel marks from Table file... A command in the VowelEditor that lets you set your own vowel marks. Layout of the Table The Table needs at least three mandatory columns labeled Vowel, F1 and F2 and one optional column labeled Size. The Vowel column contains the vowel marker labels, the F1 and F2 columns have the first and second formant frequencies in Hertz. The optional Size column contains the font size of the vowel markers. 
Wakita__1977_	Wakita (1977) H. Wakita (1977): Normalization of vowels by vocal-tract length and its application to vowel identification. IEEE Trans. on ASSP 25: 183–192. 
Watrous__1991_	Watrous (1991) R.L. Watrous (1991): Current status of Peterson-Barney vowel formant data. Journal of the Acoustical Society of America 89: 2459–2460. Links to this page Create formant table (Peterson & Barney 1952) 
waveform	waveform The waveform is the sound pressure as a function of time, or: the microphone output as a function of time. In Praat, the waveform is shown in the top half of the Sound window (see the Intro). Links to this page FAQ: Pitch analysis 
Weenink__1985_	Weenink (1985) D.J.M. Weenink (1985), Formant analysis of Dutch vowels from 10 children, Proceedings of the Institute of Phonetic Sciences of the University of Amsterdam 9, 45–52. Links to this page Create formant table (Weenink 1985) Create TableOfReal (Weenink 1985)... 
Weenink__1999_	Weenink (1999) D.J.M. Weenink (1999): Accurate algorithms for performing principal component analysis and discriminant analysis. Proceedings of the Institute of Phonetic Sciences of the University of Amsterdam 23: 77–89. 
Weenink__2003_	Weenink (2003) D.J.M. Weenink (2003): Canonical correlation analysis. Proceedings of the Institute of Phonetic Sciences of the University of Amsterdam 25: 81–99. Links to this page Canonical correlation analysis 
Weight	Weight One of the types of objects in PRAAT. An object of type Weight represents a matrix with weights wij. An object of type Weight selected together with an onject of type Dissimilarity can be used to make distinctions in the importance of the contribution of each individual dissimilarity δij to stress and therefore to the final configuration. Weights can be used for instance to code for missing values, i.e., take wij = 0 if dissimilarity δij is missing and wij = 1 if δij is known. Commands Creation Dissimilarity: To Weight Analysis See Dissimilarity & Weight: To Configuration... for help on the following analysis items: Dissimilarity & Weight: To Configuration (monotone mds)... Dissimilarity & Weight: To Configuration (i-spline mds)... Dissimilarity & Weight: To Configuration (interval mds)... Dissimilarity & Weight: To Configuration (ratio mds)... Dissimilarity & Weight: To Configuration (absolute mds)... Query See Dissimilarity & Configuration & Weight: Get stress... for help on the following query items: Dissimilarity & Configuration & Weight: Get stress (monotone mds)... Dissimilarity & Configuration & Weight: Get stress (i-spline mds)... Dissimilarity & Configuration & Weight: Get stress (interval mds)... Dissimilarity & Configuration & Weight: Get stress (ratio mds)... Dissimilarity & Configuration & Weight: Get stress (absolute mds)... Links to this page Dissimilarity & Configuration & Weight: To Configuration... Dissimilarity & Weight: To Configuration... Multidimensional scaling 
Weller___Romney__1990_	Weller & Romney (1990) S.C. Weller & A.K. Romney (1990): Metric Scaling: correspondence analysis. Sage University Paper Series on Quantitative Applications in the Social Sciences 07-075. Newbury Park, CA: Sage. Links to this page Correspondence analysis 
What_s_new_	What's new? Latest changes in Praat. 5.4 (4 October 2014) 5.3.87 (3 October 2014) • Windows scripting: prevented incorrect handling of relative paths after the use of chooseReadFile$. • Windows: repaired a bug that could cause Praat to crash if a metafile resolution was 180 or 1200 dpi. 5.3.86 (28 September 2014) • Linux audio: reverted to old version of PortAudio because of race problems in the Alsa–PulseAudio cooperation. 5.3.85 (19 September 2014) • Mac audio: circumvented a bug in PortAudio by which playback of sounds with sampling frequencies below 44100 Hz could be distorted on some USB headsets. 5.3.84 (26 August 2014) • Manipulation: repaired a bug that could cause Praat to crash when playing a manipulation of a Sound created by the SpeechSynthesizer. 5.3.83 (16 August 2014) • TextGrid window: repaired a bug with automatic alignment that could cause an analysis tier to go out of order. • Linux audio: created a second workaround that reduces even more the chances of a freeze that is due to a potential deadlock in the collaboration between Alsa and PulseAudio that can occur when the playback of a sound is cancelled. • Smoother communication with Phon. • Windows: repaired a memory leak when saving PNG files. 5.3.82 (26 July 2014) • Audio playback: if the sound has more channels than the audio hardware, distribute them evenly. • Pause forms: more consistent appearance of the Revert button. • Scripting: pauseScript ( ) function. 5.3.81 (2 July 2014) • EEG: can work with status numbers instead of only with status bits. • Windows: repaired a bug that could cause Praat to crash if there was a 96-dpi printer. 5.3.80 (29 June 2014) • Praat preferences: choice between Chinese and Japanese style for Han characters. 5.3.79 (21 June 2014) • Can now play sounds over more than two channels. • Asynchronous play in scripts (see Demo window). • EEG: blue-to-red colour scale for scalp distributions. 5.3.78 (12 June 2014) • Multithreading can now speed up pitch analysis by a factor of 4 or so, depending on the number of cores in your processor. • Linux: can now open and save Photo objects (from PNG files) and use Insert picture from file.... • Open WAV files that are in the extensible format (previously unsupported format -2). • Windows: support for dropping more than one file on the Praat icon. • Scripting: can now use the editor command with an object's ID instead of only with its name. • Windows: removed a bug that sometimes disallowed saving more than one JPEG file. • Linux audio: created a workaround that reduces the chances of a freeze that is due to a potential deadlock in the collaboration between Alsa and PulseAudio that can occur when the playback of a sound is cancelled. 5.3.77 (18 May 2014) • EEG: more facilities for EDF+ files. 5.3.76 (8 May 2014) • One can determine the size of speckles (filled circles) with Speckle size... in the Pen menu. Speckles are used in drawing Formant, PitchTier, and several other kinds of objects. 5.3.75 (30 April 2014) • Linux Matrix graphics bug fix: corrected working of Draw cells.... • Scripting bug fix: ability to use x and y as indexed variables. • PowerCepstrogram bug fix: made old version of Paint command available again for scripts. 5.3.74 (24 April 2014) • EEG: more interpretation of triggers in EDF+ files. 5.3.73 (21 April 2014) • EEG: understand more EGI/NetStation files. 5.3.72 (17 April 2014) • Windows: repaired a bug that caused two black edges in PNG files. • Windows: repaired a bug that could cause Praat to crash if a metafile resolution was 360 dpi. • Linux: repaired a bug that caused Praat to crash when cutting or pasting a sound in the Sound window. 5.3.71 (9 April 2014) • Windows: brought more unity in the style of Chinese characters. 5.3.70 (2 April 2014) • Added some query commands for DurationTier objects. • Repaired a bug that caused Praat not to run as a console app. 5.3.69 (28 March 2014) • Picture window: can save to 300-dpi and 600-dpi PNG files. • Graphics: sub-pixel precision line drawing on Mac and Linux. • Repaired a bug that could show spurious buttons in the Objects window if a plug-in created objects. 5.3.68 (20 March 2014) • Mac: corrected a bug introduced in 5.3.67 that could cause crashes when drawing a spectrogram. • Mac and Linux: Create Strings as file list... handles broken symbolic links more leniently. 5.3.67 (19 March 2014) • Corrected a bug that would create strange PNG files if the selection did not touch the upper left corner of the Picture window. • Mac: can save the Picture window to PNG file. • EEG: understand trigger letters in BDF/EDF files. 5.3.66 (9 March 2014) • Windows and Linux: can save the Picture window to PNG file. • Windows: opening, modifying and saving PNG, TIFF or JPEG files (the Photo object, as on the Mac). 5.3.65 (27 February 2014) • Scripting language: removed some bugs from runScript. • Linux: can save the Picture window to PDF file. 5.3.64 (12 February 2014) • Scripting language: writeInfo, procedure, exitScript, runScript: all with colons. • 64-bit Mac graphics: better highlighting and unhighlighting of selection. • 64-bit Mac graphics: full screen. 5.3.63 (24 January 2014) • Scripting language: easier menu command invocation using the colon :. • 64-bit Mac graphics: better handling of any absence of Doulos SIL or Charis SIL. • Windows scripting: can now use ~ in file names to refer to home directory, as on Mac and Linux. 5.3.62 (2 January 2014) • 64-bit Mac: removed a bug introduced in 5.3.61 that could cause text containing ff to become invisible. 5.3.61 (1 January 2014) • EEG: understand status registers that contain text. • KlattGrid: removed a bug introduced in May 2009 that could make Praat crash after editing an oral formant grid. 5.3.60 (8 December 2013) • Mac 64-bit: implemented swiping (to scroll with the trackpad) and pinching (to zoom with the trackpad). • Scripting: backslashTrigraphsToUnicode () and unicodeToBackslashTrigraphs (). 5.3.59 (20 November 2013) • EEG: faster reading of BDF and EDF files. • Batch scripting: made appendInfo() write to the console in the same way as print. • Removed a bug introduced in 5.3.57 whereby some Praat text files could not be read. 5.3.58 (17 November 2013) • EEG: support for 16-bit (next to 24-bit) BDF files and for 16-bit (next to 8-bit) statuses. • Mac: 64-bit beta version. 5.3.57 (27 October 2013) • Mac: opening, modifying and saving image files (the Photo object). • Mac 64-bit: some small improvements in the user interface. 5.3.56 (15 September 2013) • Mac: 64-bit alpha version. • Linux: improved selecting in the Picture window. 5.3.55 (2 September 2013) • Corrected a bug introduced in 5.3.54 by which you couldn't select a file for saving. 5.3.54 (1 September 2013) • Sound window: removed a bug introduced in 5.3.42 by which you couldn't ask for an odd number of poles in Formant Settings (by e.g. specifying 5.5 for the number of formants). Linux: improved dragging of selections in the Picture window and the Sound window. 5.3.53 (9 July 2013) • Table: more drawing commands. 5.3.52 (12 June 2013) • Scripting: editor windows understand do and do$. 5.3.51 (30 May 2013) • Sound window: Extract selected sound for overlap.... 5.3.49 (13 May 2013) • TextGrid window: alignment of the sound and the annotation in an interval, via Espeak. • Scripting: repaired a bug introduced in 5.3.32 that could cause very slow running of scripts. 5.3.48 (1 May 2013) • Scripting: variable-substitution-free object selection and file writing. • Scripting: selectObject and removeObject can select or remove multiple objects at a time. 5.3.47 (23 April 2013) • OTGrammar: included Giorgio Magri's (2012) update rule (weighted all up, high down). 5.3.46 (21 April 2013) • Scripting: variable-substitution-free procedure calls. • Linux: made the Save menu compatible with Ubuntu 12.04. 5.3.45 (15 April 2013) • More parts of the manual reflect variable-substitution-free scripting. 5.3.44 (7 April 2013) • Create Sound as pure tone.... • First steps towards variable-substitution-free scripting: the do, do$, writeInfo and appendInfo functions. 5.3.43 (27 March 2013) • Read and write stereo Kay sound files. • Phonetic symbols ʦ, ʧ and ʼ. • Network: Normalize weights..., List weights..., Weights down to Table.... 5.3.42 (2 March 2013) • Repaired some minor bugs regarding synchronization between multiple windows. 5.3.41 (9 February 2013) • Linux: repaired a bug that could cause Praat to crash when closing the Info window or a script window. 5.3.40 (2 February 2013) • Windows: better handling (in the LongSound window) of sounds that are too long to play. • Mac: corrected a bug that caused Praat to crash when closing the Strings window. • Linux: made audio output work again on 32-bit Linux. 5.3.39 (6 January 2013) • Formant & Spectrogram: To IntensityTier... 5.3.38 (4 January 2013) • ExperimentMFC: repaired a bug introduced in 5.3.36 that caused sound to fail to play completely if the screen did not blank. 5.3.37 (2 January 2013) • ExperimentMFC: after screen blanking, reaction times count from when the response buttons appear. 5.3.36 (1 January 2013) • ExperimentMFC: made it possible to blank the screen while the sound is playing. 5.3.35 (8 December 2012) • SpeechSynthesizer: made it possible to have more than one at a time. • Linux: corrected a bug that caused incorrect alignment of the buttons in the Objects window. 5.3.34 (21 November 2012) • Windows: corrected a bug that caused incorrect alignment of the buttons in the Objects window. • The new Sound: Combine to stereo can now work with Sounds of different durations, as the old could. • Corrected a bug that caused Praat to crash when creating a SpeechSynthesizer. 5.3.33 (20 November 2012) • Sound: Combine to stereo can now combine any number of Sounds into a new Sound whose number of channels is the sum of the numbers of channels of the original Sounds. • ERP: Down to Sound. 5.3.32 (17 October 2012) • Sound window: corrected the working of the by window scaling option. 5.3.31 (10 October 2012) • ERP: Down to Table... • Linux: corrected a bug that could cause Praat to crash after closing a file selector window for saving. 5.3.30 (6 October 2012) • Circumvented a rare Windows bug that could cause Praat to start to write 1.5 as 1,5 in some countries after opening a strange directory. • Windows: corrected a bug introduced in 5.3.24 that could cause Praat to crash when quitting. • Windows: corrected a bug introduced in 5.3.24 that could cause the Objects window to look weird after resizing. 5.3.29 (30 September 2012) • EEG: Draw scalp..., including gray legend. • Made the new Sound scaling options available for LongSounds. 5.3.28 (28 September 2012) • Corrected a bug introduced in 5.3.24 that made Praat crash on OSX 10.5. 5.3.27 (27 September 2012) • Corrected a couple of small bugs. 5.3.26 (26 September 2012) • Corrected a bug introduced in 5.3.24 that prevented Praat from running in batch mode. 5.3.25 (26 September 2012) • EEG: view of scalp distribution takes scaling options into account. • Linux: swipable Sound window and manual. • Linux: corrected a bug introduced in 5.3.24 whereby TextGrids could not be edited. 5.3.24 (24 September 2012) • More kinds of vertical scaling in e.g. Sound and EEG windows. • Rewritten user interface (may contain some bugs). 5.3.23 (7 August 2012) • Mac: removed a bug introduced in September 2011 that could cause incorrect behaviour of regular expressions since July 2012. 5.3.22 (21 July 2012) • Linux: removed a bug introduced in 5.3.21 that could cause Praat to crash when opening files. • Neural networks: correct writing and reading of learning settings. 5.3.21 (10 July 2012) • Linux: better folder choice in file selector window for opening files. • Repaired a bug that caused Praat to crash when opening a ManPages file on some platforms. 5.3.20 (5 July 2012) • EEG: Replace TextGrid. 5.3.19 (24 June 2012) 5.3.18 (15 June 2012) • Corrected a bug in Sound: Change gender... that caused a part of the sound not to be changed. 5.3.17 (12 June 2012) • EEG window: extent autoscaling by window. • ERPTier: Remove events between... 5.3.16 (23 May 2012) 5.3.15 (10 May 2012) • Improvements in clipboards, PDF and EPS files. 5.3.14 (28 April 2012) • Linux: Tab shortcut for playing the selection. • EPS files: higher minimum image resolution for spectrograms (300 instead of 106 dpi). 5.3.13 (11 April 2012) • EEG: Extract part... 5.3.12 (5 April 2012) • Praat picture file: allow larger function drawings (up to 109 instead of 106 points). • Linux: better audio compatibility with Ubuntu 11.10 (support for unusual sampling frequencies when playing LongSounds). 5.3.11 (27 March 2012) • EEG: a selected ERPTier can extract events on the basis of a column of a selected Table. 5.3.10 (12 March 2012) • EEG: Concatenate. 5.3.09 (10 March 2012) • Better text-to-speech. 5.3.08 (5 March 2012) • Removed a bug introduced in 5.3.07 that could cause Praat to crash when viewing a LongSound. 5.3.07 (4 March 2012) • Praat can now save Sounds as 24-bit and 32-bit WAV files. 5.3.06 (28 February 2012) 5.3.05 (19 February 2012) • SpeechSynthesizer (New menu → Sound): text-to-speech. • EEG: better scalp distribution drawing for both 32-channel and 64-channel recordings. 5.3.04 (12 January 2012) • EEG: draw scalp distribution. • Linux: better audio compatibility with Ubuntu 11.10 (support for unusual sampling frequencies when playing Sounds). 5.3.03 (21 November 2011) • EEG: filtering, editing, more viewing. 5.3.02 (7 November 2011) • Corrected a bug introduced in 5.3.01 that could cause the PitchTier or PointProcess window to crash. • Corrected a bug that could cause the Info window to freeze after an error message in a script window. 5.3.01 (1 November 2011) • Macintosh and Windows: better window positioning if the Dock or Task Bar is on the left or right. • IPA symbol: you can now use \.f for the half-length sign (ˑ). • EEG window. What used to be new? • What was new in 5.3? • What was new in 5.2? • What was new in 5.1? • What was new in 5.0? • What was new in 4.6? • What was new in 4.5? • What was new in 4.4? • What was new in 4.3? • What was new in 4.2? • What was new in 4.1? • What was new in 4.0? • What was new in 3.9? • What was new in 3.8? • What was new in 3.7? • What was new in 3.6? • What was new in 3.5? • What was new in 3.3? • What was new in 3.2? • What was new in 3.1? 
What_was_new_in_3_1_	What was new in 3.1? Praat 3.1, 5 December 1995 • Add and remove buttons dynamically. • DataEditor (Inspect button). • Initialization scripts. • Logarithmic axes. • Call remote ADDA server directly. Links to this page What's new? 
What_was_new_in_3_2_	What was new in 3.2? Praat 3.2, 29 April 1996 • Sound I/O for HPUX, Sun Sparc 5, and Sun Sparc LX. • Cross-correlation pitch and HNR analysis. • Facilities for generating tables from scripts. • Editing and playing stylized pitch contours and point processes. • Overlap-add pitch manipulation. • Spectral smoothing techniques: cepstrum and LPC. • Time-domain pitch analysis with jitter measurement. • Read and write Bell-Labs sound files and Kay CSL audio files. • Replaced IpaTimes font by free SILDoulos-IPA font, and embedded phonetic font in PostScript picture. • Completed main phonetic characters. Links to this page What's new? 
What_was_new_in_3_3_	What was new in 3.3? Praat 3.3, 6 October 1996 • Documentation: hypertext help browser, including the first 190 man pages. • New editors: type TextTier for labelling times instead of intervals. • New actions: Formant: Viterbi tracker, Statistics menu, Scatter plot. • Evaluation: For HNR analysis of speech, the cross-correlation method, which has a sensitivity of 60 dB and a typical time resolution of 12 milliseconds, must be considered better than the autocorrelation method, which has a better sensitivity (80 dB), but a much worse time resolution (30 ms). For pitch analysis, the autocorrelation method still beats the cross-correlation method because of its better resistance against noise and echos, and despite its marginally poorer resolution (15 vs. 12 ms). • User preferences are saved across sessions. • The phonetic X screen font included in the source code. • Xwindows resources included in the source code • Graphics: eight colours, small caps, text rotation. • File formats: Sun/NexT mu-law files, raw matrix text files, Xwaves mark files. • Accelerations: keyboard shortcuts, faster dynamic menu, Shift-OK keeps file selector on screen. • Object type changes: StylPitch and MarkTier are now called PitchTier and TextTier, respectively. Old files can still be read. • Script warning: all times in dialogs are in seconds now: milliseconds have gone. Links to this page What's new? 
What_was_new_in_3_5_	What was new in 3.5? Praat 3.5, 27 May 1997 New editors: • TextGridEditor replaces and extends LabelEditor: edit points as well as intervals. • AnalysisEditor replaces and extends PsolaEditor: view pitch, spectrum, formant, and intensity analyses in a single window, and allow pitch and duration resynthesis by overlap-add and more (would be undone in 3.9.19). • SpectrumEditor allows you to view and edit spectra. Praat shell: • History mechanism remembers all the commands that you have chosen, and allows you to put them into a script. • ScriptEditor allows you to edit and run any Praat script, and to put it under a button. • All added and removed buttons are remembered across sessions. • ButtonEditor allows you to make buttons visible or invisible. Evaluations: • In his 1996 doctoral thesis, Henning Reetz compared five pitch analysis routines; Sound: To Pitch (ac)... appeared to make the fewest errors. H. Reetz (1996): Pitch Perception in Speech: a Time Domain Approach, Studies in Language and Language Use 26, IFOTT, Amsterdam (ICG Printing, Dordrecht). Documentation: • 140 more man pages (now 330). • Tables and pictures in manual. • Printing the entire manual. • Logo. New types: • Labelling & segmentation: TextGrid, IntervalTier, TextTier. • Analysis & manipulation: Analysis. • Statistics: TableOfReal, Distributions, Transition File formats: • Read and write rational numbers in text files. • Read 8-bit .au sound files. • Read and write raw 8-bit two's-complement and offset-binary sound files. Audio: • 16-bit interactive Sound I/O on Mac. • Record sounds at 9.8 kHz on SGI. New commands: • Two more pitch-analysis routines. • Sound to PointProcess: collect all maxima, minima, zero crossings. • PointProcess: set calculus. • TextGrid: extract time-point information. • Compute pitch or formants at given time points. • Put pitch, formants etc. in tables en get statistics. • Many more... Macintosh: • 16-bit interactive sound I/O. • Fast and interpolating spectrogram drawing. • Phonetic Mac screen font included in source code (as a fallback to using SIL Doulos IPA). • Keyboard shortcuts, text editor, help under question mark, etc. Links to this page What's new? 
What_was_new_in_3_6_	What was new in 3.6? Praat 3.6, 27 October 1997 Editors: • Intuitive position of B and E buttons on left-handed mice. • SoundEditor: copy windowed selection to list of objects. • SoundEditor: undo Cut, Paste, Zero. • SpectrumEditor: copy band-filtered spectrum or sound to list of objects. • ManipulationEditor: LPC-based pitch manipulation. Objects: • Use '-', and '+' in object names. Phonetics library • LPC-based resynthesis in ManipulationEditor. • Sound: direct modification without formulas (addition, multiplication, windowing) • Sound: filtering in spectral domain by formula. • Create a simple Pitch object from a PitchTier (for F0) and a Pitch (for V/U). • Semitones in PitchTier tables. • PointProcess: transplant time domain from Sound. • Much more... Phonology library • Computational Optimality Theory. See OT learning. Hypertext • You can use ManPages files for creating your own tutorials. These contains buttons for playing and recording sounds, so you can use this for creating an interactive IPA sound training course. Scripting: • Programmable Praat script language: variables, expressions, control structures, procedures, complete dialog box, exchange of information with Info window, continuation lines. • Use platform-independent relative file paths in Praat script. • ScriptEditor: Run selection. Graphics: • Rotation and scaling while printing the Picture window. • Apart from bold and italic, now also bold-italic (see Text styles). • Rounded rectangles. • Conversion of millimetres and world coordinates. • Measurement of text widths (screen and PostScript). Unix: • Use the sendpraat program for sending messages to running Praat programs. Mac: • Praat looks best with the new and beautiful System 8. Links to this page What's new? 
What_was_new_in_3_7_	What was new in 3.7? Praat 3.7, 24 March 1998 Editors: • In all FunctionEditors: drag to get a selection. Phonetics library: • Many new query (Get) commands for Sound, Intensity, Harmonicity, Pitch, Formant, Ltas, PitchTier, IntensityTier, DurationTier, FormantTier. • Many new modification commands. • Many new interpolations. • Sound enhancements: Sound: Lengthen (overlap-add)..., Sound: Deepen band modulation... • Source-filter synthesis tutorial, Sound & IntensityTier: Multiply, Sound & FormantTier: Filter, Formant: Formula (frequencies)..., Sound: Pre-emphasize (in-line).... Labelling • TextGrid queries (Get times and labels in a script). • TextGrid: Count labels.... • PointProcess: To TextGrid (vuv)...: get voiced/unvoiced information from a point process. • IntervalTier to TableOfReal: labels become row labels. • TextTier to TableOfReal. Numerics and statistics library • Multidimensional scaling (Kruskal, INDSCAL, etc). • TableOfReal: Set value, Formula, Remove column, Insert column, Draw as squares, To Matrix. Phonology library • OT learning: new strategies: weighted symmetric plasticity (uncancelled or all). Praat shell • First Linux version. • Eight new functions like e.g. hertzToBark in Formulas 4. Mathematical functions. • Praat script: procedure arguments; object names. Documentation: • 230 more man pages (now 630). • Hypertext: increased readability of formulas, navigation with keyboard. Links to this page What's new? 
What_was_new_in_3_8_	What was new in 3.8? Praat 3.8, 12 January 1999 Phonetics library • New objects: LongSound (view and label long sound files), with editor; PairDistribution. • Overlap-add manipulation of voiceless intervals, version 2: quality much better now; target duration is exactly as expected from Duration tier or specified lengthening in Sound: Lengthen (overlap-add).... • Audio: Escape key stops audio playing (on Mac also Command-period). • SoundRecorder: allows multiple recordings without close; Play button; Write buttons; buffer size can be set. • Reverse a Sound or a selection of a Sound. • Sound: Get nearest zero crossing.... • Formant: Scatter plot (reversed axes).... • TextGrid & Pitch: Speckle separately.... • Extract Sound selection (preserve times) in TextGridEditor. • More query commands for Matrix, TableOfReal, Spectrum, PointProcess. Phonology library • 25-page OT learning tutorial. • Made the OT learner 14 times as fast. Platforms • May 23: Windows beta version. • April 24: Windows alpha version. Files • Read more Kay, Sun (.au), and WAV sound files. • Read Strings from raw text file... • Create Strings as file list.... • Read IntervalTier from Xwaves... • hidden Read from old Windows Praat picture file... Graphics • Use colours (instead of only greys) in Paint ellipse... etc. • More true colours (maroon, lime, navy, teal, purple, olive). • Direct printing from Macintosh to PostScript printers. • Hyperpage printing to PostScript printers and PostScript files. • Phonetic symbols: raising sign, lowering sign, script g, corner, ligature, pointing finger. Shell • November 4: all dialogs are modeless (which is new for Unix and Mac). • September 27: sendpraat for Windows. Scripting • January 7: scriptable editors. • October 7: file I/O in scripts. • August 23: script language includes all the important functions for string handling. • June 24: string variables in scripts. • June 22: faster look-up of script variables. • June 22: unlimited number of script variables. • April 5: suspended chopping of trailing spaces. • March 29: enabled formulas as arguments to dialogs (also interactive). Links to this page What's new? 
What_was_new_in_3_9_	What was new in 3.9? Praat 3.9, 18 October 2000 Editors: • Shift-click and shift-drag extend or shrink selection in editor windows. • Grouped editors can have separate zooming and scrolling (FunctionEditor preferences). • Cursor follows playing sound in editors; interruption by Escape key moves the cursor. • TextGridEditor: optimized for transcribing large corpora: text field, directly movable boundaries, more visible text in tiers, SpellingChecker, type while the sound is playing, complete keyboard navigation, control font size, control text alignment, shift-click near boundary adds interval to selection. • Stereo display in LongSound and TextGrid editors. • LongSoundEditor and TextGridEditor: write selection to audio file. • SoundEditor: added command Extract selection (preserve times). • IntervalTierEditor, DurationTierEditor. • Added many query commands in editors. Phonetics library: • Sound: To Formant...: sample-rate-independent formant analysis. • Sound: To Harmonicity (glottal-to-noise excitation ratio). • Pitch: support for ERB units, draw all combinations of line/speckle and linear/logarithmic/semitones/mels/erbs, optionally with TextGrid, Subtract linear fit. • Spectrum: Draw along logarithmic frequency axis. • TextGrid: modification commands, Extract part, Shift to zero, Scale times (with Sound or LongSound). • Matrix: To TableOfReal, Draw contour... • Concatenate Sound and LongSound objects. • File formats: save PitchTier in spreadsheet format, read CGN syntax files (XML version), text files now completely file-server-safe (independent from Windows/Macintosh/Unix line separators). Statistics and numerics library: • Principal component analysis. • Discriminant analysis. • Polynomial: drawing, root finding etc. • TableOfReal: Draw box plots.... • Covariance: To TableOfReal (random sampling).... • SSCP: Get sigma ellipse area.... • Query DTW for 'weighted distance' of time warp. • Distributions: To Strings (exact)... • Strings: Randomize. Phonology library: • OTGrammar: To PairDistribution. Graphics: • Full support for colour inkjet printers on Windows and Macintosh. • Full support for high-resolution colour clipboards and metafiles for Windows and Macintosh programs that support them (this include MS Word for Windows, but unfortunately not MS Word for Macintosh). • Colour in EPS files. • Interpolating grey images, i.e. better zoomed spectrograms. • Linux: support for 24-bits screens. Audio: • Asynchronous sound play. • Linux: solved problems with /dev/mixer (Cannot read MIC gain.) on many computers. • Added possibility of zero padding for sound playing, in order to reduce clicks on some Linux and Sun computers. • LongSound supports mono and stereo, 8-bit and 16-bit, μ-law and A-law, big-endian and little-endian, AIFC, WAV, NeXT/Sun, and NIST files. • Read two Sounds from stereo file... supports 8-bit and 16-bit, μ-law and A-law, big-endian and little-endian, AIFC, WAV, NeXT/Sun, and NIST files. • SoundRecorder writes to 16-bit AIFC, WAV, NeXT/Sun, and NIST mono and stereo files. • Sound & LongSound: write part or whole to mono or stereo audio file. • Read Sound from raw Alaw file. • Artword & Speaker (& Sound) movie: real time on all platforms. Scripting: • Formulas 4. Mathematical functions: added statistical functions: χ2, Student T, Fisher F, binomial, and their inverse functions. • Windows: program praatcon for use as a Unix-style console application. • Windows and Unix: Praat can be run with a command-line interface without quitting on errors. • Unix & Windows: can use <stdout> as a file name (supports pipes for binary data). • sendpraat now also for Macintosh. • sendsocket. • Read from file... recognizes script files if they begin with #!. • Script links in ManPages. Documentation • Tutorials on all subjects available through Intro. Links to this page What's new? 
What_was_new_in_4_0_	What was new in 4.0? Praat 4.0, 15 October 2001 Editors: • Simplified selection and cursor in editor windows. • Spectrogram, pitch contour, formant contour, and intensity available in the Sound, LongSound, and TextGrid editors. • TextGrid editor: additions and improvements. • Log files. Phonetics library: • ExperimentMFC: multiple-forced-choice listening experiments. • Sound: To Pitch (ac)...: pitch contour less dependent on time resolution. This improves the constancy of the contours in the editors when zooming. • TextGrid: additions and improvements. • Sounds: Concatenate recoverably. Creates a TextGrid whose interval labels are the original names of the sounds. • Sound & TextGrid: Extract all intervals. The reverse of the previous command. • Filterbank analyses, MelFilter, BarkFilter and FormantFilter, by band filtering in the frequency domain. • Cepstrum by David Weenink: MFCC, LFCC. Cepstrum object is a representation of the complex cepstrum. • Intensity: To IntensityTier (peaks, valleys). • Replaced Analysis and AnalysisEditor with Manipulation and ManipulationEditor. Phonology library: • PairDistribution: Get percentage correct (maximum likelihood, probability matching). • OTGrammar & PairDistribution: Get percentage correct... Graphics: • Improved spectrogram drawing. • Special symbols: háček. • Macintosh: improved screen rendition of rotated text. Audio: • Macintosh: support for multiple audio input devices (sound cards). Statistics and numerics library: • More statistics by David Weenink. • Improved random numbers and other numerical stuff. • Regular expressions. Scripting: • Formatting in variable substitution, e.g. 'pitch:2' gives two digits after the decimal point. • Added fixed$ to scripting language for formatting of numbers. Documentation: • Multidimensional scaling tutorial. • Enabled debugging-at-a-distance. Links to this page What's new? 
What_was_new_in_4_1_	What was new in 4.1? Praat 4.1, 5 June 2003 General: • MacOS X edition. • Removed licensing. • More than 99 percent of the source code distributed under the General Public Licence. • Windows 2000 and XP: put preferences files in home directory. Phonetics: • Spectrum: the sign of the Fourier transform has changed, to comply with common use in technology and physics. Old Spectrum files are converted when read. • Spectral moments. • Many jitter and shimmer measures, also in the Sound editor window. • PitchTier: shift or multiply frequencies (also in ManipulationEditor). • TextGrid: shift times, scale times. • Overlap-add synthesis: reduced buzz in voiceless parts. • Sound: Change gender... • Editors: Intro 3.6. Viewing a spectral slice. • Editors: Get spectral power at cursor cross. • Sound: To PointProcess (periodic, peaks)... • Ltas: merge. Listening experiments: • Goodness judgments. • Multiple ResultsMFC: To Table, so that the whole experiment can go into a single statistics file. • Stimulus file path can be relative to directory of experiment file. • ExperimentMFC: multiple substimuli for discrimination tests. Statistics: • New Table object for column statistics: Pearson's r, Kendall's τ-b, t-test. • Table: scatter plot. • Table: column names as variables. • T-test. • TableOfReal: Extract rows where column... • TableOfReal: Get correlation.... • Correlation: Confidence intervals... • SSCP: Get diagonality (bartlett)... OT learning: • Tutorial for bidirectional learning. • Random choice between equally violating candidates. • More constraints in metrics grammar. • Learning in editor. Graphics: • Printing: hard-coded image interpolation for EPS files and PostScript printers. Scripting: • New Formulas tutorial. • Formulas: can use variables without quotes. • Formulas for PitchTier, IntensityTier, AmplitudeTier, DurationTier. • Refer to any matrices and tables in formulas, e.g. Sound_hello (x) or Table_everything [row, col] or Table_tokens [i, F1]. • Assignment by modification, as with += -= *= /=. • New functions: date$(), extractNumber, extractWord$, extractLine$. See Formulas 5. String functions. • Scripting 5.7. Including other scripts. • String formulas in the calculator. • Stopped support of things that had been undocumented for the last four years: let, getnumber, getstring, ARGS, copy, proc, variables with capitals, and strings in numeric variables; there are messages about how to modify your old scripts. • Disallowed ambiguous expressions like -3^2. Links to this page What's new? 
What_was_new_in_4_2_	What was new in 4.2? Praat 4.2, 4 March 2004 General: • July 10, 2003: Open source code (General Public Licence). Phonetics: • Faster computation of spectrum, spectrogram, and pitch. • More precision in numeric libraries. • PitchTier: Interpolate quadratically. • TextGrids can be saved chronologically (and Praat can read that file again). • Sound editor window Time step settings...: Automatic, Fixed, and View-dependent. • Sound window: distinguish basic from advanced spectrogram and pitch settings. • Read TableOfReal from headerless spreadsheet file...: cells with strings are considered zero. • Sound window: introduced time step as advanced setting. • Sound window: reintroduced view range as advanced setting. • Ltas: Compute trend line, Subtract trend line. Audio: • Sun workstations: support audio servers. Graphics: • Better selections in Picture window and editor windows. • Picture window: better handling of rectangles and ellipses for reversed axes. • Windows: corrected positioning of pictures on clipboard and in metafiles. • Windows: EPS files check availability of Times and TimesNewRomanPSMT. • Polygon: can now also paint in colour instead of only in grey values. • Unlimited number of points for polygons in PostScript (may not work on very old printers). • Picture window: line widths on all printers and clipboards are now equal to line widths used on PostScript printers: a line with a line width of 1 will be drawn with a width 3/8 points. This improves the looks of pictures printed on non-PostScript printers, improves the looks of pictures copied to your wordprocessor when printed, and changes the looks of pictures copied to your presentation program. OT learning: • Metrics grammar supports 'impoverished overt forms', i.e. without secondary stress even if surface structures do have secondary stress. • Support for crucially tied constraints and tied candidates. • Support for backtracking in EDCD. • Queries for testing grammaticality. Scripting: • ManPages: script links can receive arguments. • ManPages: variable duration of recording. • Support for unlimited size of script files in editor window on Windows XP and MacOS X (the Unix editions already had this). • Improved the reception of sendpraat commands on Windows XP. Links to this page What's new? 
What_was_new_in_4_3_	What was new in 4.3? Praat 4.3, 26 January 2005 General: • `Apply' button in settings windows for menu commands and in script forms. • Info window can be saved. • Removed 30,000-character limit in Info window. Phonetics: • Speeded up intensity analysis by a factor of 10 (by making its time resolution 0.01 ms rather than 0.0001 ms at a sampling frequency of 44 kHz). • Speeded up pitch analysis and spectrogram analysis by a factor of two. • Sound: To Spectrum... now has a reasonably fast non-FFT version. • Calibrated long-term average spectrum (Sound: To Ltas...). • Pitch-corrected LTAS analysis. • Sound: Scale intensity. • PitchTier: To Sound (sine). • Better warnings against use of the LPC object. Voice: • July 9, 2004 (4.2.08): Shimmer measurements: more accurate and less sensitive to additive noise. • More extensive voice report: pitch statistics; harmonicity. Audio: • Reading and opening 24-bit and 32-bit sound files (saving still goes in 16 bits). • LongSound: save separate channels. • Macintosh: much faster reading of WAV files. Listening experiments: • Subjects can now respond with keyboard presses. Graphics: • One can now drag the inner viewport in the Picture window, excluding the margins. This is nice e.g. for creating square viewports or for drawing a waveform and a spectrogram in close contact. • Unix: picture highlighting as on Mac and Windows. • More drawing methods for Sound and Ltas (curve, bars, poles, speckles). OT learning: • Monitor rankings when learning. • OTGrammar: Remove harmonically bounded candidates... • OTGrammar: Save as headerless spreadsheet file... • Metrics grammar: added *Clash, *Lapse, WeightByPosition and *MoraicConsonant. Scripting: • nowarn, noprogress, nocheck. • Line numbers. Links to this page What's new? 
What_was_new_in_4_4_	What was new in 4.4? 4.4 (19 December 2005) 4.3.37 (15 December 2005) • Principal component analysis: now accepts tables with more variables (columns) than cases (rows). • TIMIT label files: removed a bug that caused Praat to crash for files whose first part was not labelled. 4.3.36 (11 December 2005) • Ltas: Average. • Optimality Theory: compute crucial rankings (select OTGrammar + PairDistribution). 4.3.35 (8 December 2005) • ExperimentMFC: switched off warnings for stereo files. 4.3.34 (8 December 2005) • Sound window: the arrow scroll step is settable. • You can now run multiple listening experiments (ExperimentMFC) in one Run. • Formant: Get quantile of bandwidth... 4.3.33 (6 December 2005) • Removed three bugs introduced in 4.3.32 in ExperimentMFC. 4.3.32 (5 December 2005) • Many more possibilities in ExperimentMFC. 4.3.31 (27 November 2005) • Sound: To Ltas (pitch-corrected)... 4.3.30 (18 November 2005) • TableOfReal: Scatter plot: allows reversed axes. 4.3.29 (11 November 2005) • Windows: many more font sizes. 4.3.28 (7 November 2005) • Fontless EPS files: corrected character width for Symbol font (depended on SILIPA setting). • Windows: more reliable detection of home directory. 4.3.27 (7 October 2005) • TextGrid & Pitch: draw with text alignment. 4.3.26 (29 September 2005) • Macintosh: corrected error introduced in 4.3.25. 4.3.25 (28 September 2005) • Macintosh: allowed recording with sample rates of 12 and 64 kHz. 4.3.24 (26 September 2005) • Table: Down to TableOfReal...: one column of the Table can be used as the row labels for the TableOfReal, and the strings in the remaining columns of the Table are replaced with whole numbers assigned in alphabetical order. 4.3.23 (24 September 2005) • Read Table from comma-separated file... • Read Table from tab-separated file... • Write picture as fontless EPS file: choice between XIPA and SILIPA93. • Bold IPA symbols in EPS files (fontless SILIPA93 only). 4.3.22 (8 September 2005) • Macintosh: variable scroll bar size (finally, 7 years since System 8.5). 4.3.21 (1 September 2005) • Macintosh: error message if any of the fonts Times, Helvetica, Courier and Symbol are unavailable at start-up. • Renamed Control menu to Praat on all platforms (as on the Mac), to reflect the fact that no other programs than Praat have used the Praat shell for five years. • Script editor: Undo and Redo buttons (only on the Mac for now). • Manual: corrected a bug that sometimes caused Praat to crash when trying to print. 4.3.20 (18 August 2005) • Log files: include name of editor window. 4.3.19 (20 July 2005) • Improved buttons in manual. • TableOfReal: Read from headerless spreadsheet file: allow row and column labels to be 30,000 rather than 100 characters. 4.3.18 (12 July 2005) • Glottal source for sound synthesis, corrected and documented. 4.3.17 (7 July 2005) • Glottal source for sound synthesis. • Multi-level Optimality Theory: parallel evaluation and bidirectional learning. 4.3.16 (22 June 2005) • Pitch drawing: corrected logarithmic scales. 4.3.15 (22 June 2005) • Graphics: better dotted lines in pitch contours; clipped pitch curves in editor windows. • Pitch analysis: more different units (semitones re 1 Hz). 4.3.14 (14 June 2005) • Scripting: regular expressions. • Removed a bug that caused Praat to crash if a proposed object name was longer than 200 characters. 4.3.13 (19 May 2005) • Macintosh: an option to switch off screen previews in EPS files. • Sources: compatibility of makefiles with MinGW (Minimalist GNU for Windows). 4.3.12 (10 May 2005) • Some more manual tricks. 4.3.11 (6 May 2005) • TextGrid editor: show number of intervals. 4.3.10 (25 April 2005) • Table: Get logistic regression. 4.3.08 (19 April 2005) • OT learning: store history with OTGrammar & Strings: Learn from partial outputs.... 4.3.07 (31 March 2005) • Linux: removed a bug that could cause a sound to stop playing. 4.3.04 (9 March 2005) • Use SIL Doulos IPA 1993/1996 instead of 1989. 4.3.03 (2 March 2005) • TextGrid window: green colouring of matching text. • Regular expressions can be used in many places. • Pitch analysis: switched off formant-pulling. 4.3.02 (16 February 2005) • TextGrid: Remove boundary at time... • Scripting: corrected nowarn. • Linux: guard against blocking audio device. • Macintosh: guard against out-of-range audio level meter. 4.3.01 (9 February 2005) • Replaced PostScript font SILDoulosIPA with XIPA (adapted for Praat by Rafael Laboissière). • Sound: Set part to zero... • Pitch: To Sound (sine)... • Sound & TextGrid: Clone time domain. Links to this page What's new? 
What_was_new_in_4_5_	What was new in 4.5? 4.5 (26 October 2006) 4.4.35 (20 October 2006) • In ManPages you can now draw pictures. 4.4.34 (19 October 2006) • Corrected a bug in the new Sound: To TextGrid (silences).... 4.4.33 (4 October 2006) • Windows: corrected a bug introduced in 4.4.31 that caused Praat to skip the first line of the Buttons file. 4.4.32 (30 September 2006) • Scripting: more techniques for object selection. • Scripting: more support for putting the results of the Info command into a string variable. 4.4.31 (23 September 2006) • Support for plug-ins. • Split between Create Strings as file list... and Create Strings as directory list.... 4.4.30 (28 August 2006) • Table: Draw ellipse (standard deviation)... 4.4.29 (21 August 2006) • Allowed European symbols in file names and object names. 4.4.28 (10 August 2006) • Windows XP: Praat files can finally again be opened by double-clicking and by dragging them onto the Praat icon. • Scripting (Windows): removed a bug that caused Praat to crash if the script window was closed when a file selector window was open. 4.4.27 (4 August 2006) • Table window: corrected vertical scroll bar (on Windows). • Formulas: invSigmoid. • Logging: added 'power' (and documented the 'freq' command). • Removed a bug that caused Read two Sounds from stereo file... not to work in scripts. 4.4.26 (24 July 2006) • Sound & FormantTier: Filter: much more accurate. 4.4.25 (16 July 2006) • TextGrid reading: don't set first boundary to zero for .wrd label files. 4.4.24 (19 June 2006) • Scripting: regular expressions allow replacement with empty string. 4.4.23 (1 June 2006) • Table: ignore more white space. 4.4.22 (30 May 2006) • Scripting: replacing with regular expression. See Formulas 5. String functions. 4.4.21 (29 May 2006) • Made Manipulation objects readable again. 4.4.20 (3 May 2006) • Removed limit on number of menus (Praat could crash if the number of open windows was high). 4.4.19 (28 April 2006) • Table: Get mean, Get standard deviation, Get quantile. 4.4.18 (24 April 2006) • Table: View & Edit: view the contents of a table. • Table: Scatter plot. • Scripting: more warnings against missing or extra spaces. 4.4.17 (19 April 2006) • Table: Pool: computing averages and medians of dependent variables for a selected combination of independent variables. • Table: Formula accepts string expressions as well as numeric expressions. • Table: Sort can sort by any number of columns. • Table: Create with column names. • Table: Report mean. • Formulas: row\$ and col\$ attributes. • Warning when trying to read data files whose format is newer than the Praat version. 4.4.16 (1 April 2006) • Spectrum window: dynamic range setting. • SoundRecorder: corrected a bug in the Intel Mac edition. 4.4.15 (30 March 2006) • Source code even more compatible with 64-bit compilers. 4.4.14 (29 March 2006) • Source code more compatible with 64-bit compilers. 4.4.13 (8 March 2006) • Table To TableOfReal: better handling of --undefined-- values (are now numeric). • MacOS X: TextGrid files can be double-clicked to open. • Create Strings as file list...: now handles up to 1,000,000 files per directory. 4.4.12 (24 February 2006) • TextGrid: removed a bug introduced in 4.4.10 that caused Praat to crash when converting an IntervalTier into a TextGrid. 4.4.11 (23 February 2006) • Listening experiments: removed a bug that could cause Praat to crash when an ExperimentMFC object was removed. 4.4.10 (20 February 2006) • Intel computers: corrected reading and writing of 24-bit sound files (error introduced in 4.4.09). • Create TextGrid: guard against zero tiers. • MacOS X: correct visibility of Praat icon. • MacOS X: correct dropping of Praat files on Praat icon. 4.4.09 (19 February 2006) • Macintosh: first Intel Macintosh version. • Windows: Create Strings from directory list... 4.4.08 (6 February 2006) • Much improved cepstral smoothing. 4.4.07 (2 February 2006) • More scripting facilities (local variables in procedures, e.g. .x and .text$). • Faster formulas. 4.4.06 (30 January 2006) • More scripting facilities (Object_xxx [ ], Self.nx, Table_xxx$ [ ], better messages). • Better reading and writing of Xwaves label files. 4.4.05 (26 January 2006) • ExperimentMFC: removed a bug that caused Praat to crash when the Oops button was pressed after the experiment finished. • TextGrid: an IntervalTier can be written to an Xwaves label file. 4.4.04 (6 January 2006) • Windows: Quicktime support (see at 4.4.03). 4.4.03 (6 January 2006) • Macintosh: Quicktime support, i.e., Read from file can now read the audio from several kinds of movie files (.mov, .avi). 4.4.02 (5 January 2006) • OT learning: allow the decision strategies of Harmonic Grammar and Linear OT. 4.4.01 (2 January 2006) • Picture window: Logarithmic marks allows reversed axes. • Manipulation window: removed a bug from Shift frequencies that caused much too small shifts in semitones. • TextGrid: Remove point.... Links to this page What's new? 
What_was_new_in_4_6_	What was new in 4.6? 4.6 (12 May 2007) 4.5.26 (8 May 2007) • Sound files: reading FLAC audio files (implemented by Erez Volk). 4.5.25 (7 May 2007) • Table: Rows to columns... • Table: Collapse rows... (renamed from Pool). • Table: Formula (column range)... • OT learning: OTGrammar window shows harmonies. 4.5.24 (27 April 2007) • OT learning: added decision strategy MaximumEntropy; this has the same harmony determination method as Harmonic Grammar (include the additive constraint noise), but there is some more variability, in that every candidate gets a relative probability of exp(harmony). 4.5.23 (26 April 2007) • Macintosh: much smaller sizes (in kilobytes) of spectrograms for printing and clipboard; this improves the compatibility with other programs such as Microsoft Word for large spectrograms. 4.5.22 (25 April 2007) • Macintosh: improved drawing of spectrograms for printing and clipboard (this was crippled in 4.5.18, but now it is better than before 4.5.18). 4.5.21 (24 April 2007) • OT learning: corrected HarmonicGrammar (and LinearOT) learning procedure to the stochastic gradient ascent method applied by Jäger (2003) to MaxEnt grammars. • Scripting: removed a bug that could make selection checking (in command windows) unreliable after a script was run. 4.5.20 (19 April 2007) • Scripting: allow assignments like pitch = To Pitch... 0 75 600. • PitchTier Formula: guard against undefined values. 4.5.19 (2 April 2007) • Scripting: allow comments with # and ; in forms. • Windows audio playing: attempt at more compatibility with Vista. 4.5.18 (30 March 2007) • Macintosh: better image drawing (more grey values). • More tabulation commands. • More SpectrumTier commands. • Picture window: keyboard shortcut for Erase all. 4.5.17 (19 March 2007) • Picture window: can change arrow size. • Several List commands. • Spectrum: To SpectrumTier (peaks). 4.5.16 (22 February 2007) • Sound-to-Intensity: made resistant against undefined settings. • Windows: made Ctrl-. available as a shortcut. • Linux: made it more likely to find the correct fonts. 4.5.15 (12 February 2007) • Windows XP: worked around a bug in Windows XP that could cause Praat to crash when the user moved the mouse pointer over a file in the Desktop in the file selector. The workaround is to temporarily disable file info tips when the file selector window is on the screen. 4.5.14 (5 February 2007) • Scripting: some new predefined string variables like preferencesDirectory$. 4.5.13 (3 February 2007) • For stereo sounds, pitch analysis is based on correlations pooled over channels (rather than on correlations of the channel average). • For stereo sounds, spectrogram analysis is based on power density averaged across channels (rather than on the power density of the channel average). • Scripting: removed a bug introduced in 4.5.06 that caused some variables not to be substituted. 4.5.12 (30 January 2007) • Made cross-correlation pitch analysis as fast as it used to be before 4.5.11. 4.5.11 (29 January 2007) • Sound objects can be stereo, for better playback quality (most analyses will work on the averaged mono signal). • Macintosh: recording a sound now uses CoreAudio instead of SoundManager, for more compatibility with modern recording devices, and the possibility to record with a sampling frequency of 96 kHz. • ManPages allow picture scripts with separate object lists. • Linux: better scroll bars in object list for Lesstif (Debian). • Linux: made Create Strings as file list... work on Reiser. • sendpraat scripts correctly wait until sounds have played. 4.5.08 (20 December 2006) • ExperimentMFC: can use stereo sounds. 4.5.07 (16 December 2006) • Macintosh: playing a sound now uses CoreAudio instead of SoundManager. • Phonetic symbols: ˈprimary stress and ˈseconˌdary stress. 4.5.06 (13 December 2006) • Support for 32-bit floating-point WAV files. • Scripting: removed several kinds of restrictions on string length. • SSCP: Draw confidence ellipse: corrected a bug that would sometimes not draw the ellipse when N was very large. 4.5.05 (5 December 2006) • Macintosh scripting: European symbols such as ö and é and ç are now allowed in file names in scripts and in MacRoman-encoded file names sent by other programs through the sendpraat subroutine. 4.5.04 (1 December 2006) • Sound: Change gender...: corrected a bug that often caused a female-to-male conversion to sound monotonous. 4.5.03 (29 November 2006) • Table: added independent-samples t-test. • Linux: corrected a bug introduced in 4.5.02 that prevented sounds from playing and other weird things. 4.5.02 (16 November 2006) • Corrected yet another bug in the new Sound: To TextGrid (silences).... 4.5.01 (28 October 2006) • Sound window: the pitch drawing method is Curves, Speckles, or Automatic. • Corrected another bug in the new Sound: To TextGrid (silences).... Links to this page What's new? 
What_was_new_in_5_0_	What was new in 5.0? 5.0 (10 December 2007) • Corrected many bugs. • Display font sizes in points rather than pixels. 4.6.41 (9 December 2007) • Windows: corrected a bug that could cause listening experiments not to run when the directory path included non-ASCII characters; the same bug could (under comparable circumstances) cause scripted menu commands not to work. • Corrected a bug that could cause null bytes in data files when the text output encoding preference was try ISO Latin-1, then UTF-16. 4.6.40 (3 December 2007) • Corrected some minor bugs. 4.6.39 (1 December 2007) • Manual: corrected a bug that could cause Praat to crash when viewing certain manual pages with pictures. • Scripting: corrected a bug that could cause Praat to crash when a long string was used as an argument to a procedure. 4.6.38 (19 November 2007) • More extensive logistic regression. 4.6.37 (15 November 2007) • Object list shows numbers. • Macintosh: corrected saving of non-ASCII text settings. 4.6.36 (2 November 2007) • Sound and TextGrid windows: direct drawing of intensity, formants, pulses, and TextGrid. • Regular expressions: corrected handling of newlines on Windows. • Scripting: improved positioning of settings windows for script commands in editors on Windows. 4.6.35 (22 October 2007) • Windows and Linux: better positioning of form windows of editor scripts. • Macintosh: OTMulti learning window more compatible with non-ASCII characters. 4.6.34 (18 October 2007) • Corrected a bug introduced in September that could cause Praat to crash when starting up if the user had explicitly made action commands visible or invisible in an earlier session. 4.6.33 (16 October 2007) • Corrected a bug introduced in September that caused Praat to crash when a PointProcess window was opened without a Sound. • Macintosh: objects with non-ASCII names show up correctly in the list. 4.6.32 (14 October 2007) • Unicode support for names of objects. • Linux: first Unicode support (in window titles). • Windows scripting: corrected a bug that caused weird characters in Paste History. 4.6.31 (8 October 2007) • TextGrid window: made Save command available again for TextGrid windows without a sound. • Corrected a bug that caused binary Collection files with objects with names with non-ASCII characters to be unreadable. 4.6.30 (3 October 2007) • OTMulti: added an evaluate command in the Objects window, so that paced learning becomes scriptable. • Macintosh: worked around a feature of a system library that could cause Praat to crash when reading a Collection text file that contained objects with non-ASCII names. 4.6.29 (1 October 2007) • OT learning: leak and constraint in OTMulti. • Support for saving Table, TableOfReal, Strings, OTGrammar and OTMulti in Unicode. 4.6.28 (1 October 2007) • OT learning: positive constraint satisfactions in OTMulti tableaus. • Corrected a bug that could cause Praat to crash when reading a non-UTF-8 text file when the Text reading preference had been set to UTF-8. 4.6.27 (29 September 2007) • Corrected redrawing of text with non-ASCII characters. 4.6.26 (29 September 2007) • Corrected reading of high UTF-8 codes. 4.6.25 (26 September 2007) • ExperimentMFC: can set font size for response buttons. 4.6.24 (24 September 2007) • Czech, Polish, Croatian, and Hungarian characters such as č ů ť ę ś ł ć ő (see Special symbols). • Some support for Hebrew characters such as א ב וּ (see Special symbols). 4.6.23 (22 September 2007) • Corrected a bug introduced in 4.6.13 that caused crashes in text handling (mainly on Linux). • Info commands in editors. 4.6.22 (17 September 2007) • Phonetic symbols: added the nonsyllabicity diacritic (a̯). • Macintosh: worked around a feature of a system library that could cause strange behaviour of forms in scripts with non-ASCII characters. 4.6.21 (5 September 2007) • Sound and TextGrid windows: direct drawing of selected sound to the picture window. 4.6.20 (2 September 2007) • Introduced direct drawing of spectrogram and pitch to the Praat picture window from Sound windows and TextGrid windows. • Corrected a bug introduced in 4.6.13 by which Inspect did not show all data in a TextGrid. 4.6.19 (31 August 2007) • Macintosh: worked around a bug in a system library that caused Praat to crash (since version 4.6.13) when removing a boundary from a TextGrid interval in MacOS X 10.3 or earlier. 4.6.18 (28 August 2007) • Sound: Filter (formula): now works in the same way as the other filter commands (without adding an empty space at the end), and on stereo sounds. 4.6.17 (25 August 2007) • Windows: improved rotated text, also for copy-paste and printing. • Windows: phonetic characters on the screen now require the Charis SIL or Doulos SIL font. • Picture settings report (mainly for script writers). • Corrected a bug that could cause Praat to crash when closing a manual page that had been read from a file. 4.6.16 (22 August 2007) • Macintosh: corrected a bug introduced in 4.6.13 that could cause Praat to crash when drawing a spectrogram in MacOS X 10.3 or earlier. 4.6.15 (21 August 2007) • Corrected a bug introduced in 4.6.14 that prevented the use of Helvetica in the Picture window. • Corrected a bug in Read Table from table file..., introduced in 4.6.13. 4.6.14 (20 August 2007) • Corrected a bug introduced in 4.6.13 that prevented any other font than Palatino in the Picture window. • Macintosh: corrected height of subscripts and superscripts (broken in 4.6.13). 4.6.13 (16 August 2007) • TextGrid: corrected reading of chronological files. • Macintosh: text looks better (and rotated text is now readable on Intel Macs). • Macintosh: phonetic characters on the screen now require the Charis SIL or Doulos SIL font. 4.6.12 (27 July 2007) • OTGrammar bug fix: leak and constraint plasticity correctly written into OTGrammar text files. 4.6.11 (25 July 2007) • OTGrammar: introduced constraint plasticity for slowing down or halting the speed with which constraints are reranked. • OTGrammar: introduced leak for implementing forgetful learning of correlations. • OTGrammar: positive constraint satisfactions are drawn as `+' in tableaus. 4.6.10 (22 July 2007) • Improved reading of UTF-16 data files. • Improved error messages when reading text files (line numbers are mentioned). • Table: Get group mean (Student t)... 4.6.09 (24 June 2007) • Corrected a bug introduced in 4.6.07 that caused a crash when reading Collections. • Corrected a bug introduced in 4.6.07 that caused incorrect Open buttons in Inspect. • How come 4.6.07 introduced those bugs? Because of large changes in the Praat source code as a result of the transition to Unicode. 4.6.08 (22 June 2007) • Windows: worked around a `feature' of the C library that caused 3-byte line-breaks in the buttons file. • Windows: returned to smaller font in script window. • OT learning: corrected a bug in PositiveHG. 4.6.07 (20 June 2007) • Sound files: MP3 as LongSound (implemented by Erez Volk). • Scripting: Unicode support for strings and script window (Mac and Windows only). 4.6.06 (4 June 2007) • Script window: corrected a bug introduced in 4.6.05 that could cause incorrect symbols in saved files. 4.6.05 (2 June 2007) • Sound files: reading MP3 audio files (implemented by Erez Volk). 4.6.04 (29 May 2007) • OT learning: added decision strategy PositiveHG. 4.6.03 (24 May 2007) • Spectral slices have better names. 4.6.02 (17 May 2007) • Sound files: saving FLAC audio files (implemented by Erez Volk). 4.6.01 (16 May 2007) • Removed a bug that caused downsampling (and therefore formant measurements) to be incorrect for stereo sounds. Links to this page What's new? 
What_was_new_in_5_1_	What was new in 5.1? 5.1 (31 January 2009) • Editors for Klatt synthesis. • Corrected many bugs. 5.0.47 (21 January 2009) • Extensive pause windows: Scripting 6.6. Controlling the user. 5.0.46 (7 January 2009) • More Klatt synthesizer. • First pause form support. • Renewed CategoriesEditor. • Repaired several memory leaks. 5.0.45 (29 December 2008) • Bug fixes in Klatt synthesizer. 5.0.44 (24 December 2008) • David's Klatt synthesizer: KlattGrid. 5.0.43 (9 December 2008) • Scripting tutorial: local variables in procedures. 5.0.42 (26 November 2008) • Removed a bug that could cause Praat to crash when drawing pictures in the manual window. • Removed a bug that could cause Praat to crash when drawing multi-line text. 5.0.41 (23 November 2008) • ExperimentMFC: allow multiple lines in all texts. • Regular expressions: removed a bug that could cause Praat to hang when using .*. • Table: Draw ellipses: removed a bug that could cause Praat to crash if some cells were undefined. 5.0.40 (10 November 2008) • Improved reading and writing of text files (faster, bigger). 5.0.39 (1 November 2008) • praatcon -a (for sending ANSI encoding when redirected) 5.0.38 (28 October 2008) • FormantGrid: To Formant... 5.0.36 (20 October 2008) • ExperimentMFC: accepts nonstandard sound files. 5.0.35 (5 October 2008) • Scale times by... and Scale times to... (Modify menu). 5.0.34 (22 September 2008) • Shift times by... and Shift times to... (Modify menu). • Sound: Combine to stereo works even if the two mono sounds have different durations or time domains. 5.0.33 (9 September 2008) • Windows: prevented warning messages about Widget type. 5.0.32 (12 August 2008) • Contributed by Ola Söder: kNN classifiers and k-means clustering. • Made UTF-16-encoded chronological TextGrid files readable. 5.0.31 (6 August 2008) • Macintosh: corrected a bug introduced in 5.0.30 that caused Praat to crash when you pressed the Tab key in a window without text fields. 5.0.30 (22 July 2008) • Macintosh and Windows: tab navigation. 5.0.29 (8 July 2008) • OTMulti: can record history. • Picture window: corrected text in Praat picture files. 5.0.28 (3 July 2008) • Windows: audio output uses DirectX (next to Multi-Media Extensions). 5.0.27 (28 June 2008) • Phonetic symbols: breve (ă). • Annotation: improved some SpellingChecker commands. • Table: can now set string values that contain spaces. 5.0.26 (15 June 2008) • Windows: sound recording no longer makes your laptop's fan spin. • Windows: no longer any 64 MB limit on recorded sounds. • Linux: audio input and output uses Alsa (next to OSS). 5.0.25 (31 May 2008) • OT learning: added decision strategy ExponentialMaximumEntropy. 5.0.24 (14 May 2008) • Linux: corrected a bug at start-up. 5.0.23 (9 May 2008) • Corrected a bug that could cause Praat to crash when you edited an Artword that you had read from a file. 5.0.22 (26 April 2008) • Editing formant contours: FormantGrid. 5.0.21 (22 April 2008) • Annotating with Cyrillic, Arabic, Chinese, Korean characters, and many more (on Macintosh and Windows). 5.0.20 (8 April 2008) • ExperimentMFC: prevented the OK key from working if no response (and goodness choice) had been made. • OT learning: sped up learning from partial outputs by a factor of five or more. 5.0.19 (4 April 2008) • TextGrid window: corrected a bug introduced in 5.0.17 that could cause Praat to crash when handling point tiers. 5.0.18 (31 March 2008) • Manipulation window: corrected a bug introduced in 5.0.17 that caused Praat to crash when adding the first duration point. • Sound: added Extract all channels. • OT learning: added OTGrammar & PairDistribution: Find positive weights.... • ExperimentMFC: corrected a bug that caused Praat to crash when the second of multiple experiments referred to non-existing sound files. 5.0.17 (29 March 2008) • Sped up vowel editor by a large factor. • OT learning: corrected Exponential HG update rule from OT-GLA to HG-GLA. • OT learning: shift Exponential HG average constraint weight to zero after every learning step. 5.0.16 (25 March 2008) • Macintosh: returned to old compiler because of incompatibility with MacOS X 10.4. 5.0.15 (21 March 2008) • Windows: more reliable dropping of files on the Praat icon when Praat is already running. 5.0.14 (20 March 2008) • David's vowel editor (New → Sound). • Formulas: corrected scaling of sinc function. 5.0.13 (18 March 2008) • Corrected drawing of histograms. • TextGrid window: selected part of the TextGrid can be extracted and saved. • TextGrid: more complete conversion between backslash trigraphs and Unicode. • Windows: more reliable dropping of files on the Praat icon when Praat is not running yet. • Formulas: sinc function. 5.0.12 (12 March 2008) • Bigger ligature symbol (k͡p). 5.0.11 (7 March 2008) • Corrected saving of new binary Manipulation files (you can send any unreadable Manipulation files to Paul Boersma for correction). 5.0.10 (27 February 2008) • Added the characters đ and Đ. • Windows: made praatcon.exe compatible with Unicode command lines. 5.0.09 (16 February 2008) • Windows: corrected a bug by which Praat would not open files that were dragged on the Praat icon if the names of these files or their directory paths contained non-ASCII characters. • Linux: ignore the Mod2 key, because of its unpredictable assignment. 5.0.08 (10 February 2008) • Corrected the minus sign (\-m = −). 5.0.07 (8 February 2008) • Object IDs are visible in editor windows. 5.0.06 (31 January 2008) • Corrected a bug that caused Find again in the TextGrid window not to work. • Macintosh: made Praat work correctly on 10.3 computers with missing fonts. 5.0.05 (19 January 2008) • All Matrix, Sound, Spectrogram, Pitch, Ltas, and Spectrum objects (and more) are now in 52-bit relative precision (instead of the earlier 23 bits). • Corrected a bug that could lead to Unknown opcode (0) messages when drawing large sounds (more than 16 million samples) in the Picture window. • Macintosh: solved around a bug in the C library that could cause incorrect representation of non-ASCII characters (in the OTGrammar window). 5.0.04 (12 January 2008) • Windows: corrected a bug introduced in 5.0.03 that caused Praat to crash if you pressed a key in the Sound window. • Macintosh: some cosmetic corrections. 5.0.03 (9 January 2008) • Scripting: guard against opening the same file more than once. • Table: possibility of regarding a column as a distribution (Generate menu). • Macintosh: corrected line colours. 5.0.02 (27 December 2007) • TextGrid window: corrected the drawing of numbers to the right of the tiers. • Corrected a bug that caused Praat to crash when doing SpectrumTier: List. 5.0.01 (18 December 2007) • Corrected a bug that could cause Praat to crash when redrawing the sound or TextGrid window. Links to this page What's new? 
What_was_new_in_5_2_	What was new in 5.2? 5.2 (29 October 2010) 5.1.45 (26 October 2010) • Linux/GTK: allow Praat to run without an X display. • Sounds are played synchronously in scripts run from ManPages with \SC. 5.1.44 (4 October 2010) • Linux/GTK: visibility of ExperimentMFC window. • Linux/GTK: keyboard shortcuts. 5.1.43 (4 August 2010) • Scripting: support for stand-alone programs; see Scripting 9.1. Turning a script into a stand-alone program. • Table: allow drawing of ellipses even if irrelevant columns contain undefined data. • Linux/GTK: correct resizing of Table window. • Linux/GTK: prevented multiple storing of Picture window selection in scripting history. 5.1.42 (26 July 2010) • Scripting: allow file selector windows; see Scripting 6.6. Controlling the user. • Linux: multiple file selection. 5.1.41 (15 July 2010) • OTGrammar: Compare candidates... • GTK: support for the Doulos SIL and Charis SIL fonts. • GTK: working vowel editor. • Vowel editor: repaired memory leak. 5.1.40 (13 July 2010) • GTK: working Demo window (drawing, clicks, keys). • GTK: pause forms. • GTK: manual pages: receive a white background, for compatibility with dark-background themes. • GTK: in settings windows, better alignment of labels to radio groups. • GTK: rotated text. 5.1.39 (10 July 2010) • GTK beta version. • Linux: made Sound: Record fixed time... work correctly (the sampling frequency was wrong). • GTK: list of objects: multiple selection, working Rename button. • GTK: running a script no longer deselects all objects at the start. • GTK: working Buttons editor. • GTK: correctly laid out settings windows. 5.1.38 (2 July 2010) • Linux: made Sound: Record fixed time... work correctly (the sampling frequency was wrong). • Mac: repaired a bug introduced in 5.1.35 that could cause Praat to crash if neither Doulos SIL nor Charis SIL were installed. • Mac: correct live scrolling in Picture window and DataEditor. 5.1.37 (23 June 2010) • PitchTier window and similar windows: can drag multiple points simultaneously. • Table: t-tests report the number of degrees of freedom. • GTK: correct progress bar again. • GTK: correct behaviour of Synth menu in manipulation window. 5.1.36 (18 June 2010) • Mac: live scrolling. • Demo window: the Demo window can now run from the command line. • Motif: corrected a bug introduced in 5.1.33 whereby things in the Picture window could be placed incorrectly. • GTK: script window accepts Unicode again. 5.1.35 (10 June 2010) • TextGrid window: removed a very old bug that could lead to reversed intervals and to crashes when you inserted a boundary after using Shift-arrow and Command-arrow. • Graphics: Praat now uses Doulos SIL instead of Charis SIL if your font setting is Times and the font is nonbold and nonitalic, because Doulos SIL matches Times New Roman better. • kNN: made Ola Söder's k-nearest-neighbours classification compatible with Windows. 5.1.34 (31 May 2010) • Sound window: corrected a bug that caused Praat to crash if the analysis window was shorter than 2 samples. • GTK: scrolling in the Info window and script window. • GTK: script editor: implemented searching, replacing, and change dialogs. 5.1.33 (24 May 2010) • GTK alpha version. • Abolished resolution independence: the Sound window now looks the same on all platforms, and the Demo window has the same relative font size on your screen and on the video projector. • GTK: support for asynchronous audio output. • GTK: sound plays once rather than three times in Sound and other windows. • GTK: can click more than once in the manual. • GTK: correct pink selections in Sound and other windows. • GTK: correct dragging in TextGrid, Manipulation, and tier windows. • GTK: a working TextGrid window. • GTK: no automatic triple click in the manual (and many other windows). • GTK: moving cursor while sound is playing in Sound and other windows. • GTK: correct colours of the rectangles in Sound and other windows. • GTK: a working Group button. • GTK: correct font menus, font size menus, colour menus, line type menus. • GTK: scrolling in the manual (and many other windows). • GTK: erase old texts in manual windows. • GTK: made Picture window come back when drawing. • GTK: Info window is fronted automatically. • GTK: support sendpraat. 5.1.32 (30 April 2010) • Scripting: command Expand include files. • Scripting: accept lines that start with non-breaking spaces (as may occur in scripts copied from the web manual). • Sound files: accept MP3 files with extension written in capitals. • Linux audio recording: corrected input choice (microphone, line). 5.1.31 (4 April 2010) • Sounds: Convolve..., Sounds: Cross-correlate..., Sound: Autocorrelate..., with full documentation. • More query commands for IntensityTier. 5.1.30 (25 March 2010) • Scripting: createDirectory () can now work with absolute paths. • PointProcess: made it impossible to add a point where there is already a point. 5.1.29 (11 March 2010) • Full support for unicode values above 0xFFFF on Macintosh. 5.1.28 (10 March 2010) • TextGrid window: removed a recently introduced bug that could cause Praat to crash when inserting a boundary. 5.1.27 (7 March 2010) • Table: Wilcoxon rank sum test. • Logistic regression: corrected a bug by which a boundary would sometimes not be drawn. 5.1.26 (25 February 2010) • Experimental GTK version with the help of Franz Brauße. • Corrected a bug that could cause Praat to crash if sound playing failed twice. 5.1.25 (20 January 2010) • Script window: the new command Reopen from disk allows you to edit the script with an external editor. • Script window: removed a bug that could cause Praat to crash of you did Find again before having done any Find. 5.1.24 (15 January 2010) • Formulas run 10 to 20 percent faster. • Macintosh: support for forward delete key and Command-`. 5.1.23 (1 January 2010) • Allowed multiple files to be selected with e.g. Read from file.... • Demo window: guarded against handling the Demo window from two scripts at a time. 5.1.22 (15 December 2009) • Picture window: millions of colours instead of just twelve. • Sound window: Move frequency cursor to... 5.1.21 (30 November 2009) • Sound: Draw where... • Matrix: Draw contours... and LogisticRegression: Draw boundary... support reversed axes. • Sound window: Move frequency cursor to.... 5.1.20 (26 October 2009) • Editor windows: repaired the Synchronized Zoom And Scroll preference. 5.1.19 (21 October 2009) • Table: Randomize rows • Tables: Append (vertically) • Scripting: corrected a bug that could cause Praat to crash if the name of a field in a form contained a colon. • Windows: corrected arc drawing. 5.1.18 (9 October 2009) • The Demo window is less often automatically moved to the front (in order to allow it to pop up other editor windows). • DTW & TextGrid: To TextGrid (warp times): corrected a bug that could lead to an incorrect end time of the last interval in new IntervalTiers. 5.1.17 (22 September 2009) • Made more stereo movies readable. • Editor windows now have a Zoom Back button. 5.1.16 (17 September 2009) • Macintosh: corrected a bug that caused incorrect phonetic symbols if Charis SIL was available but SIL Doulos IPA93 was not. 5.1.15 (30 August 2009) • Corrected a bug in Sound: Change gender... introduced in 5.1.14. 5.1.14 (27 August 2009) • Windows: corrected a bug introduced in 5.1.13 that caused Praat to crash during tab navigation. • Made Sound: Change gender... compatible with elephant calls (i.e. very low F0). 5.1.13 (21 August 2009) • Script window: Find and Replace. • Picture window (and therefore Demo window!): Insert picture from file... (MacOS 10.4 and up). • Demo window: full screen (on the Mac). • Scripting: faster object selection (scripts no longer slow down when there are many objects in the list). • Scripting: variableExists. • Macintosh: PDF clipboard (MacOS 10.4 and up). 5.1.12 (4 August 2009) • Macintosh: the Picture window can save to PDF file (you need MacOS 10.4 or up). • Macintosh: corrected a bug that caused Praat to crash at start-up on MacOS 10.3. 5.1.11 (19 July 2009) 5.1.10 (8 July 2009) • Corrected a bug that could cause Praat to crash if the Demo window was closed after an execute. • OTGrammar & PairDistribution: added Get minimum number correct.... 5.1.09 (28 June 2009) • Made East-European Roman characters available in EPS files. 5.1.08 (21 June 2009) • Removed a bug introduced in 5.1.07 that could cause strange pictures in manual. • Macintosh: execute sendpraat messages immediately instead of waiting for the user to click the jumping Praat icon. 5.1.07 (12 May 2009) • Demo window: navigation by arrow keys also on Windows. • Demo window: no longer crashes on Linux. 5.1.06 (11 May 2009) • Demo window. 5.1.05 (7 May 2009) • KlattGrid update. 5.1.04 (4 April 2009) • Corrected a bug that could cause a missing text character in EPS files produced by a version of Praat running in batch. • Corrected a bug that could cause high values in a Matrix computed from a Pitch. 5.1.03 (21 March 2009) • ExperimentMFC: corrected a bug introduced in 5.0.36 that caused Praat to crash if a sound file did not exist. • Articulatory synthesis: corrected a bug that could cause Praat to crash when copying Artwords. • Macintosh: corrected a bug that could cause poor text alignment in picture. 5.1.02 (9 March 2009) • Allow pause forms without fields. • The value undefined is disallowed from all fields in command windows except Table: Set numeric value... and TableOfReal: Set value.... • TextGrid: List... and Down to Table.... • OT learning: Giorgio Magri's Weighted all up, highest down update rule. 5.1.01 (26 February 2009) • Corrected several bugs in Klatt synthesis. Links to this page What's new? 
What_was_new_in_5_3_	What was new in 5.3? 5.3 (15 October 2011) 5.2.46 (7 October 2011) • Corrected the same very old bug as in 5.2.44, but now also for opening and saving files. • Many better messages. 5.2.45 (29 September 2011) • Spectrum window: Move cursor to nearest peak. • Table: Save as comma-separated file.... • Windows: you can now change the font size of the script window. • Windows scripting: the Info window now updates while you are writing to it. • Windows: error messages now stay at the front so that you never have to click away an invisible message window anymore. 5.2.44 (23 September 2011) • Corrected a very old bug in the history mechanism (the button title wouldn't always show up). 5.2.43 (21 September 2011) • Linux: you can now change the font size of the script window. • Corrected a bug that could cause Praat to crash when opening an already open file in the script window. 5.2.42 (18 September 2011) • Corrected a bug introduced in 5.2.36 that prevented formulas from working on FormantGrid objects. 5.2.41 (17 September 2011) • Improved dashed-dotted lines in EPS files. • Corrected a bug introduced in 5.2.36 that caused Praat to crash when running an ExperimentMFC. 5.2.40 (11 September 2011) • Corrected a bug in the 64-bit Windows edition that led to an incorrect location for the preferences files. 5.2.39 (10 September 2011) • 64-bit edition for Windows. • Corrected a bug that caused Praat to crash instead of saying undefined when reporting the shimmer of a sound with fewer than 3 pulses. 5.2.38 (6 September 2011) • Corrected several bugs that were introduced in 5.2.36 in the Inspect window. 5.2.37 (2 September 2011) • Graphics: added the Chinese phonetic symbols ɿ and ʅ. See Phonetic symbols: vowels. • Corrected a bug introduced in 5.2.36 that caused Praat to crash when querying formant quantiles. 5.2.36 (30 August 2011) • Graphics: added superscript diacritics as single symbols: ʰ (\^h), ʲ (\^j), and many more; also ‿ (\_u). See Phonetic symbols: diacritics. • Praat fully converted to C++ (this may initially cause some bugs, but will be more reliable in the end). 5.2.35 (5 August 2011) • Corrected the menus of the Sound and TextGrid windows. 5.2.34 (3 August 2011) • Insert picture from file... now works on Windows (as well as on the Mac). • Corrected a bug that could cause Praat to crash when playing a LongSound. 5.2.33 (29 July 2011) • Improved the reliability of sound playing and several other things. • Improved several error messages. 5.2.32 (22 July 2011) • Corrected several problems with error messages. • Corrected a bug that could cause slow execution of scripts with forms. 5.2.31 (21 July 2011) • Corrected a bug that caused an incorrect window size in the VowelEditor. • Corrected a bug that caused incorrect error messages when opening a FLAC file as a LongSound. • Sound window: corrected a bug that could cause Praat to crash when zooming in on the left or right edge. 5.2.30 (18 July 2011) • Corrected a bug introduced in 5.2.29 whereby the list of object actions could stay empty after an error message in a script. • Corrected a bug in Klatt synthesis whereby the generation of a sound could be refused. 5.2.29 (12 July 2011) • More accurate error checking, due to Praat's conversion to C++ (last C-only version was 5.2.17). 5.2.28 (28 June 2011) • Corrected some Polygon bugs. 5.2.27 (19 June 2011) • Polygon: Draw (closed).... • PointProcess: To Sound (phonation)...: corrected a bug that could cause Praat to crash if pulses lay outside the time domain. 5.2.26 (24 May 2011) • Corrected a bug that could cause Praat to crash on some platforms when reading a Praat binary file. • ExperimentMFC: corrected a bug that caused Praat to crash if an experiment contained zero trials. • Corrected a bug that caused Praat to crash when merging multiple IntervalTiers. 5.2.25 (11 May 2011) • OT learning: corrected a crashing bug from Get candidate.... 5.2.24 (10 May 2011) • Ability to open WAV files that contain incorrect information about the number of samples. • Removed an old bug that could cause Praat to fail to read a chronological TextGrid text file. 5.2.23 (1 May 2011) • Removed a bug introduced recently that could cause Praat to crash when working with derivatives of TableOfReal (such as Distributions). 5.2.22 (14 April 2011) • ExperimentMFC: reaction times for key presses. • Linux: more reliable start-up on German systems. 5.2.21 (29 March 2011) • Scripting: removed a crashing bug introduced for colour names in 5.2.20. 5.2.20 (25 March 2011) • Scripting: removed a large memory leak for indexed variables. • Scripting: removed a small memory leak for colour names. • Support for very long file paths on the Mac. 5.2.19 (16 March 2011) • ExperimentMFC: corrected a bug introduced in 5.2.18 that could cause Praat to crash when extracting results from an incomplete experiment. 5.2.18 (9 March 2011) • ExperimentMFC: incomplete experiments can nevertheless output their incomplete results. 5.2.17 (2 March 2011) • Better names for Table opening and saving commands. • ExperimentMFC: reaction times for mouse clicks. • Linux/GTK: corrected triple clicks in ExperimentMFC. 5.2.16 (20 February 2011) • Better support for WAV files with special chunks in them. • Manual: documentation of explicit formulas for jitter measurements. 5.2.15 (11 February 2011) • Sounds: Concatenate with overlap.... 5.2.14 (8 February 2011) • Repaired crashing bug in Manipulation window introduced in 5.2.13. 5.2.13 (7 February 2011) • Renamed Write commands to Save commands. • Scripting: allow pause forms without Stop button (see Scripting 6.6. Controlling the user). • GTK: correct behaviour of default buttons. 5.2.12 (28 January 2011) • Renamed Edit buttons to View & Edit. • Better visibility of dragged things on Linux. 5.2.11 (18 January 2011) • Better visibility of dragged things (sound selection, tier points, TextGrid boundaries) on Windows and Linux. 5.2.10 (11 January 2011) • Renamed Read and Write menus to Open and Save. • Sound: use of Formula (part)... can speed up formulas appreciably. 5.2.09 (9 January 2011) • Much improved scripting tutorial. • Listening experiments can now show pictures instead of just texts (on the Mac). • EPS files can now be many miles wide instead of just 55 inches. 5.2.08 (1 January 2011) • Improved manual. • Improved memory allocation on 32-bit platforms: less probability of crashes when you approach the 2 GB memory limit gradually, and a new low on memory; save your work now warning. • Removed IntervalTier and TextTier datatypes from Praat (old scripts that use them will continue to work). 5.2.07 (24 December 2010) • Support for reading and writing multi-channel sound files (i.e. above two-channel stereo). 5.2.06 (18 December 2010) • Picture window: a new (the fourth) line type, namely dashed-dotted. • Support for analysing and drawing multi-channel sounds (i.e. above two-channel stereo). • Can read some EEG files (BioSemi 24-bit BDF) as a Sound and a TextGrid object. • Linux: compatibility with computers without English language support. • Macintosh: support for high-plane (i.e. very uncommon) Unicode characters in file names (as already existed on Unix and Windows). 5.2.05 (4 December 2010) • Regular expressions: better Unicode support. • Scripting window: command Convert to C string. 5.2.04 (27 November 2010) • Scripting: allow directory (folder) selector windows; see Scripting 6.6. Controlling the user. 5.2.03 (19 November 2010) • Scripting: support for string arrays. 5.2.02 (17 November 2010) • TextGrid window: corrected a bug that caused Praat to crash (instead of doing nothing) when you tried to add boundaries if the selection ran from the penultimate interval to the end of the TextGrid. • Scripting: support for arrays with multiple indexes. • Linux: made spectrogram drawing compatible with Ubuntu 10.10. • Linux: made sound more easily available on Ubuntu 10.10. 5.2.01 (4 November 2010) • Scripting: support for numeric arrays. Links to this page What's new? 
Willems__1986_	Willems (1986) Lei Willems (1986): Robust formant analysis. IPO report 529: 1–25. Eindhoven: Institute for Perception Research. Links to this page Sound: To Formant (sl)... 
WordList	WordList One of the types of objects in Praat. An object of class WordList contains a sorted list of strings in a system-independent format. WordList objects can be used for spelling checking after conversion to a SpellingChecker object. 1. How to create a WordList object You will normally create a WordList object by reading a binary WordList file. You'll use the generic Read from file... command from the Open menu. See below under 3 for how to create such a file. 2. What you can do with a Wordlist object The main functionality of a WordList is its ability to tell you whether it contains a certain string. If you select a WordList, you can query the existence of a specific word by using the Has word command. You supply the word and press OK. If the WordList does contain the word, the value 1 will be written to the Info window; otherwise, the value 0 will be written. 3. How to create a binary WordList file You can create a binary (compressed) WordList file from a simple text file that contains a long list of words. Perhaps such a text file has been supplied by a lexicographic institution in your country; because of copyright issues, such word lists cannot be distributed with the Praat program. To convert the simple text file into a compressed WordList file, you basically take the following steps: Read Strings from raw text file: lexicon.iso Genericize Sort To WordList Save as binary file: lexicon.WordList I'll explain these steps in detail. For instance, a simple text file may contain the following list of words: cook cooked cookie cookies cooking cooks Copenhagen Købnhavn München Munich ångström These are just 11 words, but the procedure will work fine if you have a million of them, and enough memory in your computer. You can read the file into a Strings object with Read Strings from raw text file... from the Open menu in the Objects window. The resulting Strings object contains 11 strings in the above order, as you can verify by viewing them with Inspect. In general, the Strings object will occupy a lot of memory, and be slow to read in. For instance, a certain list of more than 300,000 Dutch word forms occupies 3.6 MB on disk, and will occupy at least 7 MB of memory after it is read in. The extra 3.4 MB arise because the Strings object contains a pointer to each of the strings, and each of the strings is in a separately allocated part of the memory heap. Moreover, it takes 8 seconds on an average 1999 computer to read this object into memory. For these reasons, we will use the WordList object if we need a sorted list for spelling checking. If you select the Strings, you can click the To WordList button. However, you will get the following complaint: String Købnhavn not generic. Please genericize first. This complaint means that the strings are still in your computer's native text format, which is ISO-Latin1 for Unix and Windows computers, or Mac encoding for Macintosh computers. So you press the Genericize button. You can see that the Strings object changes to cook cooked cookie cookies cooking cooks Copenhagen K\o/bnhavn M\unchen Munich \aongstr\om The strings are now in the generic system-independent format that is used everywhere in Praat to draw strings (see Special symbols). You can again try to click the To WordList button. However, you will get a complaint again: String Copenhagen not sorted. Please sort first. This complaint means that the strings have not been sorted in ASCII sorting order. So you click Sort, and the Strings object becomes: Copenhagen K\o/bnhavn M\unchen Munich \aongstr\om cook cooked cookie cookies cooking cooks The strings are now in the ASCII order, in which capitals come before lower-case letters, and backslashes come in between these two series. Clicking To WordList now succeeds, and a WordList object appears in the list. If you save it to a text file (with the Save menu), you will get the following file: File type = ooTextFile Object class = WordList string = Copenhagen K\o/bnhavn M\unchen Munich \aongstr\om cook cooked cookie cookies cooking cooks” Note that the double quotes () that appear inside the strings, have been doubled, as is done everywhere inside strings in Praat text files. After you have created a WordList text file, you can create a WordList object just by reading this file with Read from file... from the Open menu. The WordList object has two advantages over the Strings object. First, it won't take up more memory than the original word list. This is because the WordList is stored as a single string: a contiguous list of strings, separated by new-line symbols. Thus, our 300,000-word list will take up only 3.6 MB, and be read in 4 seconds. However, disk storage and reading can again be improved by compressing the word list. We can take advantage of the sorting, by noting for each entry how many leading characters are equal to those of the previous entry. The list then becomes something equivalent to Copenhagen 0 K\o/bnhavn 0 M\unchen 1 unich 0 \aongstr\om 0 cook 4 ed 4 ie 6 s 5 ng 4 s You can save the WordList compressed in this way as a binary file with Save as binary file.... For our 300,000-word list, this file takes up only 1.1 MB and can be read into memory (with Read from file...) in a single second. When read into memory, the WordList object is again expanded to 3.6 MB to allow rapid searching. 
Write_to_console	Write to console One of the commands in the Save menu. You can choose this command after selecting one object. The data that it contains, is written to the Console window (the terminal window, if you started up Praat from a terminal window), in the same format as with the Save as text file... command, except for the first line, which reads something like: Write to console: class Sound, name hallo 
Young__Takane___Lewyckyj__1978_	Young, Takane & Lewyckyj (1978) F.W. Young, Y. Takane & R. Lewyckyj (1978): Three notes on ALSCAL. Psychometrika 43: 433–435. Links to this page CANDECOMP Distance: To Configuration (ytl)... 
Zhang_et_al___2003_	Zhang et al. (2003) Zhihua Zhang & Chibiao Chen & Jian Sun & Kap Luk Chan (2003): EM algorithms for Gaussian mixtures with split-and-merge operation. Pattern Recognition 36: 1973–1983. Links to this page GaussianMixture: Split component... 
Ziehe_et_al___2004_	Ziehe et al. (2004) Andreas Ziehe, Pavel Laskov, Guido Nolte & Klaus-Robert Müller (2004): A fast algorithm for joint diagonalization with non-orthogonal transformations and its application to blind source separation, Journal of Machine Learning Research 5: 777–800. Links to this page Sound: To Sound (blind source separation)... 
